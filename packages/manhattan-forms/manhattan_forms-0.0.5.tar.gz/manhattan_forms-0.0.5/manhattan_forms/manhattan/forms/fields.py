from datetime import datetime

from wtforms.fields import Field, SelectFieldBase, SelectMultipleField
from wtforms.fields.core import UnboundField
from wtforms.widgets import CheckboxInput, ListWidget, TextInput

from .utils import to_object_id

__all__ = [
    'CheckboxField',
    'DocumentCheckboxField',
    'TimeField'
    ]


class CheckboxField(SelectMultipleField):
    """
    The `Checkbox` field supports for a list of checkboxes within a form, for
    single checkboxes use the `wtforms.fields.BooleanField`.
    """

    widget = ListWidget(prefix_label=False)
    option_widget = CheckboxInput()


class DocumentCheckboxField(CheckboxField):
    """
    The `DocumentCheckboxField` fields supports a list of checkboxes where the
    choices are generated by select documents from the database.
    """

    def __new__(cls, *args, **kwargs):
        if '_form' in kwargs and '_name' in kwargs:
            field = super(Field, cls).__new__(cls)

            # Set the form attribute against the field
            field._form = kwargs['_form']

            return field
        else:
            return UnboundField(cls, *args, **kwargs)

    def __init__(self, label=None, frame_cls=None, filter=None, sort=None,
            projection=None, limit=None, id_attr='_id', label_attr=None,
            validators=None, coerce=to_object_id, **kwargs):

        print(frame_cls)

        assert frame_cls is not None, \
                'You must specify the `frame_cls` to be used'

        SelectFieldBase.__init__(self, label, validators, **kwargs)
        self.coerce = coerce

        # Arguments used to build the choices
        self._frame_cls = frame_cls
        self._filter = filter
        self._sort = sort
        self._projection = projection
        self._limit = limit
        self._id_attr = id_attr
        self._label_attr = label_attr

    @property
    def choices(self):
        """Build the choices for the field a selection of documents"""

        # Check if the filter is a callable object in which case call it and use
        # the result as the filter.
        filter = self._filter
        if callable(filter):
            filter = filter(self._form, self)

        # Build the filter args
        filter_args = {
            'sort': self._sort,
            'projection': self._projection,
            'limit': self._limit
            }
        filter_args = {k: v for k, v in filter_args.items() if v}

        # Select the documents
        documents = self._frame_cls.many(filter, **filter_args)

        # Build the choices
        return [
            (
                getattr(d, self._id_attr),
                getattr(d, self._label_attr) if self._label_attr else str(d)
            )
            for d in documents]


class TimeField(Field):
    """
    The `TimeField` accepts a time string in 24hr format (by default HH:MM) and
    if valid returns a `datetime.time` instance.
    """

    widget = TextInput()

    def __init__(self, label=None, validators=None, format='%H:%M', **kwargs):
        super().__init__(label, validators, **kwargs)
        self.format = format

    def _value(self):
        if self.raw_data:
            return ' '.join(self.raw_data)
        elif self.data is not None:
            return self.data.strftime(self.format)
        return ''

    def process_formdata(self, values):
        if not values:
            return

        time_str = ' '.join(values)
        try:
            self.data = datetime.strptime(time_str, self.format).time()
        except ValueError:
            self.data = None
            raise ValueError(self.gettext('Not a valid time value.'))