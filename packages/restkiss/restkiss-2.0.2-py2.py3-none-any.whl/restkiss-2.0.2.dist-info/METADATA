Metadata-Version: 2.0
Name: restkiss
Version: 2.0.2
Summary: A lightweight REST miniframework for Python.
Home-page: http://github.com/CraveFood/restkiss
Author: Bruno Marques
Author-email: bruno@cravefood.services
License: UNKNOWN
Platform: UNKNOWN
Classifier: Development Status :: 5 - Production/Stable
Classifier: Environment :: Web Environment
Classifier: Framework :: Django
Classifier: Framework :: Flask
Classifier: Framework :: Pyramid
Classifier: Intended Audience :: Developers
Classifier: License :: OSI Approved :: BSD License
Classifier: Operating System :: OS Independent
Classifier: Programming Language :: Python
Classifier: Programming Language :: Python :: 2
Classifier: Programming Language :: Python :: 3
Classifier: Topic :: Utilities
Requires: six(>=1.4.0)
Requires-Dist: six (>=1.4.0)

========
restkiss
========

.. image:: https://travis-ci.org/CraveFood/restkiss.png?branch=master
        :target: https://travis-ci.org/CraveFood/restkiss

A fork of the restless_ lightweight REST miniframework for Python.

Documentation is at http://restkiss.readthedocs.io/.

Works great with Django_, Flask_, Pyramid_, Tornado_ & Itty_, but should be useful for
many other Python web frameworks. Based on the lessons learned from Tastypie_
& other REST libraries.

.. _restless: http://github.com/toastdriven/restless
.. _Django: http://djangoproject.com/
.. _Flask: http://flask.pocoo.org/
.. _Pyramid: http://www.pylonsproject.org/
.. _Itty: https://pypi.python.org/pypi/itty
.. _Tastypie: http://tastypieapi.org/
.. _Tornado: http://www.tornadoweb.org/
.. _tox: https://tox.readthedocs.io/


Features
========

* Small, fast codebase
* JSON output by default, but overridable
* RESTful
* Python 3.2+ (with shims to make broke-ass Python 2.6+ work)
* Flexible


Anti-Features
=============

Things that will never be added to the core library - but plugins are encouraged!

* Automatic ORM integration
* Authorization (per-object or not)
* Extensive filtering options
* XML output
* Metaclasses
* Mixins
* HATEOAS


Why?
====

Creator [@toastdriven](http://github.com/toastdriven) had a very specific goal when building the original
restless_, and our goal is to respect it. Here it follows: 

> Quite simply, I care about creating flexible & RESTful APIs. In building
> Tastypie, I tried to create something extremely complete & comprehensive.
> The result was writing a lot of hook methods (for easy extensibility) & a lot
> of (perceived) bloat, as I tried to accommodate for everything people might
> want/need in a flexible/overridable manner.
>
> But in reality, all I really ever personally want are the RESTful verbs, JSON
> serialization & the ability of override behavior.
>
> This one is written for me, but maybe it's useful to you.


Manifesto
=========

Rather than try to build something that automatically does the typically
correct thing within each of the views, it's up to you to implement the bodies
of various HTTP methods.

Example code:

.. code:: python

    # posts/api.py
    from django.contrib.auth.models import User

    from restkiss.dj import DjangoResource
    from restkiss.preparers import FieldsPreparer

    from posts.models import Post


    class PostResource(DjangoResource):
        # Controls what data is included in the serialized output.
        preparer = FieldsPreparer(fields={
            'id': 'id',
            'title': 'title',
            'author': 'user.username',
            'body': 'content',
            'posted_on': 'posted_on',
        })

        # GET /
        def list(self):
            return Post.objects.all()

        # GET /pk/
        def detail(self, pk):
            return Post.objects.get(id=pk)

        # POST /
        def create(self):
            return Post.objects.create(
                title=self.data['title'],
                user=User.objects.get(username=self.data['author']),
                content=self.data['body']
            )

        # PUT /pk/
        def update(self, pk):
            try:
                post = Post.objects.get(id=pk)
            except Post.DoesNotExist:
                post = Post()

            post.title = self.data['title']
            post.user = User.objects.get(username=self.data['author'])
            post.content = self.data['body']
            post.save()
            return post

        # DELETE /pk/
        def delete(self, pk):
            Post.objects.get(id=pk).delete()

Hooking it up:

.. code:: python

    # api/urls.py
    from django.conf.urls.default import url, include

    from posts.api import PostResource

    urlpatterns = [
        # The usual suspects, then...

        url(r'^api/posts/', include(PostResource.urls())),
    ]


Licence
=======

BSD


Running the Tests
=================

The test suite uses tox_ for simultaneous support of multiple versions of both
Python and Django. The current versions of Python supported are:

* CPython 2.7
* CPython 3.4
* CPython 3.5
* PyPy (Python 2.7)
* PyPy3 (Python 3.2)
* PyPy3 beta (Python 3.3)

You just need to install the Python interpreters above and the `tox` package
(available via `pip`), then run the `tox` command.


