# coding: utf-8

"""
VolumeEx.py

 The Clear BSD License

 Copyright (c) â€“ 2016, NetApp, Inc. All rights reserved.

 Redistribution and use in source and binary forms, with or without modification, are permitted (subject to the limitations in the disclaimer below) provided that the following conditions are met:

 * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.

 * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

 * Neither the name of NetApp, Inc. nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.

 NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
"""

from pprint import pformat
from six import iteritems


class VolumeEx(object):
    """
    NOTE: This class is auto generated by the swagger code generator program.
    Do not edit the class manually.
    """
    def __init__(self):
        """
        VolumeEx - a model defined in Swagger

        :param dict swaggerTypes: The key is attribute name
                                  and the value is attribute type.
        :param dict attributeMap: The key is attribute name
                                  and the value is json key in definition.
        """
        self.swagger_types = {
            'offline': 'bool',  # (required parameter)
            'extreme_protection': 'bool',  # (required parameter)
            'volume_handle': 'int',  # (required parameter)
            'raid_level': 'str',  # (required parameter)
            'sector_offset': 'int',  # (required parameter)
            'world_wide_name': 'str',  # (required parameter)
            'label': 'str',  # (required parameter)
            'blk_size': 'int',  # (required parameter)
            'capacity': 'int',  # (required parameter)
            'recon_priority': 'int',  # (required parameter)
            'segment_size': 'int',  # (required parameter)
            'action': 'str',  # (required parameter)
            'cache': 'VolumeCache',  # (required parameter)
            'media_scan': 'VolumeMediaScanParams',  # (required parameter)
            'volume_ref': 'str',  # (required parameter)
            'status': 'str',  # (required parameter)
            'volume_group_ref': 'str',  # (required parameter)
            'current_manager': 'str',  # (required parameter)
            'preferred_manager': 'str',  # (required parameter)
            'perms': 'VolumePerms',  # (required parameter)
            'mgmt_client_attribute': 'int',  # (required parameter)
            'dss_prealloc_enabled': 'bool',  # (required parameter)
            'dss_max_segment_size': 'int',  # (required parameter)
            'pre_read_redundancy_check_enabled': 'bool',  # (required parameter)
            'protection_information_capable': 'bool',  # (required parameter)
            'protection_type': 'str',  # (required parameter)
            'application_tag_owned': 'bool',  # (required parameter)
            'repaired_block_count': 'int',  # (required parameter)
            'volume_use': 'str',  
            'volume_full': 'bool',  
            'volume_copy_target': 'bool',  
            'volume_copy_source': 'bool',  
            'pit_base_volume': 'bool',  
            'async_mirror_target': 'bool',  
            'async_mirror_source': 'bool',  
            'remote_mirror_source': 'bool',  
            'remote_mirror_target': 'bool',  
            'disk_pool': 'bool',  
            'flash_cached': 'bool',  
            'increasing_by': 'int',  
            'metadata': 'list[VolumeMetadataItem]',  
            'data_assurance': 'bool',  
            'object_type': 'str',  
            'name': 'str',  
            'id': 'str',  
            'wwn': 'str',  
            'cache_settings': 'VolumeCache',  # (required parameter)
            'thin_provisioned': 'bool',  
            'list_of_mappings': 'list[LUNMapping]',  
            'mapped': 'bool',  # (required parameter)
            'current_controller_id': 'str',  
            'preferred_controller_id': 'str',  
            'online_volume_copy': 'bool',  
            'total_size_in_bytes': 'int'
        }

        self.attribute_map = {
            'offline': 'offline',  # (required parameter)
            'extreme_protection': 'extremeProtection',  # (required parameter)
            'volume_handle': 'volumeHandle',  # (required parameter)
            'raid_level': 'raidLevel',  # (required parameter)
            'sector_offset': 'sectorOffset',  # (required parameter)
            'world_wide_name': 'worldWideName',  # (required parameter)
            'label': 'label',  # (required parameter)
            'blk_size': 'blkSize',  # (required parameter)
            'capacity': 'capacity',  # (required parameter)
            'recon_priority': 'reconPriority',  # (required parameter)
            'segment_size': 'segmentSize',  # (required parameter)
            'action': 'action',  # (required parameter)
            'cache': 'cache',  # (required parameter)
            'media_scan': 'mediaScan',  # (required parameter)
            'volume_ref': 'volumeRef',  # (required parameter)
            'status': 'status',  # (required parameter)
            'volume_group_ref': 'volumeGroupRef',  # (required parameter)
            'current_manager': 'currentManager',  # (required parameter)
            'preferred_manager': 'preferredManager',  # (required parameter)
            'perms': 'perms',  # (required parameter)
            'mgmt_client_attribute': 'mgmtClientAttribute',  # (required parameter)
            'dss_prealloc_enabled': 'dssPreallocEnabled',  # (required parameter)
            'dss_max_segment_size': 'dssMaxSegmentSize',  # (required parameter)
            'pre_read_redundancy_check_enabled': 'preReadRedundancyCheckEnabled',  # (required parameter)
            'protection_information_capable': 'protectionInformationCapable',  # (required parameter)
            'protection_type': 'protectionType',  # (required parameter)
            'application_tag_owned': 'applicationTagOwned',  # (required parameter)
            'repaired_block_count': 'repairedBlockCount',  # (required parameter)
            'volume_use': 'volumeUse',  
            'volume_full': 'volumeFull',  
            'volume_copy_target': 'volumeCopyTarget',  
            'volume_copy_source': 'volumeCopySource',  
            'pit_base_volume': 'pitBaseVolume',  
            'async_mirror_target': 'asyncMirrorTarget',  
            'async_mirror_source': 'asyncMirrorSource',  
            'remote_mirror_source': 'remoteMirrorSource',  
            'remote_mirror_target': 'remoteMirrorTarget',  
            'disk_pool': 'diskPool',  
            'flash_cached': 'flashCached',  
            'increasing_by': 'increasingBy',  
            'metadata': 'metadata',  
            'data_assurance': 'dataAssurance',  
            'object_type': 'objectType',  
            'name': 'name',  
            'id': 'id',  
            'wwn': 'wwn',  
            'cache_settings': 'cacheSettings',  # (required parameter)
            'thin_provisioned': 'thinProvisioned',  
            'list_of_mappings': 'listOfMappings',  
            'mapped': 'mapped',  # (required parameter)
            'current_controller_id': 'currentControllerId',  
            'preferred_controller_id': 'preferredControllerId',  
            'online_volume_copy': 'onlineVolumeCopy',  
            'total_size_in_bytes': 'totalSizeInBytes'
        }

        self._offline = None
        self._extreme_protection = None
        self._volume_handle = None
        self._raid_level = None
        self._sector_offset = None
        self._world_wide_name = None
        self._label = None
        self._blk_size = None
        self._capacity = None
        self._recon_priority = None
        self._segment_size = None
        self._action = None
        self._cache = None
        self._media_scan = None
        self._volume_ref = None
        self._status = None
        self._volume_group_ref = None
        self._current_manager = None
        self._preferred_manager = None
        self._perms = None
        self._mgmt_client_attribute = None
        self._dss_prealloc_enabled = None
        self._dss_max_segment_size = None
        self._pre_read_redundancy_check_enabled = None
        self._protection_information_capable = None
        self._protection_type = None
        self._application_tag_owned = None
        self._repaired_block_count = None
        self._volume_use = None
        self._volume_full = None
        self._volume_copy_target = None
        self._volume_copy_source = None
        self._pit_base_volume = None
        self._async_mirror_target = None
        self._async_mirror_source = None
        self._remote_mirror_source = None
        self._remote_mirror_target = None
        self._disk_pool = None
        self._flash_cached = None
        self._increasing_by = None
        self._metadata = None
        self._data_assurance = None
        self._object_type = None
        self._name = None
        self._id = None
        self._wwn = None
        self._cache_settings = None
        self._thin_provisioned = None
        self._list_of_mappings = None
        self._mapped = None
        self._current_controller_id = None
        self._preferred_controller_id = None
        self._online_volume_copy = None
        self._total_size_in_bytes = None

    @property
    def offline(self):
        """
        Gets the offline of this VolumeEx.
        An indication of whether the volume is currently offline.

        :return: The offline of this VolumeEx.
        :rtype: bool
        :required/optional: required
        """
        return self._offline

    @offline.setter
    def offline(self, offline):
        """
        Sets the offline of this VolumeEx.
        An indication of whether the volume is currently offline.

        :param offline: The offline of this VolumeEx.
        :type: bool
        """
        self._offline = offline

    @property
    def extreme_protection(self):
        """
        Gets the extreme_protection of this VolumeEx.
        An indication of whether the volume is configured for extreme protection. Such configurations generally call for extensive consistency checks and parity validations with each I/O request to the volume.

        :return: The extreme_protection of this VolumeEx.
        :rtype: bool
        :required/optional: required
        """
        return self._extreme_protection

    @extreme_protection.setter
    def extreme_protection(self, extreme_protection):
        """
        Sets the extreme_protection of this VolumeEx.
        An indication of whether the volume is configured for extreme protection. Such configurations generally call for extensive consistency checks and parity validations with each I/O request to the volume.

        :param extreme_protection: The extreme_protection of this VolumeEx.
        :type: bool
        """
        self._extreme_protection = extreme_protection

    @property
    def volume_handle(self):
        """
        Gets the volume_handle of this VolumeEx.
        The internal identifier value associated with this volume. When the Storage Partitions feature is NOT present, this value represents the logical unit number (LUN) that is used to access the volume via the host I/O path. If the Storage Partitions feature IS enabled, this field has no external meaning.

        :return: The volume_handle of this VolumeEx.
        :rtype: int
        :required/optional: required
        """
        return self._volume_handle

    @volume_handle.setter
    def volume_handle(self, volume_handle):
        """
        Sets the volume_handle of this VolumeEx.
        The internal identifier value associated with this volume. When the Storage Partitions feature is NOT present, this value represents the logical unit number (LUN) that is used to access the volume via the host I/O path. If the Storage Partitions feature IS enabled, this field has no external meaning.

        :param volume_handle: The volume_handle of this VolumeEx.
        :type: int
        """
        self._volume_handle = volume_handle

    @property
    def raid_level(self):
        """
        Gets the raid_level of this VolumeEx.
        The RAID level for which this volume is configured.

        :return: The raid_level of this VolumeEx.
        :rtype: str
        :required/optional: required
        """
        return self._raid_level

    @raid_level.setter
    def raid_level(self, raid_level):
        """
        Sets the raid_level of this VolumeEx.
        The RAID level for which this volume is configured.

        :param raid_level: The raid_level of this VolumeEx.
        :type: str
        """
        allowed_values = ["raidUnsupported", "raidAll", "raid0", "raid1", "raid3", "raid5", "raid6", "raidDiskPool", "__UNDEFINED"]
        if raid_level not in allowed_values:
            raise ValueError(
                "Invalid value for `raid_level`, must be one of {0}"
                .format(allowed_values)
            )
        self._raid_level = raid_level

    @property
    def sector_offset(self):
        """
        Gets the sector_offset of this VolumeEx.
        The sector offset of this volume within its volume group. This value is provided only to allow the client application to determine the relative positions of multiple volumes within a given volume group. No other assumptions or computations should be made with this value.

        :return: The sector_offset of this VolumeEx.
        :rtype: int
        :required/optional: required
        """
        return self._sector_offset

    @sector_offset.setter
    def sector_offset(self, sector_offset):
        """
        Sets the sector_offset of this VolumeEx.
        The sector offset of this volume within its volume group. This value is provided only to allow the client application to determine the relative positions of multiple volumes within a given volume group. No other assumptions or computations should be made with this value.

        :param sector_offset: The sector_offset of this VolumeEx.
        :type: int
        """
        self._sector_offset = sector_offset

    @property
    def world_wide_name(self):
        """
        Gets the world_wide_name of this VolumeEx.
        A variable-length opaque field that provides the volume's worldwide unique identification value.

        :return: The world_wide_name of this VolumeEx.
        :rtype: str
        :required/optional: required
        """
        return self._world_wide_name

    @world_wide_name.setter
    def world_wide_name(self, world_wide_name):
        """
        Sets the world_wide_name of this VolumeEx.
        A variable-length opaque field that provides the volume's worldwide unique identification value.

        :param world_wide_name: The world_wide_name of this VolumeEx.
        :type: str
        """
        self._world_wide_name = world_wide_name

    @property
    def label(self):
        """
        Gets the label of this VolumeEx.
        The user-assigned symbol label associated with the volume.

        :return: The label of this VolumeEx.
        :rtype: str
        :required/optional: required
        """
        return self._label

    @label.setter
    def label(self, label):
        """
        Sets the label of this VolumeEx.
        The user-assigned symbol label associated with the volume.

        :param label: The label of this VolumeEx.
        :type: str
        """
        self._label = label

    @property
    def blk_size(self):
        """
        Gets the blk_size of this VolumeEx.
        The block size (in bytes) of the volume.

        :return: The blk_size of this VolumeEx.
        :rtype: int
        :required/optional: required
        """
        return self._blk_size

    @blk_size.setter
    def blk_size(self, blk_size):
        """
        Sets the blk_size of this VolumeEx.
        The block size (in bytes) of the volume.

        :param blk_size: The blk_size of this VolumeEx.
        :type: int
        """
        self._blk_size = blk_size

    @property
    def capacity(self):
        """
        Gets the capacity of this VolumeEx.
        The capacity (in bytes) of the volume.

        :return: The capacity of this VolumeEx.
        :rtype: int
        :required/optional: required
        """
        return self._capacity

    @capacity.setter
    def capacity(self, capacity):
        """
        Sets the capacity of this VolumeEx.
        The capacity (in bytes) of the volume.

        :param capacity: The capacity of this VolumeEx.
        :type: int
        """
        self._capacity = capacity

    @property
    def recon_priority(self):
        """
        Gets the recon_priority of this VolumeEx.
        The reconstruction priority value for the volume. This value is in the range 0-4, with 0 indicating that reconstruction is favored over any I/O, and 4 indicating that reconstruction should be performed with minimal impact to I/O. Intermediate values indicate various levels of compromise between these two extremes.

        :return: The recon_priority of this VolumeEx.
        :rtype: int
        :required/optional: required
        """
        return self._recon_priority

    @recon_priority.setter
    def recon_priority(self, recon_priority):
        """
        Sets the recon_priority of this VolumeEx.
        The reconstruction priority value for the volume. This value is in the range 0-4, with 0 indicating that reconstruction is favored over any I/O, and 4 indicating that reconstruction should be performed with minimal impact to I/O. Intermediate values indicate various levels of compromise between these two extremes.

        :param recon_priority: The recon_priority of this VolumeEx.
        :type: int
        """
        self._recon_priority = recon_priority

    @property
    def segment_size(self):
        """
        Gets the segment_size of this VolumeEx.
        The segment size (in bytes) of the volume. The segment size is, for the most part, an indication of the stripe depth used to lay out the volume's block addresses.

        :return: The segment_size of this VolumeEx.
        :rtype: int
        :required/optional: required
        """
        return self._segment_size

    @segment_size.setter
    def segment_size(self, segment_size):
        """
        Sets the segment_size of this VolumeEx.
        The segment size (in bytes) of the volume. The segment size is, for the most part, an indication of the stripe depth used to lay out the volume's block addresses.

        :param segment_size: The segment_size of this VolumeEx.
        :type: int
        """
        self._segment_size = segment_size

    @property
    def action(self):
        """
        Gets the action of this VolumeEx.
        An indication of what current long-running activity, if any, is currently in progress on the volume.

        :return: The action of this VolumeEx.
        :rtype: str
        :required/optional: required
        """
        return self._action

    @action.setter
    def action(self, action):
        """
        Sets the action of this VolumeEx.
        An indication of what current long-running activity, if any, is currently in progress on the volume.

        :param action: The action of this VolumeEx.
        :type: str
        """
        allowed_values = ["none", "copyback", "initializing", "reconstructing", "remappingDce", "remappingDrm", "remappingDcedrm", "remappingDseg", "remappingDve", "remappingDcedve", "remappingInternal", "remappingDefrag", "formatting", "synchronizing", "parityScan", "volumeCopy", "snapshotRollback", "pitRollback", "asyncMirrorGroupInitialSync", "reconstructingCritical", "rebalancing", "copyThenFail", "copyThenFailPending", "copyThenReplace", "copyThenReplaceAndFail", "thinDefrag", "creating", "deleting", "__UNDEFINED"]
        if action not in allowed_values:
            raise ValueError(
                "Invalid value for `action`, must be one of {0}"
                .format(allowed_values)
            )
        self._action = action

    @property
    def cache(self):
        """
        Gets the cache of this VolumeEx.
        The volume-specific caching parameters currently in effect for the volume.

        :return: The cache of this VolumeEx.
        :rtype: VolumeCache
        :required/optional: required
        """
        return self._cache

    @cache.setter
    def cache(self, cache):
        """
        Sets the cache of this VolumeEx.
        The volume-specific caching parameters currently in effect for the volume.

        :param cache: The cache of this VolumeEx.
        :type: VolumeCache
        """
        self._cache = cache

    @property
    def media_scan(self):
        """
        Gets the media_scan of this VolumeEx.
        The volume-specific media scan settings currently in effect for the volume.

        :return: The media_scan of this VolumeEx.
        :rtype: VolumeMediaScanParams
        :required/optional: required
        """
        return self._media_scan

    @media_scan.setter
    def media_scan(self, media_scan):
        """
        Sets the media_scan of this VolumeEx.
        The volume-specific media scan settings currently in effect for the volume.

        :param media_scan: The media_scan of this VolumeEx.
        :type: VolumeMediaScanParams
        """
        self._media_scan = media_scan

    @property
    def volume_ref(self):
        """
        Gets the volume_ref of this VolumeEx.
        The unique identification value for this volume. Other objects may use this reference value to refer to the volume.

        :return: The volume_ref of this VolumeEx.
        :rtype: str
        :required/optional: required
        """
        return self._volume_ref

    @volume_ref.setter
    def volume_ref(self, volume_ref):
        """
        Sets the volume_ref of this VolumeEx.
        The unique identification value for this volume. Other objects may use this reference value to refer to the volume.

        :param volume_ref: The volume_ref of this VolumeEx.
        :type: str
        """
        self._volume_ref = volume_ref

    @property
    def status(self):
        """
        Gets the status of this VolumeEx.
        The current operational state of the volume.

        :return: The status of this VolumeEx.
        :rtype: str
        :required/optional: required
        """
        return self._status

    @status.setter
    def status(self, status):
        """
        Sets the status of this VolumeEx.
        The current operational state of the volume.

        :param status: The status of this VolumeEx.
        :type: str
        """
        allowed_values = ["optimal", "degraded", "failed", "impaired", "creating", "deleting", "__UNDEFINED"]
        if status not in allowed_values:
            raise ValueError(
                "Invalid value for `status`, must be one of {0}"
                .format(allowed_values)
            )
        self._status = status

    @property
    def volume_group_ref(self):
        """
        Gets the volume_group_ref of this VolumeEx.
        The volume group reference value of the volume group on which this volume resides.

        :return: The volume_group_ref of this VolumeEx.
        :rtype: str
        :required/optional: required
        """
        return self._volume_group_ref

    @volume_group_ref.setter
    def volume_group_ref(self, volume_group_ref):
        """
        Sets the volume_group_ref of this VolumeEx.
        The volume group reference value of the volume group on which this volume resides.

        :param volume_group_ref: The volume_group_ref of this VolumeEx.
        :type: str
        """
        self._volume_group_ref = volume_group_ref

    @property
    def current_manager(self):
        """
        Gets the current_manager of this VolumeEx.
        The reference value of the controller that currently owns (i.e. manages) this volume. In non-AVT (Auto Volume Transfer) mode, host I/O access to the blocks in this volume is permitted only through the controller that is the current manager. In AVT mode, an I/O access to the controller that is not the current manager causes it to automatically become the current manager.

        :return: The current_manager of this VolumeEx.
        :rtype: str
        :required/optional: required
        """
        return self._current_manager

    @current_manager.setter
    def current_manager(self, current_manager):
        """
        Sets the current_manager of this VolumeEx.
        The reference value of the controller that currently owns (i.e. manages) this volume. In non-AVT (Auto Volume Transfer) mode, host I/O access to the blocks in this volume is permitted only through the controller that is the current manager. In AVT mode, an I/O access to the controller that is not the current manager causes it to automatically become the current manager.

        :param current_manager: The current_manager of this VolumeEx.
        :type: str
        """
        self._current_manager = current_manager

    @property
    def preferred_manager(self):
        """
        Gets the preferred_manager of this VolumeEx.
        The reference value of the controller that is the preferred manager of the volume. The preferred manager is tracked independent of the current manager, since the current manager may be switched dynamically as a result of host-base multi-path transitions. Later, when the error conditions that cause a multi-path transition have been corrected it is still possible to determine the preferred manager and switch ownership back to it.

        :return: The preferred_manager of this VolumeEx.
        :rtype: str
        :required/optional: required
        """
        return self._preferred_manager

    @preferred_manager.setter
    def preferred_manager(self, preferred_manager):
        """
        Sets the preferred_manager of this VolumeEx.
        The reference value of the controller that is the preferred manager of the volume. The preferred manager is tracked independent of the current manager, since the current manager may be switched dynamically as a result of host-base multi-path transitions. Later, when the error conditions that cause a multi-path transition have been corrected it is still possible to determine the preferred manager and switch ownership back to it.

        :param preferred_manager: The preferred_manager of this VolumeEx.
        :type: str
        """
        self._preferred_manager = preferred_manager

    @property
    def perms(self):
        """
        Gets the perms of this VolumeEx.
        Operations allowed on this volume.

        :return: The perms of this VolumeEx.
        :rtype: VolumePerms
        :required/optional: required
        """
        return self._perms

    @perms.setter
    def perms(self, perms):
        """
        Sets the perms of this VolumeEx.
        Operations allowed on this volume.

        :param perms: The perms of this VolumeEx.
        :type: VolumePerms
        """
        self._perms = perms

    @property
    def mgmt_client_attribute(self):
        """
        Gets the mgmt_client_attribute of this VolumeEx.
        For use by management client.

        :return: The mgmt_client_attribute of this VolumeEx.
        :rtype: int
        :required/optional: required
        """
        return self._mgmt_client_attribute

    @mgmt_client_attribute.setter
    def mgmt_client_attribute(self, mgmt_client_attribute):
        """
        Sets the mgmt_client_attribute of this VolumeEx.
        For use by management client.

        :param mgmt_client_attribute: The mgmt_client_attribute of this VolumeEx.
        :type: int
        """
        self._mgmt_client_attribute = mgmt_client_attribute

    @property
    def dss_prealloc_enabled(self):
        """
        Gets the dss_prealloc_enabled of this VolumeEx.
        True if dynamic segment sizing pre-allocation is enabled for the volume.

        :return: The dss_prealloc_enabled of this VolumeEx.
        :rtype: bool
        :required/optional: required
        """
        return self._dss_prealloc_enabled

    @dss_prealloc_enabled.setter
    def dss_prealloc_enabled(self, dss_prealloc_enabled):
        """
        Sets the dss_prealloc_enabled of this VolumeEx.
        True if dynamic segment sizing pre-allocation is enabled for the volume.

        :param dss_prealloc_enabled: The dss_prealloc_enabled of this VolumeEx.
        :type: bool
        """
        self._dss_prealloc_enabled = dss_prealloc_enabled

    @property
    def dss_max_segment_size(self):
        """
        Gets the dss_max_segment_size of this VolumeEx.
        The maximum segment size (in bytes) that this volume could assume with the dynamic segment sizing feature. This field is only meaningful if dssPreallocEnabled is true.

        :return: The dss_max_segment_size of this VolumeEx.
        :rtype: int
        :required/optional: required
        """
        return self._dss_max_segment_size

    @dss_max_segment_size.setter
    def dss_max_segment_size(self, dss_max_segment_size):
        """
        Sets the dss_max_segment_size of this VolumeEx.
        The maximum segment size (in bytes) that this volume could assume with the dynamic segment sizing feature. This field is only meaningful if dssPreallocEnabled is true.

        :param dss_max_segment_size: The dss_max_segment_size of this VolumeEx.
        :type: int
        """
        self._dss_max_segment_size = dss_max_segment_size

    @property
    def pre_read_redundancy_check_enabled(self):
        """
        Gets the pre_read_redundancy_check_enabled of this VolumeEx.
        If set to true, then the storage controller will, on READ operations, verify the consistency of RAID redundancy data for the stripe(s) containing the READ data.

        :return: The pre_read_redundancy_check_enabled of this VolumeEx.
        :rtype: bool
        :required/optional: required
        """
        return self._pre_read_redundancy_check_enabled

    @pre_read_redundancy_check_enabled.setter
    def pre_read_redundancy_check_enabled(self, pre_read_redundancy_check_enabled):
        """
        Sets the pre_read_redundancy_check_enabled of this VolumeEx.
        If set to true, then the storage controller will, on READ operations, verify the consistency of RAID redundancy data for the stripe(s) containing the READ data.

        :param pre_read_redundancy_check_enabled: The pre_read_redundancy_check_enabled of this VolumeEx.
        :type: bool
        """
        self._pre_read_redundancy_check_enabled = pre_read_redundancy_check_enabled

    @property
    def protection_information_capable(self):
        """
        Gets the protection_information_capable of this VolumeEx.
        This field is no longer used.

        :return: The protection_information_capable of this VolumeEx.
        :rtype: bool
        :required/optional: required
        """
        return self._protection_information_capable

    @protection_information_capable.setter
    def protection_information_capable(self, protection_information_capable):
        """
        Sets the protection_information_capable of this VolumeEx.
        This field is no longer used.

        :param protection_information_capable: The protection_information_capable of this VolumeEx.
        :type: bool
        """
        self._protection_information_capable = protection_information_capable

    @property
    def protection_type(self):
        """
        Gets the protection_type of this VolumeEx.
        The protection type of the volume.

        :return: The protection_type of this VolumeEx.
        :rtype: str
        :required/optional: required
        """
        return self._protection_type

    @protection_type.setter
    def protection_type(self, protection_type):
        """
        Sets the protection_type of this VolumeEx.
        The protection type of the volume.

        :param protection_type: The protection_type of this VolumeEx.
        :type: str
        """
        allowed_values = ["type0Protection", "type1Protection", "type2Protection", "type3Protection", "__UNDEFINED"]
        if protection_type not in allowed_values:
            raise ValueError(
                "Invalid value for `protection_type`, must be one of {0}"
                .format(allowed_values)
            )
        self._protection_type = protection_type

    @property
    def application_tag_owned(self):
        """
        Gets the application_tag_owned of this VolumeEx.
        True if application tag is owned by the storage array.

        :return: The application_tag_owned of this VolumeEx.
        :rtype: bool
        :required/optional: required
        """
        return self._application_tag_owned

    @application_tag_owned.setter
    def application_tag_owned(self, application_tag_owned):
        """
        Sets the application_tag_owned of this VolumeEx.
        True if application tag is owned by the storage array.

        :param application_tag_owned: The application_tag_owned of this VolumeEx.
        :type: bool
        """
        self._application_tag_owned = application_tag_owned

    @property
    def repaired_block_count(self):
        """
        Gets the repaired_block_count of this VolumeEx.
        This element contains a count of the number of blocks in the volume that have had data assurance errors repaired.

        :return: The repaired_block_count of this VolumeEx.
        :rtype: int
        :required/optional: required
        """
        return self._repaired_block_count

    @repaired_block_count.setter
    def repaired_block_count(self, repaired_block_count):
        """
        Sets the repaired_block_count of this VolumeEx.
        This element contains a count of the number of blocks in the volume that have had data assurance errors repaired.

        :param repaired_block_count: The repaired_block_count of this VolumeEx.
        :type: int
        """
        self._repaired_block_count = repaired_block_count

    @property
    def volume_use(self):
        """
        Gets the volume_use of this VolumeEx.


        :return: The volume_use of this VolumeEx.
        :rtype: str
        :required/optional: optional
        """
        return self._volume_use

    @volume_use.setter
    def volume_use(self, volume_use):
        """
        Sets the volume_use of this VolumeEx.


        :param volume_use: The volume_use of this VolumeEx.
        :type: str
        """
        allowed_values = ["standardVolume", "repositoryVolume", "mirrorTargetVolume", "mirrorSourceVolume", "concatVolume", "freeRepositoryVolume", "asyncMirrorSourceVolume", "asyncMirrorTargetVolume"]
        if volume_use not in allowed_values:
            raise ValueError(
                "Invalid value for `volume_use`, must be one of {0}"
                .format(allowed_values)
            )
        self._volume_use = volume_use

    @property
    def volume_full(self):
        """
        Gets the volume_full of this VolumeEx.


        :return: The volume_full of this VolumeEx.
        :rtype: bool
        :required/optional: optional
        """
        return self._volume_full

    @volume_full.setter
    def volume_full(self, volume_full):
        """
        Sets the volume_full of this VolumeEx.


        :param volume_full: The volume_full of this VolumeEx.
        :type: bool
        """
        self._volume_full = volume_full

    @property
    def volume_copy_target(self):
        """
        Gets the volume_copy_target of this VolumeEx.
        This value is true if the volume is currently the target of a volume copy pair.

        :return: The volume_copy_target of this VolumeEx.
        :rtype: bool
        :required/optional: optional
        """
        return self._volume_copy_target

    @volume_copy_target.setter
    def volume_copy_target(self, volume_copy_target):
        """
        Sets the volume_copy_target of this VolumeEx.
        This value is true if the volume is currently the target of a volume copy pair.

        :param volume_copy_target: The volume_copy_target of this VolumeEx.
        :type: bool
        """
        self._volume_copy_target = volume_copy_target

    @property
    def volume_copy_source(self):
        """
        Gets the volume_copy_source of this VolumeEx.
        This value is true if the volume is currently the source in a volume copy pair.

        :return: The volume_copy_source of this VolumeEx.
        :rtype: bool
        :required/optional: optional
        """
        return self._volume_copy_source

    @volume_copy_source.setter
    def volume_copy_source(self, volume_copy_source):
        """
        Sets the volume_copy_source of this VolumeEx.
        This value is true if the volume is currently the source in a volume copy pair.

        :param volume_copy_source: The volume_copy_source of this VolumeEx.
        :type: bool
        """
        self._volume_copy_source = volume_copy_source

    @property
    def pit_base_volume(self):
        """
        Gets the pit_base_volume of this VolumeEx.


        :return: The pit_base_volume of this VolumeEx.
        :rtype: bool
        :required/optional: optional
        """
        return self._pit_base_volume

    @pit_base_volume.setter
    def pit_base_volume(self, pit_base_volume):
        """
        Sets the pit_base_volume of this VolumeEx.


        :param pit_base_volume: The pit_base_volume of this VolumeEx.
        :type: bool
        """
        self._pit_base_volume = pit_base_volume

    @property
    def async_mirror_target(self):
        """
        Gets the async_mirror_target of this VolumeEx.
        This value is true if the volume is currently the target in an Asynchronous Mirror relationship.

        :return: The async_mirror_target of this VolumeEx.
        :rtype: bool
        :required/optional: optional
        """
        return self._async_mirror_target

    @async_mirror_target.setter
    def async_mirror_target(self, async_mirror_target):
        """
        Sets the async_mirror_target of this VolumeEx.
        This value is true if the volume is currently the target in an Asynchronous Mirror relationship.

        :param async_mirror_target: The async_mirror_target of this VolumeEx.
        :type: bool
        """
        self._async_mirror_target = async_mirror_target

    @property
    def async_mirror_source(self):
        """
        Gets the async_mirror_source of this VolumeEx.
        This value is true if the volume is currently the source in an Asynchronous Mirror relationship.

        :return: The async_mirror_source of this VolumeEx.
        :rtype: bool
        :required/optional: optional
        """
        return self._async_mirror_source

    @async_mirror_source.setter
    def async_mirror_source(self, async_mirror_source):
        """
        Sets the async_mirror_source of this VolumeEx.
        This value is true if the volume is currently the source in an Asynchronous Mirror relationship.

        :param async_mirror_source: The async_mirror_source of this VolumeEx.
        :type: bool
        """
        self._async_mirror_source = async_mirror_source

    @property
    def remote_mirror_source(self):
        """
        Gets the remote_mirror_source of this VolumeEx.
        True if the volume is a source (primary), in an Remote Volume Mirror relationship.

        :return: The remote_mirror_source of this VolumeEx.
        :rtype: bool
        :required/optional: optional
        """
        return self._remote_mirror_source

    @remote_mirror_source.setter
    def remote_mirror_source(self, remote_mirror_source):
        """
        Sets the remote_mirror_source of this VolumeEx.
        True if the volume is a source (primary), in an Remote Volume Mirror relationship.

        :param remote_mirror_source: The remote_mirror_source of this VolumeEx.
        :type: bool
        """
        self._remote_mirror_source = remote_mirror_source

    @property
    def remote_mirror_target(self):
        """
        Gets the remote_mirror_target of this VolumeEx.
        True if the volume is a target (secondary), in an Remote Volume Mirror relationship.

        :return: The remote_mirror_target of this VolumeEx.
        :rtype: bool
        :required/optional: optional
        """
        return self._remote_mirror_target

    @remote_mirror_target.setter
    def remote_mirror_target(self, remote_mirror_target):
        """
        Sets the remote_mirror_target of this VolumeEx.
        True if the volume is a target (secondary), in an Remote Volume Mirror relationship.

        :param remote_mirror_target: The remote_mirror_target of this VolumeEx.
        :type: bool
        """
        self._remote_mirror_target = remote_mirror_target

    @property
    def disk_pool(self):
        """
        Gets the disk_pool of this VolumeEx.
        True if the volume was defined on a DiskPool.

        :return: The disk_pool of this VolumeEx.
        :rtype: bool
        :required/optional: optional
        """
        return self._disk_pool

    @disk_pool.setter
    def disk_pool(self, disk_pool):
        """
        Sets the disk_pool of this VolumeEx.
        True if the volume was defined on a DiskPool.

        :param disk_pool: The disk_pool of this VolumeEx.
        :type: bool
        """
        self._disk_pool = disk_pool

    @property
    def flash_cached(self):
        """
        Gets the flash_cached of this VolumeEx.
        True if this volume is added to a flashCache.

        :return: The flash_cached of this VolumeEx.
        :rtype: bool
        :required/optional: optional
        """
        return self._flash_cached

    @flash_cached.setter
    def flash_cached(self, flash_cached):
        """
        Sets the flash_cached of this VolumeEx.
        True if this volume is added to a flashCache.

        :param flash_cached: The flash_cached of this VolumeEx.
        :type: bool
        """
        self._flash_cached = flash_cached

    @property
    def increasing_by(self):
        """
        Gets the increasing_by of this VolumeEx.
        If a Dynamic Volume Expansion (DVE) is in progress, the total capacity the volume is being increased by, otherwise zero.

        :return: The increasing_by of this VolumeEx.
        :rtype: int
        :required/optional: optional
        """
        return self._increasing_by

    @increasing_by.setter
    def increasing_by(self, increasing_by):
        """
        Sets the increasing_by of this VolumeEx.
        If a Dynamic Volume Expansion (DVE) is in progress, the total capacity the volume is being increased by, otherwise zero.

        :param increasing_by: The increasing_by of this VolumeEx.
        :type: int
        """
        self._increasing_by = increasing_by

    @property
    def metadata(self):
        """
        Gets the metadata of this VolumeEx.
        Metadata associated with the volume

        :return: The metadata of this VolumeEx.
        :rtype: list[VolumeMetadataItem]
        :required/optional: optional
        """
        return self._metadata

    @metadata.setter
    def metadata(self, metadata):
        """
        Sets the metadata of this VolumeEx.
        Metadata associated with the volume

        :param metadata: The metadata of this VolumeEx.
        :type: list[VolumeMetadataItem]
        """
        self._metadata = metadata

    @property
    def data_assurance(self):
        """
        Gets the data_assurance of this VolumeEx.


        :return: The data_assurance of this VolumeEx.
        :rtype: bool
        :required/optional: optional
        """
        return self._data_assurance

    @data_assurance.setter
    def data_assurance(self, data_assurance):
        """
        Sets the data_assurance of this VolumeEx.


        :param data_assurance: The data_assurance of this VolumeEx.
        :type: bool
        """
        self._data_assurance = data_assurance

    @property
    def object_type(self):
        """
        Gets the object_type of this VolumeEx.


        :return: The object_type of this VolumeEx.
        :rtype: str
        :required/optional: optional
        """
        return self._object_type

    @object_type.setter
    def object_type(self, object_type):
        """
        Sets the object_type of this VolumeEx.


        :param object_type: The object_type of this VolumeEx.
        :type: str
        """
        allowed_values = ["volume", "pool", "host", "lunMapping", "hostGroup", "thinVolume", "drive", "volumeCopy", "pit", "pitView", "snapshotGroup", "snapshot", "accessVolume", "legacySnapshot", "hostType", "metadataTag", "managementUrl", "folder", "asyncMirrorGroup", "asyncMirrorGroupMember", "asyncMirrorGroupIncompleteMember", "consistencyGroup", "consistencyGroupView", "fan", "battery", "storageSystem", "controller", "powerSupply", "minihub", "esm", "drawer", "hostBoard", "interconnectCRU", "cacheBackupDevice", "tray", "supportCRU", "hostPort", "initiator", "snapshotSchedule", "thermalSensor", "sfp", "flashCache", "featureAttribute", "featureState", "lockKeyId", "remoteVolume", "mirrorVolume", "vaultMirrorVolume", "vaultMirrorGroup", "metadataVolume", "sasPort", "sasExpander", "channelPort", "speedNegError", "snmpAgentBundle", "stagedFirmware", "workload"]
        if object_type not in allowed_values:
            raise ValueError(
                "Invalid value for `object_type`, must be one of {0}"
                .format(allowed_values)
            )
        self._object_type = object_type

    @property
    def name(self):
        """
        Gets the name of this VolumeEx.


        :return: The name of this VolumeEx.
        :rtype: str
        :required/optional: optional
        """
        return self._name

    @name.setter
    def name(self, name):
        """
        Sets the name of this VolumeEx.


        :param name: The name of this VolumeEx.
        :type: str
        """
        self._name = name

    @property
    def id(self):
        """
        Gets the id of this VolumeEx.


        :return: The id of this VolumeEx.
        :rtype: str
        :required/optional: optional
        """
        return self._id

    @id.setter
    def id(self, id):
        """
        Sets the id of this VolumeEx.


        :param id: The id of this VolumeEx.
        :type: str
        """
        self._id = id

    @property
    def wwn(self):
        """
        Gets the wwn of this VolumeEx.


        :return: The wwn of this VolumeEx.
        :rtype: str
        :required/optional: optional
        """
        return self._wwn

    @wwn.setter
    def wwn(self, wwn):
        """
        Sets the wwn of this VolumeEx.


        :param wwn: The wwn of this VolumeEx.
        :type: str
        """
        self._wwn = wwn

    @property
    def cache_settings(self):
        """
        Gets the cache_settings of this VolumeEx.
        The volume-specific caching parameters currently in effect for the volume.

        :return: The cache_settings of this VolumeEx.
        :rtype: VolumeCache
        :required/optional: required
        """
        return self._cache_settings

    @cache_settings.setter
    def cache_settings(self, cache_settings):
        """
        Sets the cache_settings of this VolumeEx.
        The volume-specific caching parameters currently in effect for the volume.

        :param cache_settings: The cache_settings of this VolumeEx.
        :type: VolumeCache
        """
        self._cache_settings = cache_settings

    @property
    def thin_provisioned(self):
        """
        Gets the thin_provisioned of this VolumeEx.


        :return: The thin_provisioned of this VolumeEx.
        :rtype: bool
        :required/optional: optional
        """
        return self._thin_provisioned

    @thin_provisioned.setter
    def thin_provisioned(self, thin_provisioned):
        """
        Sets the thin_provisioned of this VolumeEx.


        :param thin_provisioned: The thin_provisioned of this VolumeEx.
        :type: bool
        """
        self._thin_provisioned = thin_provisioned

    @property
    def list_of_mappings(self):
        """
        Gets the list_of_mappings of this VolumeEx.


        :return: The list_of_mappings of this VolumeEx.
        :rtype: list[LUNMapping]
        :required/optional: optional
        """
        return self._list_of_mappings

    @list_of_mappings.setter
    def list_of_mappings(self, list_of_mappings):
        """
        Sets the list_of_mappings of this VolumeEx.


        :param list_of_mappings: The list_of_mappings of this VolumeEx.
        :type: list[LUNMapping]
        """
        self._list_of_mappings = list_of_mappings

    @property
    def mapped(self):
        """
        Gets the mapped of this VolumeEx.


        :return: The mapped of this VolumeEx.
        :rtype: bool
        :required/optional: required
        """
        return self._mapped

    @mapped.setter
    def mapped(self, mapped):
        """
        Sets the mapped of this VolumeEx.


        :param mapped: The mapped of this VolumeEx.
        :type: bool
        """
        self._mapped = mapped

    @property
    def current_controller_id(self):
        """
        Gets the current_controller_id of this VolumeEx.


        :return: The current_controller_id of this VolumeEx.
        :rtype: str
        :required/optional: optional
        """
        return self._current_controller_id

    @current_controller_id.setter
    def current_controller_id(self, current_controller_id):
        """
        Sets the current_controller_id of this VolumeEx.


        :param current_controller_id: The current_controller_id of this VolumeEx.
        :type: str
        """
        self._current_controller_id = current_controller_id

    @property
    def preferred_controller_id(self):
        """
        Gets the preferred_controller_id of this VolumeEx.


        :return: The preferred_controller_id of this VolumeEx.
        :rtype: str
        :required/optional: optional
        """
        return self._preferred_controller_id

    @preferred_controller_id.setter
    def preferred_controller_id(self, preferred_controller_id):
        """
        Sets the preferred_controller_id of this VolumeEx.


        :param preferred_controller_id: The preferred_controller_id of this VolumeEx.
        :type: str
        """
        self._preferred_controller_id = preferred_controller_id

    @property
    def online_volume_copy(self):
        """
        Gets the online_volume_copy of this VolumeEx.


        :return: The online_volume_copy of this VolumeEx.
        :rtype: bool
        :required/optional: optional
        """
        return self._online_volume_copy

    @online_volume_copy.setter
    def online_volume_copy(self, online_volume_copy):
        """
        Sets the online_volume_copy of this VolumeEx.


        :param online_volume_copy: The online_volume_copy of this VolumeEx.
        :type: bool
        """
        self._online_volume_copy = online_volume_copy

    @property
    def total_size_in_bytes(self):
        """
        Gets the total_size_in_bytes of this VolumeEx.


        :return: The total_size_in_bytes of this VolumeEx.
        :rtype: int
        :required/optional: optional
        """
        return self._total_size_in_bytes

    @total_size_in_bytes.setter
    def total_size_in_bytes(self, total_size_in_bytes):
        """
        Sets the total_size_in_bytes of this VolumeEx.


        :param total_size_in_bytes: The total_size_in_bytes of this VolumeEx.
        :type: int
        """
        self._total_size_in_bytes = total_size_in_bytes

    def to_dict(self):
        """
        Returns the model properties as a dict
        """
        result = {}

        for attr, _ in iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value

        return result

    def to_str(self):
        """
        Returns the string representation of the model
        """
        return pformat(self.to_dict())

    def __repr__(self):
        """
        For `print` and `pprint`
        """
        if self is None:
           return None
        return self.to_str()

    def __eq__(self, other):
        """
        Returns true if both objects are equal
        """
        if self is None or other is None:
            return None
        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """
        Returns true if both objects are not equal
        """
        return not self == other

