{
	"version": 3,
	"file": "D:/activ_tosh/geatec/numscrypt/numscrypt/development/automated_tests/ndarray/__javascript__/autotest.js",
	"sources": [
		"",
		"C:/Python35/lib/site-packages/transcrypt/modules/org/transcrypt/__javascript__/__core__.mod.js",
		"C:/Python35/lib/site-packages/transcrypt/modules/org/transcrypt/__base__.py",
		"C:/Python35/lib/site-packages/transcrypt/modules/org/transcrypt/__standard__.py",
		"C:/Python35/lib/site-packages/transcrypt/modules/org/transcrypt/__javascript__/__builtin__.mod.js",
		"D:/activ_tosh/geatec/numscrypt/numscrypt/development/automated_tests/ndarray/basics/__init__.py",
		"C:/Python35/lib/site-packages/transcrypt/modules/itertools/__javascript__/__init__.mod.js",
		"C:/Python35/lib/site-packages/transcrypt/modules/math/__init__.py",
		"D:/activ_tosh/geatec/numscrypt/numscrypt/development/automated_tests/ndarray/module_fft/__init__.py",
		"D:/activ_tosh/geatec/numscrypt/numscrypt/development/automated_tests/ndarray/module_linalg/__init__.py",
		"C:\\Python35\\lib\\site-packages/numscrypt/__init__.py",
		"C:\\Python35\\lib\\site-packages/numscrypt/fft/__init__.py",
		"C:\\Python35\\lib\\site-packages/numscrypt/linalg.py",
		"C:/Python35/lib/site-packages/transcrypt/modules/org/transcrypt/autotester/__init__.py",
		"D:/activ_tosh/geatec/numscrypt/numscrypt/development/automated_tests/ndarray/autotest.py"
	],
	"sourcesContent": [
		"__pragma__ ('padding')",
		"\tvar __all__ = {};\n\tvar __world__ = __all__;\n\t\n\t// Nested object creator, part of the nesting may already exist and have attributes\n\tvar __nest__ = function (headObject, tailNames, value) {\n\t\t// In some cases this will be a global object, e.g. 'window'\n\t\tvar current = headObject;\n\t\t\n\t\tif (tailNames != '') {\t// Split on empty string doesn't give empty list\n\t\t\t// Find the last already created object in tailNames\n\t\t\tvar tailChain = tailNames.split ('.');\n\t\t\tvar firstNewIndex = tailChain.length;\n\t\t\tfor (var index = 0; index < tailChain.length; index++) {\n\t\t\t\tif (!current.hasOwnProperty (tailChain [index])) {\n\t\t\t\t\tfirstNewIndex = index;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcurrent = current [tailChain [index]];\n\t\t\t}\n\t\t\t\n\t\t\t// Create the rest of the objects, if any\n\t\t\tfor (var index = firstNewIndex; index < tailChain.length; index++) {\n\t\t\t\tcurrent [tailChain [index]] = {};\n\t\t\t\tcurrent = current [tailChain [index]];\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Insert it new attributes, it may have been created earlier and have other attributes\n\t\tfor (var attrib in value) {\n\t\t\tcurrent [attrib] = value [attrib];\t\t\t\n\t\t}\t\t\n\t};\n\t__all__.__nest__ = __nest__;\n\t\n\t// Initialize module if not yet done and return its globals\n\tvar __init__ = function (module) {\n\t\tif (!module.__inited__) {\n\t\t\tmodule.__all__.__init__ (module.__all__);\n\t\t\tmodule.__inited__ = true;\n\t\t}\n\t\treturn module.__all__;\n\t};\n\t__all__.__init__ = __init__;\n\t\n\t// Since we want to assign functions, a = b.f should make b.f produce a bound function\n\t// So __get__ should be called by a property rather then a function\n\t// Factory __get__ creates one of three curried functions for func\n\t// Which one is produced depends on what's to the left of the dot of the corresponding JavaScript property\n\tvar __get__ = function (self, func, quotedFuncName) {\n\t\tif (self) {\n\t\t\tif (self.hasOwnProperty ('__class__') || typeof self == 'string' || self instanceof String) {\t\t\t// Object before the dot\n\t\t\t\tif (quotedFuncName) {\t\t\t\t\t\t\t\t\t// Memoize call since fcall is on, by installing bound function in instance\n\t\t\t\t\tObject.defineProperty (self, quotedFuncName, {\t\t// Will override the non-own property, next time it will be called directly\n\t\t\t\t\t\tvalue: function () {\t\t\t\t\t\t\t// So next time just call curry function that calls function\n\t\t\t\t\t\t\tvar args = [] .slice.apply (arguments);\n\t\t\t\t\t\t\treturn func.apply (null, [self] .concat (args));\n\t\t\t\t\t\t},\t\t\t\t\n\t\t\t\t\t\twritable: true,\n\t\t\t\t\t\tenumerable: true,\n\t\t\t\t\t\tconfigurable: true\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn function () {\t\t\t\t\t\t\t\t\t// Return bound function, code dupplication for efficiency if no memoizing\n\t\t\t\t\tvar args = [] .slice.apply (arguments);\t\t\t\t// So multilayer search prototype, apply __get__, call curry func that calls func\n\t\t\t\t\treturn func.apply (null, [self] .concat (args));\n\t\t\t\t};\n\t\t\t}\n\t\t\telse {\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Class before the dot\n\t\t\t\treturn func;\t\t\t\t\t\t\t\t\t\t\t// Return static method\n\t\t\t}\n\t\t}\n\t\telse {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Nothing before the dot\n\t\t\treturn func;\t\t\t\t\t\t\t\t\t\t\t\t// Return free function\n\t\t}\n\t}\n\t__all__.__get__ = __get__;\n\t\t\t\n\t// Class creator function\n\tvar __class__ = function (name, bases, extra) {\n\t\t// Create class functor\n\t\tvar cls = function () {\n\t\t\tvar args = [] .slice.apply (arguments);\n\t\t\treturn cls.__new__ (args);\n\t\t};\n\t\t\n\t\t// Copy methods, properties and static attributes from base classes to new class object\n\t\tfor (var index = bases.length - 1; index >= 0; index--) {\t// Reversed order, since class vars of first base should win\n\t\t\tvar base = bases [index];\n\t\t\tfor (var attrib in base) {\n\t\t\t\tvar descrip = Object.getOwnPropertyDescriptor (base, attrib);\n\t\t\t\tObject.defineProperty (cls, attrib, descrip);\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Add class specific attributes to class object\n\t\tcls.__name__ = name;\n\t\tcls.__bases__ = bases;\n\t\t\n\t\t// Add own methods, properties and static attributes to class object\n\t\tfor (var attrib in extra) {\n\t\t\tvar descrip = Object.getOwnPropertyDescriptor (extra, attrib);\n\t\t\tObject.defineProperty (cls, attrib, descrip);\n\t\t}\n\t\t\t\t\n\t\t// Return class object\n\t\treturn cls;\n\t};\n\t__all__.__class__ = __class__;\n\t\n\t// Create mother of all classes\t\t\n\tvar object = __all__.__class__ ('object', [], {\n\t\t__init__: function (self) {},\n\t\t\t\n\t\t__name__: 'object',\n\t\t__bases__: [],\n\t\t\t\n\t\t// Object creator function is inherited by all classes (so in principle it could be made global)\n\t\t__new__: function (args) {\t// Args are just the constructor args\t\t\n\t\t\t// In JavaScript the Python class is the prototype of the Python object\n\t\t\t// In this way methods and static attributes will be available both with a class and an object before the dot\n\t\t\t// The descriptor produced by __get__ will return the right method flavor\n\t\t\tvar instance = Object.create (this, {__class__: {value: this, enumerable: true}});\n\t\t\t\n\t\t\t// Call constructor\n\t\t\tthis.__init__.apply (null, [instance] .concat (args));\n\t\t\t\n\t\t\t// Return instance\t\t\t\n\t\t\treturn instance;\n\t\t}\t\n\t});\n\t__all__.object = object;\n\t\n\t// Define __pragma__ to preserve '<all>' and '</all>', since it's never generated as a function, must be done early, so here\n\tvar __pragma__ = function () {};\n\t__all__.__pragma__ = __pragma__;\n",
		"# This module is avaible both in the Python and Transcrypt environments\n# It is included in-between the __core__ and the __builtin__ module, so the latter can adapt __envir__\n# In Transcrypt, __base__ is available inline, it isn't nested and cannot be imported in the normal way\n\nclass __Envir__:\n\tdef __init__ (self):\n\t\tself.transpiler_name = 'transcrypt'\n\t\tself.transpiler_version = '3.5.218'\n\t\tself.target_subdir = '__javascript__'\n\t\t\n__envir__ = __Envir__ ()",
		"# This module is avaible solely in the Transcrypt environment\n# It is included after the __builtin__ module, since it uses its facilities\n# In Transcrypt, __standard__ is available inline, it isn't nested and cannot be imported in the normal way\n\n__pragma__ ('skip')\ncopy = 0\n__pragma__ ('noskip')\n\n__pragma__ ('nokwargs')\n__pragma__ ('noalias', 'sort')\n\nclass Exception:\n\tdef __init__ (self, *args):\n\t\tself.args = args\n\t\t\n\tdef __repr__ (self):\n\t\tif len (self.args):\n\t\t\treturn '{}{}'.format (self.__class__.__name__, repr (tuple (self.args)))\n\t\telse:\n\t\t\treturn '{}()'.format (self.__class__.__name__)\n\t\t\t\n\tdef __str__ (self):\n\t\tif len (self.args) > 1:\n\t\t\treturn str (tuple (self.args))\n\t\telif len (self.args):\n\t\t\treturn str (self.args [0])\n\t\telse:\n\t\t\treturn ''\n\t\t\nclass StopIteration ():\n\tdef __init__ (self):\n\t\tException.__init__ (self, 'Iterator exhausted')\n\t\t\nclass ValueError (Exception):\n\tpass\n\t\nclass AssertionError (Exception):\n\tpass\n\t\t\t\n__pragma__ ('kwargs')\n\t\t\t\ndef __sort__ (iterable, key = None, reverse = False):\t# Used by py_sort, can deal with kwargs\n\tif key:\n\t\titerable.sort (lambda a, b: key (a) > key (b))\t# JavaScript sort\n\telse:\n\t\titerable.sort ()\t\t\t\t\t\t\t\t# JavaScript sort\n\t\t\n\tif reverse:\n\t\titerable.reverse ()\n\t\t\ndef sorted (iterable, key = None, reverse = False):\n\tif type (iterable) == dict:\n\t\tresult = copy (iterable.keys ()) \n\telse:\t\t\n\t\tresult = copy (iterable)\n\t\t\n\t__sort__ (result, key, reverse)\n\treturn result\n\n\n__pragma__ ('nokwargs')\n\ndef map (func, iterable):\n\treturn [func (item) for item in iterable]\n\n\ndef filter (func, iterable):\n\treturn [item for item in iterable if func (item)]\n\t\n__pragma__ ('ifdef', '__complex__')\nclass complex:\n\tdef __init__ (self, real, imag = None):\n\t\tif imag == None:\n\t\t\tif type (real) == complex:\n\t\t\t\tself.real = real.real\n\t\t\t\tself.imag = real.imag\n\t\t\telse:\n\t\t\t\tself.real = real\n\t\t\t\tself.imag = 0\n\t\telse:\n\t\t\tself.real = real\n\t\t\tself.imag = imag\n\t\t\t\n\tdef __neg__ (self):\n\t\treturn complex (-self.real, -self.imag)\n\t\t\n\tdef __exp__ (self):\n\t\tmodulus = Math.exp (self.real)\n\t\treturn complex (modulus * Math.cos (self.imag), modulus * Math.sin (self.imag))\n\t\n\tdef __log__ (self):\n\t\treturn complex (Math.log (Math.sqrt (self.real * self.real + self.imag * self.imag)), Math.atan2 (self.imag, self.real))\n\t\t\n\tdef __pow__ (self, other):\t# a ** b = exp (b log a)\n\t\treturn (self.__log__ () .__mul__ (other)) .__exp__ ()\n\t\t\n\tdef __rpow__ (self, real):\t# real ** comp -> comp.__rpow__ (real)\n\t\treturn self.__mul__ (Math.log (real)) .__exp__ ()\n\t\t\n\tdef __mul__ (self, other):\n\t\tif __typeof__ (other) is 'number':\n\t\t\treturn complex (self.real * other, self.imag * other)\n\t\telse:\n\t\t\treturn complex (self.real * other.real - self.imag * other.imag, self.real * other.imag + self.imag * other.real)\n\t\t\n\tdef __rmul__ (self, real):\t# real + comp -> comp.__rmul__ (real)\n\t\treturn complex (self.real * real, self.imag * real)\n\t\t\n\tdef __div__ (self, other):\n\t\tif __typeof__ (other) is 'number':\n\t\t\treturn complex (self.real / other, self.imag / other)\n\t\telse:\n\t\t\tdenom = other.real * other.real + other.imag * other.imag\n\t\t\treturn complex (\n\t\t\t\t(self.real * other.real + self.imag * other.imag) / denom,\n\t\t\t\t(self.imag * other.real - self.real * other.imag) / denom\n\t\t\t)\n\t\t\n\tdef __rdiv__ (self, real):\t# real / comp -> comp.__rdiv__ (real)\n\t\tdenom = self.real * self.real\n\t\treturn complex (\n\t\t\t(real * self.real) / denom,\n\t\t\t(real * self.imag) / denom\n\t\t)\n\t\t\n\tdef __add__ (self, other):\n\t\tif __typeof__ (other) is 'number':\n\t\t\treturn complex (self.real + other, self.imag)\n\t\telse:\t# Assume other is complex\n\t\t\treturn complex (self.real + other.real, self.imag + other.imag)\n\t\t\n\tdef __radd__ (self, real):\t# real + comp -> comp.__radd__ (real)\n\t\treturn complex (self.real + real, self.imag)\n\t\t\n\tdef __sub__ (self, other):\n\t\tif __typeof__ (other) is 'number':\n\t\t\treturn complex (self.real - other, self.imag)\n\t\telse:\n\t\t\treturn complex (self.real - other.real, self.imag - other.imag)\n\t\t\n\tdef __rsub__ (self, real):\t# real - comp -> comp.__rsub__ (real)\n\t\treturn complex (real - self.real, -self.imag)\n\t\t\n\tdef __repr__ (self):\n\t\treturn '({}{}{}j)'.format (self.real, '+' if self.imag >= 0 else '', self.imag)\n\t\t\t\n\tdef __str__ (self):\n\t\treturn __repr__ (self) [1 : -1]\n\t\t\n__pragma__ ('endif')\n\nclass __Terminal__:\n\tdef __init__ (self):\n\t\ttry:\n\t\t\tself.element = document.getElementById ('__terminal__')\n\t\texcept:\t# node.js\n\t\t\tself.element = None\n\t\tif self.element:\n\t\t\tself.buffer = ''\n\t\t\tself.element.style.overflowX = 'auto'\n\t\t\tself.element.style.padding = '5px'\n\t\t\tself.element.innerHTML = '_'\n\t\t\n\t__pragma__ ('kwargs')\n\t\t\n\tdef print (self, *args, sep = ' ', end = '\\n'):\n\t\tif self.element:\n\t\t\tself.buffer = '{}{}{}'.format (self.buffer, sep.join ([str (arg) for arg in args]), end) [-4096 : ]\t\n\t\t\tself.element.innerHTML = self.buffer.replace ('\\n', '<br>')\n\t\t\tself.element.scrollTop = self.element.scrollHeight\n\t\telse:\n\t\t\tconsole.log (sep.join ([str (arg) for arg in args]))\n\t\t\n\tdef input (self, question):\n\t\tself.print ('{}_'.format (question), end = '')\n\t\ttry:\n\t\t\tanswer = window.prompt (question)\n\t\texcept:\n\t\t\tconsole.log ('Error: Blocking input not yet implemented outside browser')\n\t\tself.buffer = self.buffer [:-1]\n\t\tself.print (answer)\n\t\treturn answer\n\t\t\n\t__pragma__ ('nokwargs')\n\t\n__terminal__ = __Terminal__ ()\n",
		"\n\t// Initialize non-nested modules __base__ and __standard__ and make its names available directly and via __all__\n\t// It can't do that itself, because it is a regular Python module\n\t// The compiler recognizes its their namesand generates them inline rather than nesting them\n\t// In this way it isn't needed to import them everywhere\n\t \t\n\t// __base__\n\t\n\t__nest__ (__all__, '', __init__ (__all__.org.transcrypt.__base__));\n\tvar __envir__ = __all__.__envir__;\n\n\t// __standard__\n\t\n\t__nest__ (__all__, '', __init__ (__all__.org.transcrypt.__standard__));\n\t\n\tvar Exception = __all__.Exception;\n\tvar StopIteration = __all__.StopIteration;\n\tvar ValueError = __all__.ValueError;\n\tvar AssertionError = __all__.AssertionError;\n\t\n\tvar __sort__ = __all__.__sort__;\n\tvar sorted = __all__.sorted;\n\t\n\tvar map = __all__.map;\n\tvar filter = __all__.filter;\n\t\n__pragma__ ('ifdef', '__complex__')\n\tvar complex = __all__.complex;\n__pragma__ ('endif')\n\t\n\t__all__.print = __all__.__terminal__.print;\n\t__all__.input = __all__.__terminal__.input;\n\t\n\tvar print = __all__.print;\n\tvar input = __all__.input;\n\n\t// Complete __envir__, that was created in __base__, for non-stub mode\n\t__envir__.executor_name = __envir__.transpiler_name;\n\t\n\t// Make make __main__ available in browser\n\tvar __main__ = {__file__: ''};\n\t__all__.main = __main__;\n\t\n\t// Define current exception, there's at most one exception in the air at any time\n\tvar __except__ = null;\n\t__all__.__except__ = __except__;\n\t\t\n\t// Define recognizable dictionary for **kwargs parameter\n\tvar __kwargdict__ = function (anObject) {\n\t\tanObject.__class__ = __kwargdict__;\t// This class needs no __name__\n\t\tanObject.constructor = Object;\n\t\treturn anObject;\n\t}\n\t__all__.___kwargdict__ = __kwargdict__;\n\t\n\t// Property installer function, no member since that would bloat classes\n\tvar property = function (getter, setter) {\t// Returns a property descriptor rather than a property\n\t\tif (!setter) {\t// ??? Make setter optional instead of dummy?\n\t\t\tsetter = function () {};\n\t\t}\n\t\treturn {get: function () {return getter (this)}, set: function (value) {setter (this, value)}, enumerable: true};\n\t}\n\t__all__.property = property;\n\t\n\t// Assert function, call to it only generated when compiling with --dassert option\n\tfunction assert (condition, message) {\n\t\tif (!condition) {\n\t\t\tif (message != undefined) {\n\t\t\t\tthrow AssertionError (message);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow AssertionError ();\n\t\t\t}\n\t\t}\n\t}\n\t\n\t__all__.assert = assert;\n\t\n\tvar __merge__ = function (object0, object1) {\n\t\tvar result = {};\n\t\tfor (var attrib in object0) {\n\t\t\tresult [attrib] = object0 [attrib];\n\t\t}\n\t\tfor (var attrib in object1) {\n\t\t\tresult [attrib] = object1 [attrib];\n\t\t}\n\t\treturn result;\n\t}\n\t__all__.__merge__ = __merge__;\n\t\n\t/* Not needed anymore?\n\t// Make console.log understand apply\n\tconsole.log.apply = function () {\n\t\tprint ([] .slice.apply (arguments) .slice (1));\n\t};\n\t*/\n\n\t// Manipulating attributes by name\n\t\n\tvar dir = function (obj) {\n\t\tvar aList = [];\n\t\tfor (var aKey in obj) {\n\t\t\taList.push (aKey);\n\t\t}\n\t\taList.sort ();\n\t\treturn aList;\n\t}\n\t\n\tvar setattr = function (obj, name, value) {\n\t\tobj [name] = value;\n\t};\n\t\t\n\t__all__.setattr = setattr;\n\t\n\tvar getattr = function (obj, name) {\n\t\treturn obj [name];\n\t};\n\t\n\t__all__.getattr= getattr\n\t\n\tvar hasattr = function (obj, name) {\n\t\treturn name in obj;\n\t};\n\t__all__.hasattr = hasattr;\n\t\n\tvar delattr = function (obj, name) {\n\t\tdelete obj [name];\n\t};\n\t__all__.delattr = (delattr);\n\t\n\t// The __in__ function, used to mimic Python's 'in' operator\n\t// In addition to CPython's semantics, the 'in' operator is also allowed to work on objects, avoiding a counterintuitive separation between Python dicts and JavaScript objects\n\t// In general many Transcrypt compound types feature a deliberate blend of Python and JavaScript facilities, facilitating efficient integration with JavaScript libraries\n\t// If only Python objects and Python dicts are dealt with in a certain context, the more pythonic 'hasattr' is preferred for the objects as opposed to 'in' for the dicts\n\tvar __in__ = function (element, container) {\n\t\tif (type (container) == dict) {\n\t\t\treturn container.keys () .indexOf (element) > -1;                                   // The keys of parameter 'element' are in an array\n\t\t}\n\t\telse {\n\t\t\treturn container.indexOf ? container.indexOf (element) > -1 : element in container; // Parameter 'element' itself is an array, string or object\n\t\t}\n\t}\n\t__all__.__in__ = __in__;\n\t\n\t// Find out if an attribute is special\n\tvar __specialattrib__ = function (attrib) {\n\t\treturn (attrib.startswith ('__') && attrib.endswith ('__')) || attrib == 'constructor' || attrib.startswith ('py_');\n\t}\n\t__all__.__specialattrib__ = __specialattrib__;\n\t\t\n\t// Len function for any object\n\tvar len = function (anObject) {\n\t\tif (anObject) {\n\t\t\tvar l = anObject.length;\n\t\t\tif (l == undefined) {\n\t\t\t\tvar result = 0;\n\t\t\t\tfor (var attrib in anObject) {\n\t\t\t\t\tif (!__specialattrib__ (attrib)) {\n\t\t\t\t\t\tresult++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn l;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treturn 0;\n\t\t}\n\t}\n\t__all__.len = len;\n\t\n\tvar bool = function (any) {\t// Subtly different from __ (any), always truly returns a bool, rather than something truthy or falsy\n\t\treturn typeof any == 'boolean' ? any : typeof any == 'number' ? any != 0 : len (any) ? true : false;\n\t}\n\tbool.__name__ = 'bool'\t// So it can be used as a type with a name\n\t__all__.bool = bool;\n\t\n\tvar float = function (any) {\n\t\tif (isNaN (any)) {\n\t\t\tthrow ('ValueError');\t// !!! Turn into real value error\n\t\t}\n\t\telse {\n\t\t\treturn +any;\n\t\t}\n\t}\n\tfloat.__name__ = 'float'\n\t__all__.float = float;\n\t\n\tvar int = function (any) {\n\t\treturn float (any) | 0\n\t}\n\tint.__name__ = 'int';\n\t__all__.int = int;\n\t\n\tvar type = function (anObject) {\n\t\ttry {\n\t\t\tvar result = anObject.__class__;\n\t\t\treturn result;\n\t\t}\n\t\tcatch (exception) {\n\t\t\tvar aType = typeof anObject;\n\t\t\tif (aType == 'boolean') {\n\t\t\t\treturn bool;\n\t\t\t}\n\t\t\telse if (aType == 'number') {\n\t\t\t\tif (anObject % 1 == 0) {\n\t\t\t\t\treturn int;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn float;\n\t\t\t\t}\t\t\t\t\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn aType;\n\t\t\t}\n\t\t}\n\t}\n\t__all__.type = type;\n\t\n\tvar isinstance = function (anObject, classinfo) {\n\t\tfunction isA (queryClass) {\n\t\t\tif (queryClass == classinfo) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tfor (var index = 0; index < queryClass.__bases__.length; index++) {\n\t\t\t\tif (isA (queryClass.__bases__ [index], classinfo)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\ttry {\n\t\t\treturn '__class__' in anObject ? isA (anObject.__class__) : anObject instanceof classinfo;\n\t\t}\n\t\tcatch (exception) {\n\t\t\tconsole.log (exception);\n\t\t\tconsole.dir (anObject);\n\t\t}\n\t};\n\t__all__.isinstance = isinstance;\n\t\n\t// Truthyness conversion\n\tfunction __ (any) {\t// Subtly different from bool (any), __ ([1, 2, 3]) returns [1, 2, 3], needed for nonempty selection: l = list1 or list2\n\t\treturn ['boolean', 'number'] .indexOf (typeof (any)) >= 0 ? any : len (any) ? any : false;\n\t}\n\t__all__.__ = __;\n\t\n\t// Repr function uses __repr__ method, then __str__ then toString\n\tvar repr = function (anObject) {\n\t\ttry {\n\t\t\treturn anObject.__repr__ ();\n\t\t}\n\t\tcatch (exception) {\n\t\t\ttry {\n\t\t\t\treturn anObject.__str__ ();\n\t\t\t}\n\t\t\tcatch (exception) {\t// It was a dict in Python, so an Object in JavaScript\n\t\t\t\ttry {\n\t\t\t\t\tif (anObject.constructor == Object) {\n\t\t\t\t\t\tvar result = '{';\n\t\t\t\t\t\tvar comma = false;\n\t\t\t\t\t\tfor (var attrib in anObject) {\n\t\t\t\t\t\t\tif (!__specialattrib__ (attrib)) {\n\t\t\t\t\t\t\t\tif (attrib.isnumeric ()) {\n\t\t\t\t\t\t\t\t\tvar attribRepr = attrib;\t\t\t\t// If key can be interpreted as numerical, we make it numerical \n\t\t\t\t\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t// So we accept that '1' is misrepresented as 1\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tvar attribRepr = '\\'' + attrib + '\\'';\t// Alpha key in dict\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif (comma) {\n\t\t\t\t\t\t\t\t\tresult += ', ';\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tcomma = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tresult += attribRepr + ': ' + anObject [attrib] .__repr__ ();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcatch (exception) {\n\t\t\t\t\t\t\t\t\tresult += attribRepr + ': ' + anObject [attrib] .toString ();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresult += '}';\n\t\t\t\t\t\treturn result;\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\treturn typeof anObject == 'boolean' ? anObject.toString () .capitalize () : anObject.toString ();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (exception) {\n\t\t\t\t\tconsole.log ('ERROR: Could not evaluate repr (<object of type ' + typeof anObject + '>)');\n\t\t\t\t\treturn '???';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t__all__.repr = repr;\n\t\n\t// Char from Unicode or ASCII\n\tvar chr = function (charCode) {\n\t\treturn String.fromCharCode (charCode);\n\t}\n\t__all__.chr = chr;\n\n\t// Unicode or ASCII from char\n\tvar ord = function (aChar) {\n\t\treturn aChar.charCodeAt (0);\n\t}\n\t__all__.org = ord;\n\t\n\t// Maximum of n numbers\n\tvar max = Math.max;\n\t__all__.max = max;\n\t\n\t// Minimum of n numbers\n\tvar min = Math.min;\n\t__all__.min = min;\n\t\n\t// Absolute value\n__pragma__ ('ifdef', '__complex__')\n\tvar abs = function (x) {\n\t\ttry {\n\t\t\treturn Math.abs (x);\n\t\t}\n\t\tcatch (exception) {\n\t\t\treturn Math.sqrt (x.real * x.real + x.imag * x.imag);\n\t\t}\n\t}\n__pragma__ ('else')\n\tvar abs = Math.abs;\n\t__all__.abs = abs;\n__pragma__ ('endif')\n\t\n\t// Bankers rounding\n\tvar round = function (number, ndigits) {\n\t\tif (ndigits) {\n\t\t\tvar scale = Math.pow (10, ndigits);\n\t\t\tnumber *= scale;\n\t\t}\n\t\t\t\n\t\tvar rounded = Math.round (number);\n\t\tif (rounded - number == 0.5 && rounded % 2) {\t// Has rounded up to odd, should have rounded down to even\n\t\t\trounded -= 1;\n\t\t}\n\t\t\t\n\t\tif (ndigits) {\n\t\t\trounded /= scale;\n\t\t}\n\t\t\n\t\treturn rounded\n \t}\n\t__all__.round = round;\n\t\t\n\t// Iterator protocol functions\n\t\n\tfunction wrap_py_next () {\t\t// Add as 'next' method to make Python iterator JavaScript compatible\n\t\tvar result = this.__next__ ();\n\t\treturn {value: result, done: result == undefined};\t\t\n\t}\n\t\n\tfunction wrap_js_next () {\t\t// Add as '__next__' method to make JavaScript iterator Python compatible\n\t\tvar result = this.next ();\n\t\tif (result.done) {\n\t\t\tthrow StopIteration ();\n\t\t}\n\t\telse {\n\t\t\treturn result.value;\n\t\t}\n\t}\n\t\n\tfunction py_iter (iterable) {\t// Produces universal iterator with Python '__next__' as well as JavaScript 'next'\n\t\tif ('__iter__' in iterable) {\t// It's a Python iterable (incl. JavaScript Arrays and strings)\n\t\t\tvar iterator = iterable.__iter__ ();\n\t\t\titerator.next = wrap_py_next;\n\t\t\treturn iterator;\n\t\t}\n\t\telse if ('selector' in iterable) { // Assume it's a JQuery iterator\n\t\t\tvar iterator = list (iterable) .__iter__ ();\n\t\t\titerator.next = wrap_py_next;\n\t\t\treturn iterator;\n\t\t}\n\t\telse if ('next' in iterable) {\t// It's a JavaScript generator\n\t\t\t// It should have an iterator field, but doesn't in Chrome\n\t\t\t// So we just return the generator itself, which is both an iterable and an iterator\n\t\t\titerable.__next__ = wrap_js_next;\n\t\t\treturn iterable;\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\t}\n\t__all__.py_iter = py_iter;\n\t\n\tfunction py_next (iterator) {\t\t\t\t// Called only in a Python context, could receive Python or JavaScript iterator\n\t\ttry {\t\t\t\t\t\t\t\t\t// Primarily assume Python iterator, for max speed\n\t\t\tvar result = iterator.__next__ ();\n\t\t}\n\t\tcatch (exception) {\t\t\t\t\t\t// JavaScript iterators are the exception here\n\t\t\tvar result = iterator.next ();\n\t\t\tif (result.done) {\n\t\t\t\tthrow StopIteration ();\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn result.value;\n\t\t\t}\n\t\t}\t\n\t\tif (result == undefined) {\n\t\t\tthrow StopIteration ();\n\t\t}\n\t\treturn result;\n\t}\n\t__all__.py_next = py_next;\n\t\n\tfunction __SeqIterator__ (iterable) {\n\t\tthis.iterable = iterable;\n\t\tthis.index = 0;\n\t}\n\t\n\t__all__.__SeqIterator__ = __SeqIterator__;\n\t\n\t__SeqIterator__.prototype.__iter__ = function () {\n\t\treturn this;\n\t}\n\t\n\t__SeqIterator__.prototype.__next__ = function () {\n\t\treturn this.iterable [this.index++];\n\t}\n\t\n\t__SeqIterator__.prototype.next = wrap_py_next;\n\t\n\tfunction __KeyIterator__ (iterable) {\n\t\tthis.iterable = iterable;\n\t\tthis.index = 0;\n\t}\n\n\t__all__.__KeyIterator__ = __KeyIterator__;\n\t\n\t__KeyIterator__.prototype.__iter__ = function () {\n\t\treturn this;\n\t}\n\t\n\t__KeyIterator__.prototype.__next__ = function () {\n\t\treturn this.iterable.keys () [this.index++];\n\t}\n\t\t\t\n\t__KeyIterator__.prototype.next = wrap_py_next;\n\t\n\t// Reversed function for arrays\n\tvar py_reversed = function (iterable) {\n\t\titerable = iterable.slice ();\n\t\titerable.reverse ();\n\t\treturn iterable;\n\t}\n\t__all__.py_reversed = py_reversed;\n\t\n\t// Zip method for arrays\n\tvar zip = function () {\n\t\tvar args = [] .slice.call (arguments);\n\t\tvar shortest = args.length == 0 ? [] : args.reduce (\t// Find shortest array in arguments\n\t\t\tfunction (array0, array1) {\n\t\t\t\treturn array0.length < array1.length ? array0 : array1;\n\t\t\t}\n\t\t);\n\t\treturn shortest.map (\t\t\t\t\t// Map each element of shortest array\n\t\t\tfunction (current, index) {\t\t\t// To the result of this function\n\t\t\t\treturn args.map (\t\t\t\t// Map each array in arguments\n\t\t\t\t\tfunction (current) {\t\t// To the result of this function\n\t\t\t\t\t\treturn current [index]; // Namely it's index't entry\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t);\n\t}\n\t__all__.zip = zip;\n\t\n\t// Range method, returning an array\n\tfunction range (start, stop, step) {\n\t\tif (stop == undefined) {\n\t\t\t// one param defined\n\t\t\tstop = start;\n\t\t\tstart = 0;\n\t\t}\n\t\tif (step == undefined) {\n\t\t\tstep = 1;\n\t\t}\n\t\tif ((step > 0 && start >= stop) || (step < 0 && start <= stop)) {\n\t\t\treturn [];\n\t\t}\n\t\tvar result = [];\n\t\tfor (var i = start; step > 0 ? i < stop : i > stop; i += step) {\n\t\t\tresult.push(i);\n\t\t}\n\t\treturn result;\n\t};\n\t__all__.range = range;\n\t\n\t// Any, all and sum\n\t\n__pragma__ ('ifdef', '__esv6__')\n\tfunction any (iterable) {\n\t\tfor (let item of iterable) {\n\t\t\tif (bool (item)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tfunction all (iterable) {\n\t\tfor (let item of iterable) {\n\t\t\tif (! bool (item)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tfunction sum (iterable) {\n\t\tlet result = 0;\n\t\tfor (let item of iterable) {\n\t\t\tresult += item;\n\t\t}\n\t\treturn result;\n\t}\n__pragma__ ('else')\n\tfunction any (iterable) {\n\t\tfor (var index = 0; index < iterable.length; index++) {\n\t\t\tif (bool (iterable [index])) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tfunction all (iterable) {\n\t\tfor (var index = 0; index < iterable.length; index++) {\n\t\t\tif (! bool (iterable [index])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tfunction sum (iterable) {\n\t\tvar result = 0;\n\t\tfor (var index = 0; index < iterable.length; index++) {\n\t\t\tresult += iterable [index];\n\t\t}\n\t\treturn result;\n\t}\n__pragma__ ('endif')\n\n\t__all__.any = any;\n\t__all__.all = all;\n\t__all__.sum = sum;\n\t\n\t// Enumerate method, returning a zipped list\n\tfunction enumerate (iterable) {\n\t\treturn zip (range (len (iterable)), iterable);\n\t}\n\t__all__.enumerate = enumerate;\n\t\t\n\t// Shallow and deepcopy\n\t\n\tfunction copy (anObject) {\n\t\tif (anObject == null || typeof anObject == \"object\") {\n\t\t\treturn anObject;\n\t\t}\n\t\telse {\n\t\t\tvar result = {}\n\t\t\tfor (var attrib in obj) {\n\t\t\t\tif (anObject.hasOwnProperty (attrib)) {\n\t\t\t\t\tresult [attrib] = anObject [attrib];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n\t__all__.copy = copy;\n\t\n\tfunction deepcopy (anObject) {\n\t\tif (anObject == null || typeof anObject == \"object\") {\n\t\t\treturn anObject;\n\t\t}\n\t\telse {\n\t\t\tvar result = {}\n\t\t\tfor (var attrib in obj) {\n\t\t\t\tif (anObject.hasOwnProperty (attrib)) {\n\t\t\t\t\tresult [attrib] = deepcopy (anObject [attrib]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n\t__all__.deepcopy = deepcopy;\n\t\t\n\t// List extensions to Array\n\t\n\tfunction list (iterable) {\t\t\t\t\t\t\t\t\t\t// All such creators should be callable without new\n__pragma__ ('ifdef', '__esv6__')\n\t\tvar instance = iterable ? Array.from (iterable) : [];\n__pragma__ ('else')\n\t\tvar instance = iterable ? [] .slice.apply (iterable) : [];\t// Spread iterable, n.b. array.slice (), so array before dot\n__pragma__ ('endif')\n\t\t// Sort is the normal JavaScript sort, Python sort is a non-member function\n\t\treturn instance;\n\t}\n\t__all__.list = list;\n\tArray.prototype.__class__ = list;\t// All arrays are lists (not only if constructed by the list ctor), unless constructed otherwise\n\tlist.__name__ = 'list';\n\t\n\t/*\n\tArray.from = function (iterator) { // !!! remove\n\t\tresult = [];\n\t\tfor (item of iterator) {\n\t\t\tresult.push (item);\n\t\t}\n\t\treturn result;\n\t}\n\t*/\n\t\n\tArray.prototype.__iter__ = function () {\n\t\treturn new __SeqIterator__ (this);\n\t}\n\t\n\tArray.prototype.__getslice__ = function (start, stop, step) {\n\t\tif (start < 0) {\n\t\t\tstart = this.length + start;\n\t\t}\n\t\t\n\t\tif (stop == null) {\n\t\t\tstop = this.length;\n\t\t}\n\t\telse if (stop < 0) {\n\t\t\tstop = this.length + stop;\n\t\t}\n\t\t\n\t\tvar result = list ([]);\n\t\tfor (var index = start; index < stop; index += step) {\n\t\t\tresult.push (this [index]);\n\t\t}\n\t\t\n\t\treturn result;\n\t}\n\t\t\n\tArray.prototype.__setslice__ = function (start, stop, step, source) {\n\t\tif (start < 0) {\n\t\t\tstart = this.length + start;\n\t\t}\n\t\t\t\n\t\tif (stop == null) {\n\t\t\tstop = this.length;\n\t\t}\n\t\telse if (stop < 0) {\n\t\t\tstop = this.length + stop;\n\t\t}\n\t\t\t\n\t\tif (step == null) {\t// Assign to 'ordinary' slice, replace subsequence\n\t\t\tArray.prototype.splice.apply (this, [start, stop - start] .concat (source)) \n\t\t}\n\t\telse {\t\t\t\t// Assign to extended slice, replace designated items one by one\n\t\t\tvar sourceIndex = 0;\n\t\t\tfor (var targetIndex = start; targetIndex < stop; targetIndex += step) {\n\t\t\t\tthis [targetIndex] = source [sourceIndex++];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tArray.prototype.__repr__ = function () {\n\t\tif (this.__class__ == set && !this.length) {\n\t\t\treturn 'set()';\n\t\t}\n\t\t\n\t\tvar result = !this.__class__ || this.__class__ == list ? '[' : this.__class__ == tuple ? '(' : '{';\n\t\t\n\t\tfor (var index = 0; index < this.length; index++) {\n\t\t\tif (index) {\n\t\t\t\tresult += ', ';\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tresult += this [index] .__repr__ ();\n\t\t\t}\n\t\t\tcatch (exception) {\n\t\t\t\tresult += this [index] .toString ();\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (this.__class__ == tuple && this.length == 1) {\n\t\t\tresult += ',';\n\t\t}\n\t\t\n\t\tresult += !this.__class__ || this.__class__ == list ? ']' : this.__class__ == tuple ? ')' : '}';;\n\t\treturn result;\n\t};\n\t\n\tArray.prototype.__str__ = Array.prototype.__repr__;\n\t\n\tArray.prototype.append = function (element) {\n\t\tthis.push (element);\n\t};\n\n\tArray.prototype.clear = function () {\n\t\tthis.length = 0;\n\t};\n\t\n\tArray.prototype.extend = function (aList) {\n\t\tthis.push.apply (this, aList);\n\t};\n\t\n\tArray.prototype.insert = function (index, element) {\n\t\tthis.splice (index, 0, element);\n\t};\n\n\tArray.prototype.remove = function (element) {\n\t\tvar index = this.indexOf (element);\n\t\tif (index == -1) {\n\t\t\tthrow ('KeyError');\n\t\t}\n\t\tthis.splice (index, 1);\n\t};\n\n\tArray.prototype.index = function (element) {\n\t\treturn this.indexOf (element)\n\t};\n\t\n\tArray.prototype.py_pop = function (index) {\n\t\tif (index == undefined) {\n\t\t\treturn this.pop ()\t// Remove last element\n\t\t}\n\t\telse {\n\t\t\treturn this.splice (index, 1) [0];\n\t\t}\n\t};\t\n\t\n\tArray.prototype.py_sort = function () {\n\t\t__sort__.apply  (null, [this].concat ([] .slice.apply (arguments)));\t// Can't work directly with arguments\n\t\t// Python params: (iterable, key = None, reverse = False)\n\t\t// py_sort is called with the Transcrypt kwargs mechanism, and just passes the params on to __sort__\n\t\t// __sort__ is def'ed with the Transcrypt kwargs mechanism\n\t};\n\t\n\tArray.prototype.__add__ = function (aList) {\n\t\treturn list (this.concat (aList))\n\t}\n\t\n\tArray.prototype.__mul__ = function (scalar) {\n\t\tvar result = this;\n\t\tfor (var i = 1; i < scalar; i++) {\n\t\t\tresult = result.concat (this);\n\t\t}\n\t\treturn result;\n\t}\n\t\n\tArray.prototype.__rmul__ = Array.prototype.__mul__;\n\t\t\n\t// Tuple extensions to Array\n\t\n\tfunction tuple (iterable) {\n\t\tvar instance = iterable ? [] .slice.apply (iterable) : [];\n\t\tinstance.__class__ = tuple;\t// Not all arrays are tuples\n\t\treturn instance;\n\t}\n\t__all__.tuple = tuple;\n\ttuple.__name__ = 'tuple';\n\t\n\t// Set extensions to Array\n\t// N.B. Since sets are unordered, set operations will occasionally alter the 'this' array by sorting it\n\t\t\n\tfunction set (iterable) {\n\t\tvar instance = [];\n\t\tif (iterable) {\n\t\t\tfor (var index = 0; index < iterable.length; index++) {\n\t\t\t\tinstance.add (iterable [index]);\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\t\tinstance.__class__ = set;\t// Not all arrays are sets\n\t\treturn instance;\n\t}\n\t__all__.set = set;\n\tset.__name__ = 'set';\n\t\n\tArray.prototype.__bindexOf__ = function (element) {\t// Used to turn O (n^2) into O (n log n)\n\t// Since sorting is lex, compare has to be lex. This also allows for mixed lists\n\t\n\t\telement += '';\n\t\n\t\tvar mindex = 0;\n\t\tvar maxdex = this.length - 1;\n\t\t\t \n\t\twhile (mindex <= maxdex) {\n\t\t\tvar index = (mindex + maxdex) / 2 | 0;\n\t\t\tvar middle = this [index] + '';\n\t \n\t\t\tif (middle < element) {\n\t\t\t\tmindex = index + 1;\n\t\t\t}\n\t\t\telse if (middle > element) {\n\t\t\t\tmaxdex = index - 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn index;\n\t\t\t}\n\t\t}\n\t \n\t\treturn -1;\n\t}\n\t\n\tArray.prototype.add = function (element) {\t\t\n\t\tif (this.indexOf (element) == -1) {\t// Avoid duplicates in set\n\t\t\tthis.push (element);\n\t\t}\n\t};\n\t\n\tArray.prototype.discard = function (element) {\n\t\tvar index = this.indexOf (element);\n\t\tif (index != -1) {\n\t\t\tthis.splice (index, 1);\n\t\t}\n\t};\n\t\n\tArray.prototype.isdisjoint = function (other) {\n\t\tthis.sort ();\n\t\tfor (var i = 0; i < other.length; i++) {\n\t\t\tif (this.__bindexOf__ (other [i]) != -1) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t};\n\t\n\tArray.prototype.issuperset = function (other) {\n\t\tthis.sort ();\n\t\tfor (var i = 0; i < other.length; i++) {\n\t\t\tif (this.__bindexOf__ (other [i]) == -1) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t};\n\t\n\tArray.prototype.issubset = function (other) {\n\t\treturn set (other.slice ()) .issuperset (this);\t// Sort copy of 'other', not 'other' itself, since it may be an ordered sequence\n\t};\n\t\n\tArray.prototype.union = function (other) {\n\t\tvar result = set (this.slice () .sort ());\n\t\tfor (var i = 0; i < other.length; i++) {\n\t\t\tif (result.__bindexOf__ (other [i]) == -1) {\n\t\t\t\tresult.push (other [i]);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t};\n\t\n\tArray.prototype.intersection = function (other) {\n\t\tthis.sort ();\n\t\tvar result = set ();\n\t\tfor (var i = 0; i < other.length; i++) {\n\t\t\tif (this.__bindexOf__ (other [i]) != -1) {\n\t\t\t\tresult.push (other [i]);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t};\n\t\n\tArray.prototype.difference = function (other) {\n\t\tvar sother = set (other.slice () .sort ());\n\t\tvar result = set ();\n\t\tfor (var i = 0; i < this.length; i++) {\n\t\t\tif (sother.__bindexOf__ (this [i]) == -1) {\n\t\t\t\tresult.push (this [i]);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t};\n\t\n\tArray.prototype.symmetric_difference = function (other) {\n\t\treturn this.union (other) .difference (this.intersection (other));\n\t};\n\t\n\tArray.prototype.update = function () {\t// O (n)\n\t\tvar updated = [] .concat.apply (this.slice (), arguments) .sort ();\t\t\n\t\tthis.clear ();\n\t\tfor (var i = 0; i < updated.length; i++) {\n\t\t\tif (updated [i] != updated [i - 1]) {\n\t\t\t\tthis.push (updated [i]);\n\t\t\t}\n\t\t}\n\t};\n\t\n\tArray.prototype.__eq__ = function (other) {\t// Also used for list\n\t\tif (this.length != other.length) {\n\t\t\treturn false;\n\t\t}\n\t\tif (this.__class__ == set) {\n\t\t\tthis.sort ();\n\t\t\tother.sort ();\n\t\t}\t\n\t\tfor (var i = 0; i < this.length; i++) {\n\t\t\tif (this [i] != other [i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t};\n\t\n\tArray.prototype.__ne__ = function (other) {\t// Also used for list\n\t\treturn !this.__eq__ (other);\n\t}\n\t\t\n\tArray.prototype.__le__ = function (other) {\n\t\treturn this.issubset (other);\n\t}\n\t\t\n\tArray.prototype.__ge__ = function (other) {\n\t\treturn this.issuperset (other);\n\t}\n\t\t\n\tArray.prototype.__lt__ = function (other) {\n\t\treturn this.issubset (other) && !this.issuperset (other);\n\t}\n\t\t\n\tArray.prototype.__gt__ = function (other) {\n\t\treturn this.issuperset (other) && !this.issubset (other);\n\t}\n\t\n\t// Dict extensions to object\n\t\n\tfunction __keyIterator__ () {\n\t\treturn new __KeyIterator__ (this);\n\t}\n\t\n\tfunction __keys__ () {\n\t\tvar keys = []\n\t\tfor (var attrib in this) {\n\t\t\tif (!__specialattrib__ (attrib)) {\n\t\t\t\tkeys.push (attrib);\n\t\t\t}     \n\t\t}\n\t\treturn keys;\n\t}\n\t\t\n\tfunction __items__ () {\n\t\tvar items = []\n\t\tfor (var attrib in this) {\n\t\t\tif (!__specialattrib__ (attrib)) {\n\t\t\t\titems.push ([attrib, this [attrib]]);\n\t\t\t}     \n\t\t}\n\t\treturn items;\n\t}\n\t\t\n\tfunction __del__ (key) {\n\t\tdelete this [key];\n\t}\n\t\n\tfunction __clear__ () {\n\t\tfor (var attrib in this) {\n\t\t\tdelete this [attrib];\n\t\t}\n\t}\n\t\n\tfunction __setdefault__ (aKey, aDefault) {\n\t\tvar result = this [aKey];\n\t\tif (result != undefined) {\n\t\t\treturn result;\n\t\t}\n\t\tvar val = aDefault == undefined ? null : aDefault;\n\t\tthis [aKey] = val;\n\t\treturn val;\n\t}\n\t\n\tfunction __pop__ (aKey, aDefault) {\n\t\tvar result = this [aKey];\n\t\tif (result != undefined) {\n\t\t\tdelete this [aKey];\n\t\t\treturn result;\n\t\t}\n\t\treturn aDefault;\n\t}\t\n\t\n\tfunction __update__(aDict) {\n\t\tfor (var aKey in aDict) {\n\t\t\tthis [aKey] = aDict [aKey];\n\t\t}\n\t}\n\t\n\tfunction dict (objectOrPairs) {\n\t\tif (!objectOrPairs || objectOrPairs instanceof Array) {\t// It's undefined or an array of pairs\n\t\t\tvar instance = {};\n\t\t\tif (objectOrPairs) {\n\t\t\t\tfor (var index = 0; index < objectOrPairs.length; index++) {\n\t\t\t\t\tvar pair = objectOrPairs [index];\n\t\t\t\t\tinstance [pair [0]] = pair [1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\t\t\t\t\t\t\t\t\t\t\t\t\t// It's a JavaScript object literal\n\t\t\tvar instance = objectOrPairs;\n\t\t}\n\t\t\t\n\t\t// Trancrypt interprets e.g. {aKey: 'aValue'} as a Python dict literal rather than a JavaScript object literal\n\t\t// So dict literals rather than bare Object literals will be passed to JavaScript libraries\n\t\t// Some JavaScript libraries call all enumerable callable properties of an object that's passed to them\n\t\t// So the properties of a dict should be non-enumerable\n\t\tObject.defineProperty (instance, '__class__', {value: dict, enumerable: false, writable: true});\n\t\tObject.defineProperty (instance, 'keys', {value: __keys__, enumerable: false});\n\t\tObject.defineProperty (instance, '__iter__', {value: __keyIterator__, enumerable: false});\n\t\tObject.defineProperty (instance, 'items', {value: __items__, enumerable: false});\t\t\n\t\tObject.defineProperty (instance, 'del', {value: __del__, enumerable: false});\n\t\tObject.defineProperty (instance, 'clear', {value: __clear__, enumerable: false});\n\t\tObject.defineProperty (instance, 'setdefault', {value: __setdefault__, enumerable: false});\n\t\tObject.defineProperty (instance, 'py_pop', {value: __pop__, enumerable: false});\n\t\tObject.defineProperty (instance, 'update', {value: __update__, enumerable: false});\n\t\treturn instance;\n\t}\n\t__all__.dict = dict;\n\tdict.__name__ = 'dict';\n\t\n\t// String extensions\n\t\n\tfunction str (stringable) {\n\t\ttry {\n\t\t\treturn stringable.__str__ ();\n\t\t}\n\t\tcatch (exception) {\n\t\t\treturn new String (stringable);\n\t\t}\n\t}\n\t__all__.str = str;\t\n\t\n\tString.prototype.__class__ = str;\t// All strings are str\n\tstr.__name__ = 'str';\n\t\n\tString.prototype.__iter__ = function () {\n\t\treturn new __SeqIterator__ (this);\n\t}\n\t\t\n\tString.prototype.__repr__ = function () {\n\t\treturn (this.indexOf ('\\'') == -1 ? '\\'' + this + '\\'' : '\"' + this + '\"') .replace ('\\t', '\\\\t') .replace ('\\n', '\\\\n');\n\t};\n\t\n\tString.prototype.__str__ = function () {\n\t\treturn this;\n\t};\n\t\n\tString.prototype.capitalize = function () {\n\t\treturn this.charAt (0).toUpperCase () + this.slice (1);\n\t};\n\t\n\tString.prototype.endswith = function (suffix) {\n\t\treturn suffix == '' || this.slice (-suffix.length) == suffix;\n\t};\n\t\n\tString.prototype.find  = function (sub, start) {\n\t\treturn this.indexOf (sub, start);\n\t};\n\t\n\tString.prototype.__getslice__ = function (start, stop, step) {\n\t\tif (start < 0) {\n\t\t\tstart = this.length + start;\n\t\t}\n\t\t\n\t\tif (stop == null) {\n\t\t\tstop = this.length;\n\t\t}\n\t\telse if (stop < 0) {\n\t\t\tstop = this.length + stop;\n\t\t}\n\t\t\n\t\tvar result = '';\n\t\tif (step == 1) {\n\t\t\tresult = this.substring (start, stop);\n\t\t}\n\t\telse {\n\t\t\tfor (var index = start; index < stop; index += step) {\n\t\t\t\tresult = result.concat (this.charAt(index));\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\t\n\t// Since it's worthwhile for the 'format' function to be able to deal with *args, it is defined as a property\n\t// __get__ will produce a bound function if there's something before the dot\n\t// Since a call using *args is compiled to e.g. <object>.<function>.apply (null, args), the function has to be bound already\n\t// Otherwise it will never be, because of the null argument\n\t// Using 'this' rather than 'null' contradicts the requirement to be able to pass bound functions around\n\t// The object 'before the dot' won't be available at call time in that case, unless implicitly via the function bound to it\n\t// While for Python methods this mechanism is generated by the compiler, for JavaScript methods it has to be provided manually\n\t// Call memoizing is unattractive here, since every string would then have to hold a reference to a bound format method\n\tObject.defineProperty (String.prototype, 'format', {\n\t\tget: function () {return __get__ (this, function (self) {\n\t\t\tvar args = tuple ([] .slice.apply (arguments).slice (1));\t\t\t\n\t\t\tvar autoIndex = 0;\n\t\t\treturn self.replace (/\\{(\\w*)\\}/g, function (match, key) { \n\t\t\t\tif (key == '') {\n\t\t\t\t\tkey = autoIndex++;\n\t\t\t\t}\n\t\t\t\tif (key == +key) {\t// So key is numerical\n\t\t\t\t\treturn args [key] == undefined ? match : args [key];\n\t\t\t\t}\n\t\t\t\telse {\t\t\t\t// Key is a string\n\t\t\t\t\tfor (var index = 0; index < args.length; index++) {\n\t\t\t\t\t\t// Find first 'dict' that has that key and the right field\n\t\t\t\t\t\tif (typeof args [index] == 'object' && args [index][key] != undefined) {\n\t\t\t\t\t\t\treturn args [index][key];\t// Return that field field\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn match;\n\t\t\t\t}\n\t\t\t});\n\t\t});},\n\t\tenumerable: true\n\t});\n\t\n\tString.prototype.isnumeric = function () {\n\t\treturn !isNaN (parseFloat (this)) && isFinite (this);\n\t};\n\t\n\tString.prototype.join = function (strings) {\n__pragma__ ('ifdef', '__esv6__')\n\t\tstrings = Array.from (strings);\t// Much faster than iterating through strings char by char\n__pragma__ ('endif')\n\t\treturn strings.join (this);\n\t};\n\t\n\tString.prototype.lower = function () {\n\t\treturn this.toLowerCase ();\n\t};\n\t\n\tString.prototype.py_replace = function (old, aNew, maxreplace) {\n\t\treturn this.split (old, maxreplace) .join (aNew);\n\t};\n\t\n\tString.prototype.lstrip = function () {\n\t\treturn this.replace (/^\\s*/g, '');\n\t};\n\t\n\tString.prototype.rfind = function (sub, start) {\n\t\treturn this.lastIndexOf (sub, start);\n\t};\n\t\n\tString.prototype.rsplit = function (sep, maxsplit) {\t// Combination of general whitespace sep and positive maxsplit neither supported nor checked, expensive and rare\n\t\tif (sep == undefined || sep == null) {\n\t\t\tsep = /\\s+/;\n\t\t\tvar stripped = this.strip ();\n\t\t}\n\t\telse {\n\t\t\tvar stripped = this;\n\t\t}\n\t\t\t\n\t\tif (maxsplit == undefined || maxsplit == -1) {\n\t\t\treturn stripped.split (sep);\n\t\t}\n\t\telse {\n\t\t\tvar result = stripped.split (sep);\n\t\t\tif (maxsplit < result.length) {\n\t\t\t\tvar maxrsplit = result.length - maxsplit;\n\t\t\t\treturn [result.slice (0, maxrsplit) .join (sep)] .concat (result.slice (maxrsplit));\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t};\n\t\n\tString.prototype.rstrip = function () {\n\t\treturn this.replace (/\\s*$/g, '');\n\t};\n\t\n\tString.prototype.py_split = function (sep, maxsplit) {\t// Combination of general whitespace sep and positive maxsplit neither supported nor checked, expensive and rare\n\t\tif (sep == undefined || sep == null) {\n\t\t\tsep = /\\s+/\n\t\t\tvar stripped = this.strip ();\n\t\t}\n\t\telse {\n\t\t\tvar stripped = this;\n\t\t}\n\t\t\t\n\t\tif (maxsplit == undefined || maxsplit == -1) {\n\t\t\treturn stripped.split (sep);\n\t\t}\n\t\telse {\n\t\t\tvar result = stripped.split (sep);\n\t\t\tif (maxsplit < result.length) {\n\t\t\t\treturn result.slice (0, maxsplit).concat ([result.slice (maxsplit).join (sep)]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t};\n\t\n\tString.prototype.startswith = function (prefix) {\n\t\treturn this.indexOf (prefix) == 0;\n\t};\n\t\n\tString.prototype.strip = function () {\n\t\treturn this.trim ();\n\t};\n\t\t\n\tString.prototype.upper = function () {\n\t\treturn this.toUpperCase ();\n\t};\n\t\n\tString.prototype.__mul__ = function (scalar) {\n\t\tvar result = this;\n\t\tfor (var i = 1; i < scalar; i++) {\n\t\t\tresult = result + this;\n\t\t}\n\t\treturn result;\n\t}\n\t\n\tString.prototype.__rmul__ = String.prototype.__mul__;\n\t\t\n\t// General operator overloading, only the ones that make most sense in matrix and complex operations\n\t\n\tvar __neg__ = function (a) {\n\t\tif (typeof a == 'object' && '__neg__' in a) {\n\t\t\treturn a.__neg__ ();\n\t\t}\n\t\telse {\n\t\t\treturn -a;\n\t\t}\n\t};  \n\t__all__.__neg__ = __neg__;\n\t\n\tvar __matmul__ = function (a, b) {\n\t\treturn a.__matmul__ (b);\n\t};  \n\t__all__.__matmul__ = __matmul__;\n\t\n\tvar __pow__ = function (a, b) {\n\t\tif (typeof a == 'object' && '__pow__' in a) {\n\t\t\treturn a.__pow__ (b);\n\t\t}\n\t\telse if (typeof b == 'object' && '__rpow__' in b) {\n\t\t\treturn b.__rpow__ (a);\n\t\t}\n\t\telse {\n\t\t\treturn Math.pow (a, b);\n\t\t}\n\t};\t\n\t__all__.pow = __pow__;\n\t\n\tvar __mul__ = function (a, b) {\n\t\tif (typeof a == 'object' && '__mul__' in a) {\n\t\t\treturn a.__mul__ (b);\n\t\t}\n\t\telse if (typeof b == 'object' && '__rmul__' in b) {\n\t\t\treturn b.__rmul__ (a);\n\t\t}\n\t\telse if (typeof a == 'string') {\n\t\t\treturn a.__mul__ (b);\n\t\t}\n\t\telse if (typeof b == 'string') {\n\t\t\treturn b.__rmul__ (a);\n\t\t}\n\t\telse {\n\t\t\treturn a * b;\n\t\t}\n\t};  \n\t__all__.__mul__ = __mul__;\n\t\n\tvar __div__ = function (a, b) {\n\t\tif (typeof a == 'object' && '__div__' in a) {\n\t\t\treturn a.__div__ (b);\n\t\t}\n\t\telse if (typeof b == 'object' && '__rdiv__' in b) {\n\t\t\treturn b.__rdiv__ (a);\n\t\t}\n\t\telse {\n\t\t\treturn a / b;\n\t\t}\n\t};  \n\t__all__.__div__ = __div__;\n\t\n\tvar __add__ = function (a, b) {\n\t\tif (typeof a == 'object' && '__add__' in a) {\n\t\t\treturn a.__add__ (b);\n\t\t}\n\t\telse if (typeof b == 'object' && '__radd__' in b) {\n\t\t\treturn b.__radd__ (a);\n\t\t}\n\t\telse {\n\t\t\treturn a + b;\n\t\t}\n\t};  \n\t__all__.__add__ = __add__;\n\t\n\tvar __sub__ = function (a, b) {\n\t\tif (typeof a == 'object' && '__sub__' in a) {\n\t\t\treturn a.__sub__ (b);\n\t\t}\n\t\telse if (typeof b == 'object' && '__rsub__' in b) {\n\t\t\treturn b.__rsub__ (a);\n\t\t}\n\t\telse {\n\t\t\treturn a - b;\n\t\t}\n\t};  \n\t__all__.__sub__ = __sub__;\n\t\n\tvar __eq__ = function (a, b) {\n\t\tif (typeof a == 'object' && '__eq__' in a) {\n\t\t\treturn a.__eq__ (b);\n\t\t}\n\t\telse {\n\t\t\treturn a == b\n\t\t}\n\t};\n\t__all__.__eq__ = __eq__;\n\t\t\n\tvar __ne__ = function (a, b) {\n\t\tif (typeof a == 'object' && '__ne__' in a) {\n\t\t\treturn a.__ne__ (b);\n\t\t}\n\t\telse {\n\t\t\treturn a != b\n\t\t}\n\t};\n\t__all__.__ne__ = __ne__;\n\t\t\n\tvar __lt__ = function (a, b) {\n\t\tif (typeof a == 'object' && '__lt__' in a) {\n\t\t\treturn a.__lt__ (b);\n\t\t}\n\t\telse {\n\t\t\treturn a < b\n\t\t}\n\t};\n\t__all__.__lt__ = __lt__;\n\t\t\n\tvar __le__ = function (a, b) {\n\t\tif (typeof a == 'object' && '__le__' in a) {\n\t\t\treturn a.__le__ (b);\n\t\t}\n\t\telse {\n\t\t\treturn a <= b\n\t\t}\n\t};\n\t__all__.__le__ = __le__;\n\t\t\n\tvar __gt__ = function (a, b) {\n\t\tif (typeof a == 'object' && '__gt__' in a) {\n\t\t\treturn a.__gt__ (b);\n\t\t}\n\t\telse {\n\t\t\treturn a > b\n\t\t}\n\t};\n\t__all__.__gt__ = __gt__;\n\t\t\n\tvar __ge__ = function (a, b) {\n\t\tif (typeof a == 'object' && '__ge__' in a) {\n\t\t\treturn a.__ge__ (b);\n\t\t}\n\t\telse {\n\t\t\treturn a >= b\n\t\t}\n\t};\n\t__all__.__ge__ = __ge__;\n\t\t\n\tvar __getitem__ = function (container, key) {\t\t\t\t\t\t\t// Slice c.q. index, direct generated call to runtime switch\n\t\tif (typeof container == 'object' && '__getitem__' in container) {\n\t\t\treturn container.__getitem__ (key);\t\t\t\t\t\t\t\t// Overloaded on container\n\t\t}\n\t\telse {\n\t\t\treturn container [key];\t\t\t\t\t\t\t\t\t\t\t// Container must support bare JavaScript brackets\n\t\t}\n\t};\n\t__all__.__getitem__ = __getitem__;\n\n\tvar __setitem__ = function (container, key, value) {\t\t\t\t\t// Slice c.q. index, direct generated call to runtime switch\n\t\tif (typeof container == 'object' && '__setitem__' in container) {\n\t\t\tcontainer.__setitem__ (key, value);\t\t\t\t\t\t\t\t// Overloaded on container\n\t\t}\n\t\telse {\n\t\t\tcontainer [key] = value;\t\t\t\t\t\t\t\t\t\t// Container must support bare JavaScript brackets\n\t\t}\n\t};\n\t__all__.__setitem__ = __setitem__;\n\n\tvar __getslice__ = function (container, lower, upper, step) {\t\t\t// Slice only, no index, direct generated call to runtime switch\n\t\tif (typeof container == 'object' && '__getitem__' in container) {\n\t\t\treturn container.__getitem__ ([lower, upper, step]);\t\t\t// Container supports overloaded slicing c.q. indexing\n\t\t}\n\t\telse {\n\t\t\treturn container.__getslice__ (lower, upper, step);\t\t\t\t// Container only supports slicing injected natively in prototype\n\t\t}\n\t};\n\t__all__.__getslice__ = __getslice__;\n\n\tvar __setslice__ = function (container, lower, upper, step, value) {\t// Slice, no index, direct generated call to runtime switch\n\t\tif (typeof container == 'object' && '__setitem__' in container) {\n\t\t\tcontainer.__setitem__ ([lower, upper, step], value);\t\t\t// Container supports overloaded slicing c.q. indexing\n\t\t}\n\t\telse {\n\t\t\tcontainer.__setslice__ (lower, upper, step, value);\t\t\t\t// Container only supports slicing injected natively in prototype\n\t\t}\n\t};\n\t__all__.__setslice__ = __setslice__;\n\n\tvar __call__ = function (/* <callee>, <params>* */) {\n\t\tvar args = [] .slice.apply (arguments)\n\t\tif (typeof args [0] == 'object' && '__call__' in args [0]) {\n\t\t\treturn args [0] .__call__ .apply (null,  args.slice (1));\n\t\t}\n\t\telse {\n\t\t\treturn args [0] .apply (null, args.slice (1));\n\t\t}\t\t\n\t};\n\t__all__.__call__ = __call__;\n\n",
		"from org.transcrypt.stubs.browser import *\nfrom org.transcrypt.stubs.browser import __main__, __envir__, __pragma__\n\n# Imports for Transcrypt, resolved run time\nif __envir__.executor_name == __envir__.transpiler_name:\n\timport numscrypt as num\n\n# Imports for CPython, resolved compile time\n__pragma__ ('skip')\nimport numpy as num\n__pragma__ ('noskip')\n\ndef run (autoTester):\n\tz = num.zeros ((4, 3), 'int32')\n\tautoTester.check ('Zeros', z.tolist (), '<br>')\n\t\n\to = num.ones ((4, 5))\n\tautoTester.check ('Ones', o.astype ('int32') .tolist ())\n\t\n\ti = num.identity (3, 'int32')\n\tautoTester.check ('Identity', i.tolist (), '<br>')\n\t\n\t# shape: 2 blocks x 3 rows x 4 columns\n\t\n\ta = num.array ([\n\t\t[1, 1, 2, 3],\n\t\t[4, 5, 6, 7],\n\t\t[8, 9, 10, 12]\n\t])\n\t\n\tautoTester.check ('Matrix a', a.tolist (), '<br>')\n\t\n\tautoTester.check ('Transpose of a', a.transpose () .tolist (), '<br>')\n\t\n\tb = num.array ([\n\t\t[2, 2, 4, 6],\n\t\t[8, 10, 12, 14],\n\t\t[16, 18, 20, 24]\n\t])\n\t\n\tbp =  b.transpose ()\n\t\n\tautoTester.check ('Matrix b', b.tolist (), '<br>')\n\tautoTester.check ('Permutation of b', bp.tolist (), '<br>')\n\t\t\n\tc = num.array ([\n\t\t[1, 2, 3, 4],\n\t\t[5, 6, 7, 8],\n\t\t[9, 10, 11, 12],\n\t], 'int32')\n\t\n\tautoTester.check ('Shape c', tuple (c.shape), '<br>')\n\tautoTester.check ('Matrix c', c.tolist (), '<br>')\n\t\n\tct = c.transpose ()\n\tautoTester.check ('Shape ct', tuple (ct.shape), '<br>')\n\tautoTester.check ('Transpose of c', ct .tolist (), '<br>')\n\n\tcs0, cs1 = num.hsplit (c, 2)\n\tautoTester.check ('Matrix cs0', cs0.tolist (), '<br>')\n\tautoTester.check ('Matrix cs1', cs1.tolist (), '<br>')\n\n\tci = num.hstack ((cs1, cs0))\n\tautoTester.check ('Matrix ci', ci.tolist (), '<br>')\n\t\n\tcts0, cts1, cts2 = num.hsplit (ct, 3)\n\tautoTester.check ('Matrix cts0', cts0.tolist (), '<br>')\n\tautoTester.check ('Matrix cts1', cts1.tolist (), '<br>')\n\tautoTester.check ('Matrix cts2', cts2.tolist (), '<br>')\n\n\tcti = num.hstack ((cts2, cts1, cts0))\n\tautoTester.check ('Matrix ci', cti.tolist (), '<br>')\n\t\n\td = num.array ([\n\t\t[13, 14],\n\t\t[15, 16],\n\t\t[17, 18],\n\t\t[19, 20]\n\t], 'int32')\n\t\n\tautoTester.check ('Matrix d', d.tolist (), '<br>')\n\tdt = d.transpose ()\n\tautoTester.check ('Permutation of d', dt.tolist (), '<br>')\n\t\n\tds0, ds1, ds2, ds3 = num.vsplit (d, 4)\n\tautoTester.check ('Matrix ds0', ds0.tolist (), '<br>')\n\tautoTester.check ('Matrix ds1', ds1.tolist (), '<br>')\n\tautoTester.check ('Matrix ds2', ds2.tolist (), '<br>')\n\tautoTester.check ('Matrix ds3', ds3.tolist (), '<br>')\n\n\tdi = num.vstack ((ds3, ds2, ds1, ds0))\n\tautoTester.check ('Matrix di', di.tolist (), '<br>')\n\t\n\tdts0, dts1 = num.vsplit (dt, 2)\n\tautoTester.check ('Matrix dts0', dts0.tolist (), '<br>')\n\tautoTester.check ('Matrix dts1', dts1.tolist (), '<br>')\n\n\tdti = num.vstack ((dts1, dts0))\n\tautoTester.check ('Matrix dti', dti.tolist (), '<br>')\n\t\n\tv0 = num.array (range (10))\t\n\tv1 = num.array ((1, 2, 3, 1, 2, 3, 1, 2, 3, 1))\n\n\t__pragma__ ('opov')\n\t\n\ta [1, 0] = 177\n\tel = b [1, 2]\n\t\n\tbsl0 = b [1, 1 : 3]\n\tbsl1 = b [1 : 2, 1 : 3]\n\tbsl2 = b [1 : 2, 1]\n\tbsl3 = b [1, 1 : 3]\n\tbsl4 = b [ : , 1]\n\tbsl5 = b [1, 1 : 3]\n\tbsl6 = b [1, 1 : 3]\n\tbsl7 = b [1, 2 : 3]\n\n\tbpsl0 = bp [1, 1 : 3]\n\tbpsl1 = bp [1 : 2, 1 : 3]\n\tbpsl2 = bp [1, 0 : ]\n\tbpsl3 = bp [1, 1 : 3]\n\tbpsl4 = bp [ : , 1]\n\tbpsl5 = bp [3, 1 : 3]\n\tbpsl6 = bp [2 : 4, 1 : 3]\n\tbpsl7 = bp [2 : 4, 2 : 3]\n\t\n\tsum = a + b\n\tdif = a - b\n\tprod = a * b\n\tquot = a / b\n\tdot = c @ d\n\tvsum = v0 + v1\n\tvel = vsum [6]\n\tvsum [6] = 70\n\t\n\tmul_a3 = a * 3\n\tmul_3a = 3 * a\n\tdiv_a3 = a / 3.1234567\n\tdiv_3a = 3.1234567 / a\n\tadd_a3 = a + 3\n\tadd_3a = 3 + a\n\tsub_a3 = a - 3\n\tsub_3a = 3 - a\n\tneg_a = -a\n\t\n\t__pragma__ ('noopov')\n\t\t\n\tautoTester.check ('El a [1, 2, 3] alt', a.tolist (), '<br>')\n\tautoTester.check ('El b [1, 2, 3]', el, '<br>')\n\t\n\tautoTester.check ('Sl b0', bsl0.tolist (), '<br>')\n\tautoTester.check ('Sl b1', bsl1.tolist (), '<br>')\n\tautoTester.check ('Sl b2', bsl2.tolist (), '<br>')\n\tautoTester.check ('Sl b3', bsl3.tolist (), '<br>')\n\tautoTester.check ('Sl b4', bsl4.tolist (), '<br>')\n\tautoTester.check ('Sl b5', bsl5.tolist (), '<br>')\n\tautoTester.check ('Sl b6', bsl6.tolist (), '<br>')\n\tautoTester.check ('Sl b7', bsl7.tolist (), '<br>')\n\t\n\tautoTester.check ('Sl bp0', bpsl0.tolist (), '<br>')\n\tautoTester.check ('Sl bp1', bpsl1.tolist (), '<br>')\n\tautoTester.check ('Sl bp2', bpsl2.tolist (), '<br>')\n\tautoTester.check ('Sl bp3', bpsl3.tolist (), '<br>')\n\tautoTester.check ('Sl bp4', bpsl4.tolist (), '<br>')\n\tautoTester.check ('Sl bp5', bpsl5.tolist (), '<br>')\n\tautoTester.check ('Sl bp6', bpsl6.tolist (), '<br>')\n\tautoTester.check ('Sl bp7', bpsl7.tolist (), '<br>')\n\t\n\tautoTester.check ('Matrix sum', sum.tolist (), '<br>')\n\tautoTester.check ('Matrix difference', dif.tolist (), '<br>')\n\tautoTester.check ('Matrix product', prod.tolist (), '<br>')\n\tautoTester.check ('Matrix quotient', quot.tolist (), '<br>')\n\tautoTester.check ('Matrix dotproduct', dot.tolist (), '<br>')\n\t\n\tautoTester.check ('Vector', v0.tolist (), '<br>')\n\tautoTester.check ('Vector', v1.tolist (), '<br>')\n\tautoTester.check ('El sum old', vel, '<br>')\n\tautoTester.check ('Vector sum new', vsum.tolist (), '<br>')\n\t\n\tautoTester.check ('mul_a3', mul_a3.tolist (), '<br>')\n\tautoTester.check ('mul_3a', mul_3a.tolist (), '<br>')\n\tautoTester.check ('div_a3', num.round (div_a3, 2).tolist (), '<br>')\n\tautoTester.check ('div_3a', num.round (div_3a, 2).tolist (), '<br>')\n\tautoTester.check ('add_a3', add_a3.tolist (), '<br>')\n\tautoTester.check ('add_3a', add_3a.tolist (), '<br>')\n\tautoTester.check ('sub_a3', sub_a3.tolist (), '<br>')\n\tautoTester.check ('sub_3a', sub_3a.tolist (), '<br>')\n\tautoTester.check ('neg_a', neg_a.tolist (), '<br>')\n\t\n\t__pragma__ ('opov')\n\tcomp_a = num.array ([\n\t\t[1 + 2j, 2 - 1j, 3],\n\t\t[4, 5 + 3j, 7]\n\t], 'complex128')\t\n\tcomp_b = num.array ([\n\t\t[6, 8 - 1j],\n\t\t[9 + 3j, 10],\n\t\t[11, 12 - 6j]\n\t], 'complex128')\n\tcomp_c = comp_a @ comp_b\n\t__pragma__ ('noopov')\n\t\n\tautoTester.check ('comp_a', comp_a.tolist (), '<br>')\n\tautoTester.check ('comp_b', comp_b.tolist (), '<br>')\n\tautoTester.check ('comp_c', comp_c.tolist (), '<br>')\n\t\n\t__pragma__ ('opov')\n\t\n\tcomp_a_square = comp_a [ : , : 2]\n\tcomp_b_square = comp_b [1 : , : ]\n\t\n\tcomp_c_square = comp_a_square * comp_b_square\n\tcomp_d_square = comp_a_square / comp_b_square\n\tcomp_e_square = comp_a_square + comp_b_square\n\tcomp_f_square = comp_a_square - comp_b_square\n\t\n\t__pragma__ ('noopov')\n\t\n\tautoTester.check ('comp_a_square', comp_a_square.tolist (), '<br>')\n\tautoTester.check ('comp_b_square', comp_b_square.tolist (), '<br>')\n\tautoTester.check ('comp_c_square', comp_c_square.tolist (), '<br>')\n\tautoTester.check ('comp_d_square', num.round (comp_d_square, 2).tolist (), '<br>')\n\tautoTester.check ('comp_e_square', comp_e_square.tolist (), '<br>')\n\tautoTester.check ('comp_f_square', comp_f_square.tolist (), '<br>')\n\t\n\t__pragma__ ('opov')\n\tsliceable_a = num.array ([\n\t\t[1, 2, 3, 4],\n\t\t[5, 6, 7, 8],\n\t\t[9, 10, 11, 12],\n\t\t[13, 14, 15, 16]\n\t])\n\tautoTester.check ('sliceable_a', sliceable_a.tolist ())\n\n\tslice_a = sliceable_a [1 : , 1 : ]\n\tautoTester.check ('slice_a')\n\t\n\tsliceable_at = sliceable_a.transpose ()\n\tslice_at = sliceable_at [1 : ]\n\t\n\t__pragma__ ('noopov')\n\t",
		"\t__nest__ (\n\t\t__all__,\n\t\t'itertools', {\n\t\t\t__all__: {\n\t\t\t\t__inited__: false,\n\t\t\t\t__init__: function (__all__) {\n__pragma__ ('ifdef', '__esv6__')\n\t\t\t\t\tvar count = function* (start, step) {\n\t\t\t\t\t\tif (start == undefined) {\n\t\t\t\t\t\t\tstart = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (step == undefined) {\n\t\t\t\t\t\t\tstep = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\tyield start;\n\t\t\t\t\t\t\tstart += step;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tvar cycle = function* (iterable) {\t\t\t\t\t\t\n\t\t\t\t\t\tlet buffer = Array.from (iterable);\t// Can't reset, Chrome can't obtain iter from gener\n\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\tfor (let item of buffer) {\n\t\t\t\t\t\t\t\tyield item;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tvar repeat = function* (item, n) {\n\t\t\t\t\t\tif (typeof n == 'undefined') {\n\t\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\t\tyield item;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tfor (let index = 0; index < n; index++) {\n\t\t\t\t\t\t\t\tyield item;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tvar accumulate = function* (iterable, func) {\n\t\t\t\t\t\tlet sum;\n\t\t\t\t\t\tlet first = true;\n\t\t\t\t\t\tif (func) {\n\t\t\t\t\t\t\tfor (let item of iterable) {\n\t\t\t\t\t\t\t\tif (first) {\n\t\t\t\t\t\t\t\t\tsum = item;\n\t\t\t\t\t\t\t\t\tfirst = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tsum = func (sum, item);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tyield sum;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tfor (let item of iterable) {\n\t\t\t\t\t\t\t\tif (first) {\n\t\t\t\t\t\t\t\t\tsum = item;\n\t\t\t\t\t\t\t\t\tfirst = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tsum = sum + item;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tyield sum;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tvar chain = function* () {\n\t\t\t\t\t\tlet args = [] .slice.apply (arguments);\t\t\t\t\t\t\t\n\t\t\t\t\t\tfor (let arg of args) {\n\t\t\t\t\t\t\tfor (let item of arg) {\n\t\t\t\t\t\t\t\tyield item;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tchain.from_iterable = function* (iterable) {\t\t\t\t\t\t\n\t\t\t\t\t\tfor (let item of iterable) {\n\t\t\t\t\t\t\tfor (let subItem of item) {\n\t\t\t\t\t\t\t\tyield subItem;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tvar compress = function* (data, selectors) {\n\t\t\t\t\t\tlet dataIterator = data [Symbol.iterator] .call (data);\n\t\t\t\t\t\tlet selectorsIterator = selectors [Symbol.iterator] ();\n\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\tlet dataItem = dataIterator.next ();\n\t\t\t\t\t\t\tlet selectorsItem = selectorsIterator.next ();\n\t\t\t\t\t\t\tif (dataItem.done || selectorsItem.done) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (selectorsItem.value) {\n\t\t\t\t\t\t\t\t\tyield dataItem.value;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tvar dropwhile = function* (pred, seq) {\n\t\t\t\t\t\tlet started = false;\n\t\t\t\t\t\tfor (let item of seq) {\n\t\t\t\t\t\t\tif (started) {\n\t\t\t\t\t\t\t\tyield item;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (!pred (item)) {\n\t\t\t\t\t\t\t\tstarted = true;\n\t\t\t\t\t\t\t\tyield item;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tvar filterfalse = function* (pred, seq) {\n\t\t\t\t\t\tfor (let item of seq) {\n\t\t\t\t\t\t\tif (!pred (item)) {\n\t\t\t\t\t\t\t\tyield item;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tvar groupby = function* (iterable, keyfunc) {\n\t\t\t\t\t\tlet anIterator = iterable [Symbol.iterator] ();\n\t\t\t\t\t\tlet item = anIterator.next ();\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (item.done) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tlet groupKey = keyfunc (item.value);\n\t\t\t\t\t\tlet more = true;\n\t\t\t\t\t\t\n\t\t\t\t\t\tfunction* group () {\n\t\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\t\tyield (item.value);\n\t\t\t\t\t\t\t\titem = anIterator.next ();\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif (item.done) {\n\t\t\t\t\t\t\t\t\tmore = false;\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tlet key = keyfunc (item.value);\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif (key != groupKey) {\n\t\t\t\t\t\t\t\t\tgroupKey = key;\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\twhile (more) {\n\t\t\t\t\t\t\tyield tuple ([groupKey, group ()]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tvar islice = function* () {\n\t\t\t\t\t\tlet start;\t// Have to be defined at function level, or Closure compiler will loose them after a yield \n\t\t\t\t\t\tlet stop;\t//\n\t\t\t\t\t\tlet step;\t//\n\t\t\t\t\t\t\n\t\t\t\t\t\tlet args = [] .slice.apply (arguments);\n\t\t\t\t\t\tlet anIterator = args [0][Symbol.iterator] ();\n\t\t\t\t\t\tif (args.length == 2) {\n\t\t\t\t\t\t\tstop = args [1];\n\t\t\t\t\t\t\tstart = 0;\n\t\t\t\t\t\t\tstep = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tstart = args [1];\n\t\t\t\t\t\t\tstop = args [2];\n\t\t\t\t\t\t\tif (args.length == 4) {\n\t\t\t\t\t\t\t\tstep = args [3];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tstep = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (let index = 0; index < start; index++) {\n\t\t\t\t\t\t\tif (anIterator.next (). done) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (let index = 0; index < stop - start; index++) {\n\t\t\t\t\t\t\tlet next = anIterator.next ();\n\t\t\t\t\t\t\tif (next.done) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (index % step == 0) {\n\t\t\t\t\t\t\t\tyield next.value;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tvar starmap = function* (func, seq) {\n\t\t\t\t\t\tlet anIterator = seq [Symbol.iterator] ();\n\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\tlet next = anIterator.next ()\n\t\t\t\t\t\t\tif (next.done) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tyield func (...next.value); \n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tvar takewhile = function* (pred, seq) {\n\t\t\t\t\t\tfor (let item of seq) {\n\t\t\t\t\t\t\tif (pred (item)) {\n\t\t\t\t\t\t\t\tyield item;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tvar tee = function (iterable, n) {\n\t\t\t\t\t\tif (n == undefined) {\n\t\t\t\t\t\t\tn = 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlet all = [];\t\t\t\t\t\t\t\t// Don't return iterator since destructuring assignment cannot yet deal with that\n\t\t\t\t\t\tlet one = list (iterable);\n\t\t\t\t\t\tfor (let i = 0; i < n; i++) {\n\t\t\t\t\t\t\tall.append (one [Symbol.iterator] ());\t// Iterator rather than list, exhaustable for semantic equivalence\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn list (all);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tvar product = function () {\n\t\t\t\t\t\tlet args = [] .slice.apply (arguments);\n\t\t\t\t\t\tif (args.length && args [args.length - 1] .__class__ == __kwargdict__) {\n\t\t\t\t\t\t\tvar repeat = args.pop () ['repeat']; \n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tvar repeat = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tlet oldMolecules = [tuple ([])];\n\t\t\t\t\t\tfor (let i = 0; i < repeat; i++) {\n\t\t\t\t\t\t\tfor (let arg of args) {\n\t\t\t\t\t\t\t\tlet newMolecules = [];\n\t\t\t\t\t\t\t\tfor (let oldMolecule of oldMolecules) {\n\t\t\t\t\t\t\t\t\tfor (let atom of arg) {\n\t\t\t\t\t\t\t\t\t\tnewMolecules.append (tuple (oldMolecule.concat (atom)));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\toldMolecules = newMolecules;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn list (oldMolecules);\t// Also works if args is emptpy\n\t\t\t\t\t}\n\t\t\t\t\tvar permutations = function (iterable, r) {\n\t\t\t\t\t\tif (r == undefined) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tr = len (iterable);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (exception) {\n\t\t\t\t\t\t\t\tr = len (list (iterable));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlet aProduct = product (iterable, __kwargdict__ ({repeat: r}));\n\t\t\t\t\t\tlet result = [];\n\t\t\t\t\t\tfor (let molecule of aProduct) {\n\t\t\t\t\t\t\tif (len (set (molecule)) == r) {\t// Weed out doubles\n\t\t\t\t\t\t\t\tresult.append (molecule);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn list (result);\n\t\t\t\t\t}\n\t\t\t\t\tvar combinations = function (iterable, r) {\n\t\t\t\t\t\tlet tail = list (iterable);\n\t\t\t\t\t\tfunction recurse (tail, molecule, rNext) {\n\t\t\t\t\t\t\tfor (let index = 0; index < len (tail) - rNext; index++) {\n\t\t\t\t\t\t\t\tlet newMolecule = molecule.concat (tail.slice (index, index + 1));\n\n\t\t\t\t\t\t\t\tif (rNext) {\n\t\t\t\t\t\t\t\t\trecurse (tail.slice (index + 1), newMolecule, rNext - 1);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tresult.append (tuple (newMolecule));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlet result = [];\n\t\t\t\t\t\trecurse (tail, tail.slice (0, 0), r - 1);\n\t\t\t\t\t\treturn list (result);\n\t\t\t\t\t}\n\t\t\t\t\tvar combinations_with_replacement = function (iterable, r) {\n\t\t\t\t\t\tlet tail = list (iterable);\n\t\t\t\t\t\tfunction recurse (tail, molecule, rNext) {\n\t\t\t\t\t\t\tfor (let index = 0; index < len (tail); index++) {\n\t\t\t\t\t\t\t\tlet newMolecule = molecule.concat (tail.slice (index, index + 1));\n\n\t\t\t\t\t\t\t\tif (rNext) {\n\t\t\t\t\t\t\t\t\trecurse (tail.slice (index), newMolecule, rNext - 1);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tresult.append (tuple (newMolecule));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlet result = [];\n\t\t\t\t\t\trecurse (tail, tail.slice (0, 0), r - 1);\n\t\t\t\t\t\treturn list (result);\n\t\t\t\t\t}\n__pragma__ ('else')\n\t\t\t\t\tvar chain = function () {\n\t\t\t\t\t\tvar args = [] .slice.apply (arguments);\n\t\t\t\t\t\tvar result = [];\n\t\t\t\t\t\tfor (var index = 0; index < args.length; index++) {\n\t\t\t\t\t\t\tresult = result.concat (args [index]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn list (result);\n\t\t\t\t\t}\n__pragma__ ('endif')\n\t\t\t\t\t//<all>\n__pragma__ ('ifdef', '__esv6__')\n\t\t\t\t\t__all__.count = count;\n\t\t\t\t\t__all__.cycle = cycle;\n\t\t\t\t\t__all__.repeat = repeat;\n\t\t\t\t\t__all__.accumulate = accumulate;\n\t\t\t\t\t__all__.chain = chain;\n\t\t\t\t\t__all__.compress = compress;\n\t\t\t\t\t__all__.dropwhile = dropwhile;\n\t\t\t\t\t__all__.filterfalse = filterfalse;\n\t\t\t\t\t__all__.groupby = groupby;\n\t\t\t\t\t__all__.islice = islice;\n\t\t\t\t\t__all__.starmap = starmap;\n\t\t\t\t\t__all__.takewhile = takewhile;\n\t\t\t\t\t__all__.tee = tee;\n\t\t\t\t\t__all__.product = product;\n\t\t\t\t\t__all__.permutations = permutations;\n\t\t\t\t\t__all__.combinations = combinations;\n\t\t\t\t\t__all__.combinations_with_replacement = combinations_with_replacement;\n__pragma__ ('else')\n\t\t\t\t\t__all__.chain = chain;\n__pragma__ ('endif')\n\t\t\t\t\t//</all>\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t);\n",
		"pi = Math.PI\ne = Math.E\n\nexp = Math.exp\n\ndef expm1 (x):\t\t# IE workaround\n\treturn Math.exp (x) - 1\n\ndef log (x, base):\n\treturn Math.log (x) if base is js_undefined else Math.log (x) / Math.log (base)\n\ndef log1p (x):\t\t# IE workaround\n\treturn Math.log (x + 1)\n\ndef log2 (x):\t\t# IE workaround\n\treturn Math.log (x) / Math.LN2\n\t\ndef log10 (x):\t\t# IE workaround\n\treturn Math.log (x) / Math.LN10\n\npow = Math.pow\nsqrt = Math.sqrt\n\nsin = Math.sin\ncos = Math.cos\ntan = Math.tan\n\nasin = Math.asin\nacos = Math.acos\natan = Math.atan\natan2 = Math.atan2\n\nhypot = Math.hypot\n\t\ndef degrees (x):\n\treturn x * 180 / Math.PI\n\t\ndef radians (x):\n\treturn x * Math.PI / 180\n\t\nsinh = Math.sinh\ncosh = Math.cosh\ntanh = Math.tanh\n\nasinh = Math.asinh\nacosh = Math.acosh\natanh = Math.atanh\n\nfloor = Math.floor\nceil = Math.ceil\ntrunc = Math.trunc\n\ninf = js_Infinity\nnan = js_NaN\n",
		"from org.transcrypt.stubs.browser import *\nfrom org.transcrypt.stubs.browser import __main__, __envir__, __pragma__\n\nfrom math import sin, cos, pi\n\ntranspiled = __envir__.executor_name == __envir__.transpiler_name\n\n\n# Imports for Transcrypt, resolved run time\nif __envir__.executor_name == __envir__.transpiler_name:\n\timport numscrypt as num\n\timport numscrypt.fft as fft\n\n# Imports for CPython, resolved compile time\n__pragma__ ('skip')\nimport numpy as num\nimport numpy.fft as fft\n__pragma__ ('noskip')\n\nfSample = 4096\ntTotal = 2\nfSin = 30\nfCos = 50\n\ndef getNow ():\t# Avoid operator overloading, which would result in the dysfunctional: __new__ __call__ (Date)\n\treturn __new__ (Date ())\n\ndef tCurrent (iCurrent):\n\treturn iCurrent / fSample\n\ndef run (autoTester):\n\tcut = 102\n\tautoTester.check ('Samples computed: {}<br>'.format (tTotal  * fSample))\n\tautoTester.check ('Samples shown: {}<br>'.format (cut))\n\n\torig = num.array ([\n\t\tcomplex (0.3 + sin (2 * pi * fSin * t) + 0.5 * cos (2 * pi * fCos * t), 0)\n\t\tfor t in [\n\t\t\tiSample / fSample\n\t\t\tfor iSample in range (tTotal * fSample)\n\t\t]\n\t], 'complex128')\n\t\n\t__pragma__ ('opov')\n\n\tdelta = 0.001 + 0.001j\n\tautoTester.check ('Original samples', num.round (orig + delta, 3) .tolist ()[ : cut], '<br>')\n\n\tif transpiled:\n\t\ttimeStartFft = getNow ()\n\tfreqs = fft.fft (orig)\n\tif transpiled:\n\t\ttimeStopFft = getNow ()\t\n\t\t\n\tautoTester.check ('Frequencies', num.round (freqs + delta, 3) .tolist ()[ : cut], '<br>')\n\t\n\tif transpiled:\n\t\ttimeStartIfft = getNow ()\t\n\treconstr = fft.ifft (freqs)\n\tif transpiled:\n\t\ttimeStopIfft = getNow ()\t\n\t\n\tautoTester.check ('Reconstructed samples', num.round (reconstr + delta, 3) .tolist ()[ : cut], '<br>')\n\t\n\t__pragma__ ('noopov')\n\t\t\n\tif transpiled:\n\t\tprint ('FFT for {} samples took {} ms'.format (tTotal * fSample, timeStopFft - timeStartFft))\n\t\tprint ('IFFT for {} samples took {} ms'.format (tTotal * fSample, timeStopIfft - timeStartIfft))\n",
		"from org.transcrypt.stubs.browser import *\nfrom org.transcrypt.stubs.browser import __main__, __envir__, __pragma__\n\n# Imports for Transcrypt, resolved run time\nif __envir__.executor_name == __envir__.transpiler_name:\n\timport numscrypt as num\n\timport numscrypt.linalg as linalg\n\n# Imports for CPython, resolved compile time\n__pragma__ ('skip')\nimport numpy as num\nimport numpy.linalg as linalg\n__pragma__ ('noskip')\n\ndef run (autoTester):\n\n\t# Real\n\n\tr = num.array ([\n\t\t[2.12, -2.11, -1.23], \n\t\t[2.31, 1.14, 3.15], \n\t\t[1.13, 1.98, 2.81]\n\t])\n\t\n\tautoTester.check ('Matrix r', num.round (r, 2) .tolist (), '<br>')\n\t\n\tri = linalg.inv (r)\n\t\n\tautoTester.check ('Matrix ri', num.round (ri, 2) .tolist (), '<br>')\n\t\n\t__pragma__ ('opov')\n\trid = r @ ri\n\t__pragma__ ('noopov')\n\t\n\tautoTester.check ('r @ ri', [[int (round (elem)) for elem in row] for row in rid.tolist ()], '<br>')\n\t\n\t__pragma__ ('opov')\n\tdelta = 0.001\n\tautoTester.check ('r * r', num.round (r * r + delta, 3) .tolist (), '<br>')\n\tautoTester.check ('r / r', num.round (r / r + delta, 3) .tolist (), '<br>')\n\tautoTester.check ('r + r', num.round (r + r + delta, 3) .tolist (), '<br>')\n\tautoTester.check ('r - r', num.round (r - r + delta, 3) .tolist (), '<br>')\n\t__pragma__ ('noopov')\n\n\t# Complex\n\t\n\t__pragma__ ('opov')\n\tc = num.array ([\n\t\t[2.12 - 3.15j, -2.11, -1.23], \n\t\t[2.31, 1.14, 3.15 + 2.75j], \n\t\t[1.13, 1.98 - 4.33j, 2.81]\n\t], 'complex128')\n\t__pragma__ ('noopov')\n\t\n\tautoTester.check ('Matrix c',  num.round (c, 2) .tolist (), '<br>')\n\t\n\tci = linalg.inv (c)\n\t\n\tautoTester.check ('Matrix ci', num.round (ci, 2) .tolist (), '<br>')\n\t\n\t__pragma__ ('opov')\n\tcid = c @ ci\n\t__pragma__ ('noopov')\n\t\n\t# autoTester.check ('c @ ci', [['{} + j{}'.format (int (round (elem.real)), int (round (elem.imag))) for elem in row] for row in cid.tolist ()], '<br>')\n\t\n\t__pragma__ ('opov')\n\tdelta = 0.001 + 0.001j\n\tautoTester.check ('c * c', num.round (c * c + delta , 3) .tolist (), '<br>')\n\tautoTester.check ('c / c', num.round (c / c + delta, 3) .tolist (), '<br>')\n\tautoTester.check ('c + c', num.round (c + c + delta, 3) .tolist (), '<br>')\n\tautoTester.check ('c - c', num.round (c - c + delta, 3) .tolist (), '<br>')\n\t__pragma__ ('noopov')",
		"# For performance reasons, real arrays or scalars and complex arrays can only be mixed in a limited way\n# In general real arrays in natural order are fastest\n# Real arrays in non-natural order are slower\n# Complex arrays are slowest\n\nfrom org.transcrypt.stubs.browser import __pragma__\n\t\n__pragma__ ('skip')\nInt32Array = Float32Array = Float64Array = Array = 0\n__pragma__ ('noskip')\n\t\nimport itertools\n\nclass ns_settings:\n\toptim_space = False\n\nns_ctors = {\n\t'int32': Int32Array,\n\t'float32': Float32Array,\n\t'float64': Float64Array,\n\t'complex64': Float32Array,\n\t'complex128': Float64Array\n}\n\ndef ns_complex (dtype):\n\treturn dtype in ('complex64', 'complex128')\n\ndef ns_buftype (dtype):\n\treturn (\n\t\t\t'float32'\n\t\tif dtype == 'complex64' else\n\t\t\t'float64'\n\t\tif dtype == 'complex128' else\n\t\t\tdtype\n\t)\n\ndef ns_createbuf (imag, dtype, size):\n\t\treturn (\n\t\t\t\t__new__ (ns_ctors [ns_buftype (dtype)] (size))\n\t\t\tif not imag or ns_complex (dtype) else\n\t\t\t\tNone\n\t\t)\n\t\t\nclass ndarray:\n\tdef __init__ (\n\t\tself,\n\t\tshape,\n\t\tdtype,\n\t\t\n\t\t# Any fully constructed real array instance will have realbuf != None, imagbuf == None\n\t\t# Any fully constructed complex array instance will have realbuf != None, imagbuf != None\n\t\trealbuf = None,\n\t\timagbuf = None\n\t):\n\t\tself.dtype = dtype\n\t\tself.ns_complex = ns_complex (dtype)\n\t\t\n\t\tself.realbuf = realbuf\n\t\tif self.ns_complex:\n\t\t\tself.imagbuf = imagbuf\n\t\t\t\n\t\tself.setshape (shape)\n\t\t\n\tdef setshape (self, shape):\n\t\tself.shape = shape\n\t\tself.ndim = shape.length\n\t\tself.ns_nrows = shape [0]\n\t\t\n\t\tif self.ndim == 1:\n\t\t\tself.size = self.ns_nrows\n\t\telse:\n\t\t\tself.ns_ncols = shape [1]\n\t\t\tself.size = self.ns_nrows * self.ns_ncols\n\t\t\n\tdef astype (self, dtype):\t# Do not use to convert between real and complex arrays\n\t\tresult = empty (self.shape, dtype)\n\t\t\n\t\tresult.realbuf.set (self.realbuf)\n\t\tif self.ns_complex:\n\t\t\tresult.imagbuf.set (self.imagbuf)\n\t\t\t\n\t\treturn result\n\t\t\t\t\t\t\n\tdef tolist (self):\n\t\tif self.ns_complex:\n\t\t\tflat = [complex (real, imag) for real, imag in zip (list (self.realbuf), list (self.imagbuf))]\n\t\telse:\n\t\t\tflat = self.realbuf\n\t\t\t\n\t\tif self.ndim == 1:\n\t\t\treturn list (flat)\n\t\telse:\n\t\t\treturn [[flat [self.ns_ncols * irow + icol] for icol in range (self.ns_ncols)] for irow in range (self.ns_nrows)]\n\t\t\t\t\t\n\tdef __repr__ (self):\n\t\treturn 'array({})'.format (repr (self.tolist ()))\n\n\tdef __str__ (self):\n\t\tif self.ndim == 1:\n\t\t\treturn str (self.tolist ())\n\t\telse:\n\t\t\treturn '[\\n\\t{}\\n]\\n'.format ('\\n\\t'.join ([str (row) for row in self.tolist ()]))\n\t\t\n\tdef reshape (self, shape):\n\t\tif self.ndim == 1:\n\t\t\treturn array (self, self.dtype),\n\t\telse:\n\t\t\tresult = array (self, self.dtype)\n\t\t\tresult.setshape (self.ns_ncols, self.ns_nrows)\n\t\t\treturn result\n\t\t\t\n\tdef transpose (self):\n\t\tif self.ndim == 1:\n\t\t\tresult = array (self, dtype)\n\t\telse:\n\t\t\tresult = empty ((self.ns_ncols, self.ns_nrows), self.dtype)\n\t\t\t\t\n\t\tif self.ns_complex:\t\n\t\t\tfor irow in range (self.ns_nrows):\n\t\t\t\tfor icol in range (self.ns_ncols):\n\t\t\t\t\titarget = result.ns_ncols * icol + irow\n\t\t\t\t\tresult.imagbuf [itarget] = self.imagbuf [isource]\n\t\t\t\t\tresult.realbuf [itarget] = self.realbuf [isource]\n\t\telse:\n\t\t\tfor irow in range (self.ns_nrows):\n\t\t\t\tfor icol in range (self.ns_ncols):\n\t\t\t\t\tresult.realbuf [result.ns_ncols * icol + irow] = self.realbuf [self.ns_ncols * irow + icol]\n\t\t\t\t\t\n\t\treturn result\n\t\t\t\t\n\tdef __getitem__ (self, key):\n\t\tif self.ndim == 1:\t\t\t\n\t\t\tif type (key) == tuple:\n\t\t\t\t# Slice of single dim array\n\n\t\t\t\tif key [1] == None:\n\t\t\t\t\tkey [1] = self.size\n\t\t\t\telif key [1] < 0:\n\t\t\t\t\tkey [1] += self.size\n\t\t\t\t\n\t\t\t\tresult = empty ([(key [1] - key [0]) / key [2]], self.dtype)\n\t\t\t\t\n\t\t\t\titarget = 0\n\t\t\t\tif self.ns_complex:\n\t\t\t\t\tfor isource in range (*self.shape):\n\t\t\t\t\t\tresult.realbuf [itarget] = self.realbuf [isource]\n\t\t\t\t\t\tresult.imagbuf [__postinc__ (itarget)] = self.realbuf [isource]\n\t\t\t\telse:\n\t\t\t\t\tfor isource in range (*self.shape):\n\t\t\t\t\t\tresult.realbuf [__postinc__ (itarget)] = self.realbuf [isource]\n\t\t\t\t\n\t\t\t\treturn result\n\t\t\telse:\n\t\t\t\t# Element of single dim array\n\t\t\t\n\t\t\t\tif self.ns_complex:\n\t\t\t\t\treturn complex (self.realbuf [key], self.imagbuf [key])\n\t\t\t\telse:\n\t\t\t\t\treturn self.realbuf [key]\n\t\telse:\n\t\t\trowkey = key [0]\n\t\t\tcolkey = key [1]\n\t\t\t\n\t\t\trowistup = type (rowkey) == tuple\n\t\t\tcolistup = type (colkey) == tuple\n\t\t\t\n\t\t\tif rowistup:\n\t\t\t\tif rowkey [1] == None:\n\t\t\t\t\trowkey [1] = self.ns_nrows\n\t\t\t\telif rowkey [1] < 0:\n\t\t\t\t\trowkey [1] += self.ns_nrows\n\t\t\t\t\t\n\t\t\tif colistup:\n\t\t\t\tif colkey [1] == None:\n\t\t\t\t\tcolkey [1] = self.ns_ncols\n\t\t\t\telif colkey [1] < 0:\n\t\t\t\t\tcolkey [1] += self.ns_ncols\n\t\t\t\n\t\t\tif rowistup or colistup:\n\t\t\t\t# Slice of multidim array\n\t\t\t\n\t\t\t\tif not rowistup:\n\t\t\t\t\tresult = empty (((colkey [1] - colkey [0]) / colkey [2], ), self.dtype)\n\t\t\t\t\t\n\t\t\t\t\titarget = 0\n\t\t\t\t\tif self.ns_complex:\n\t\t\t\t\t\tfor isourcecol in range (*colkey):\n\t\t\t\t\t\t\tisource = self.ns_ncols * rowkey + isourcecol\n\t\t\t\t\t\t\tresult.realbuf [itarget] = self.realbuf [isource]\n\t\t\t\t\t\t\tresult.imagbuf [__postinc__ (itarget)] = self.imagbuf [isource]\n\t\t\t\t\telse:\n\t\t\t\t\t\tfor isourcecol in range (*colkey):\n\t\t\t\t\t\t\tresult.realbuf [__postinc__ (itarget)] = self.realbuf [self.ns_ncols * rowkey + isourcecol]\n\t\t\t\telif not colistup:\n\t\t\t\t\tresult = empty (((rowkey [1] - rowkey [0]) / rowkey [2], ), self.dtype)\n\t\t\t\t\t\n\t\t\t\t\titarget = 0\n\t\t\t\t\tif self.ns_complex:\n\t\t\t\t\t\tfor isourcerow in range (*rowkey):\n\t\t\t\t\t\t\tisource = self.ns_ncols * isourcerow + colkey\n\t\t\t\t\t\t\tresult.realbuf [itarget] = self.realbuf [isource]\n\t\t\t\t\t\t\tresult.imagbuf [__postinc__ (itarget)] = self.imagbuf [isource]\n\t\t\t\t\telse:\n\t\t\t\t\t\tfor isourcerow in range (*rowkey):\n\t\t\t\t\t\t\tresult.realbuf [__postinc__ (itarget)] = self.realbuf [self.ns_ncols * isourcerow + colkey]\n\t\t\t\telse:\n\t\t\t\t\tresult = empty ((\n\t\t\t\t\t\t(key[0][1] - key[0][0]) / key [0][2],\n\t\t\t\t\t\t(key[1][1] - key[1][0]) / key [1][2]\n\t\t\t\t\t), self.dtype)\n\t\t\t\t\t\t\t\t\n\t\t\t\t\titarget = 0\n\t\t\t\t\tif self.ns_complex:\n\t\t\t\t\t\tfor isourcerow in range (*rowkey):\n\t\t\t\t\t\t\tfor isourcecol in range (*colkey):\n\t\t\t\t\t\t\t\tisource = self.ns_ncols * isourcerow + isourcecol\n\t\t\t\t\t\t\t\tresult.realbuf [itarget] = self.realbuf [isource]\n\t\t\t\t\t\t\t\tresult.imagbuf [__postinc__ (itarget)] = self.imagbuf [isource]\t\t\t\t\t\t\t\n\n\t\t\t\t\telse:\n\t\t\t\t\t\tfor isourcerow in range (*rowkey):\n\t\t\t\t\t\t\tfor isourcecol in range (*colkey):\n\t\t\t\t\t\t\t\tresult.realbuf [__postinc__ (itarget)] = self.realbuf [self.ns_ncols * isourcerow + isourcecol]\n\t\t\t\t\t\t\t\n\t\t\t\treturn result\n\t\t\telse:\n\t\t\t\t# Element of multi dim array\n\t\t\t\n\t\t\t\tif self.ns_complex:\n\t\t\t\t\tisource = self.ns_ncols * key [0] + key [1]\n\t\t\t\t\treturn complex (self.realbuf [isource], self.imagbuf [isource])\n\t\t\t\telse:\n\t\t\t\t\treturn self.realbuf [self.ns_ncols * key [0] + key [1]]\n\t\t\t\t\t\n\tdef __setitem__ (self, key, value):\n\t\tif self.ndim == 1:\t\t\n\t\t\tif type (key) == tuple:\n\t\t\t\t# Slice of single dim array\n\t\t\t\t\n\t\t\t\tif key [1] == None:\n\t\t\t\t\tkey [1] = self.size\n\t\t\t\telif key [1] < 0:\n\t\t\t\t\tkey [1] += self.size\n\t\t\t\t\n\t\t\t\tisource = 0\n\t\t\t\tif self.ns_complex:\n\t\t\t\t\tfor itarget in range (*self.shape):\n\t\t\t\t\t\tself.realbuf [itarget] = value.realbuf [isource]\n\t\t\t\t\t\tself.imagbuf [itarget] = value.realbuf [__postinc__ (isource)]\n\t\t\t\telse:\n\t\t\t\t\tfor itarget in range (*self.shape):\n\t\t\t\t\t\tself.realbuf [itarget] = value.realbuf [__postinc__ (isource)]\n\t\t\t\t\n\t\t\t\treturn result\n\t\t\telse:\n\t\t\t\t# Element of single dim array\n\t\t\t\t\n\t\t\t\tif self.ns_complex:\n\t\t\t\t\tself.realbuf [key] = value.real\n\t\t\t\t\tself.imagbuf [key] = value.imag\n\t\t\t\telse:\n\t\t\t\t\tself.realbuf [key] = value\n\t\telse:\n\t\t\trowkey = key [0]\n\t\t\tcolkey = key [1]\n\t\t\trowistup = type (rowkey) == tuple\n\t\t\tcolistup = type (colkey) == tuple\n\t\t\t\n\t\t\tif rowistup or colistup:\n\t\t\t\t# Slice of multi dim array\n\t\t\t\t\n\t\t\t\tif not rowistup:\t\t\t\n\t\t\t\t\tisource = 0\n\t\t\t\t\tif self.ns_complex:\n\t\t\t\t\t\tfor itargetcol in range (*colkey):\n\t\t\t\t\t\t\titarget = self.ns_ncols * rowkey + itargetcol\n\t\t\t\t\t\t\tself.realbuf [itarget] = value.realbuf [isource]\n\t\t\t\t\t\t\tself.imagbuf [itarget] = value.imagbuf [__postinc__ (isource)]\n\t\t\t\t\telse:\n\t\t\t\t\t\tfor itargetcol in range (*colkey):\n\t\t\t\t\t\t\tresult.realbuf [self.ns_ncols * rowkey + itargetcol] = self.realbuf [__postinc__ (isource)]\n\t\t\t\telif not colistup:\n\t\t\t\t\tresult = empty ([(rowkey [1] - rowkey [0]) / rowkey [2]], self.dtype)\n\t\t\t\t\t\n\t\t\t\t\tisource = 0\n\t\t\t\t\tif self.ns_complex:\n\t\t\t\t\t\tfor itargetrow in range (*rowkey):\n\t\t\t\t\t\t\titarget = self.ns_ncols * isourcerow + colkey\n\t\t\t\t\t\t\tself.realbuf [itarget] = value.realbuf [isource]\n\t\t\t\t\t\t\tself.imagbuf [itarget] = value.imagbuf [__postinc__ (isource)]\n\t\t\t\t\telse:\n\t\t\t\t\t\tfor isourcerow in range (*rowkey):\n\t\t\t\t\t\t\tself.realbuf [self.ns_ncols * isourcerow + colkey] = value [__postinc__ (isource)]\n\t\t\t\telse:\t\t\t\n\t\t\t\t\tisource = 0\n\t\t\t\t\tif self.ns_complex:\n\t\t\t\t\t\tfor itargetrow in range (*rowkey):\n\t\t\t\t\t\t\tfor itargetcol in range (*colkey):\n\t\t\t\t\t\t\t\titarget = self.ns_ncols * itargetrow + itargetcol\n\t\t\t\t\t\t\t\tself.realbuf [itarget] = value.realbuf [isource]\n\t\t\t\t\t\t\t\tself.imagbuf [itarget] = value.imagbuf [__postinc__ (isource)]\t\t\t\t\t\t\t\n\t\t\t\t\telse:\n\t\t\t\t\t\tfor isourcerow in range (*rowkey):\n\t\t\t\t\t\t\tfor isourcecol in range (*colkey):\n\t\t\t\t\t\t\t\tself.realbuf [self.ns_ncols * itargetrow + itargetcol] = value.realbuf [__postinc__ (isource)]\t\t\t\t\t\t\n\t\t\telse:\n\t\t\t\t# Element of multi dim array\n\t\t\t\t\n\t\t\t\tif self.ns_complex:\n\t\t\t\t\titarget = self.ns_ncols * key [0] + key [1]\n\t\t\t\t\tself.realbuf [itarget] = value.real\n\t\t\t\t\tself.imagbuf [itarget] = value.imag\n\t\t\t\telse:\n\t\t\t\t\tself.realbuf [self.ns_ncols * key [0] + key [1]] = value\n\t\t\t\t\t\n\tdef real (self):\t# Returns a view, so you can assign to self via it\n\t\treturn ndarray (self.shape, ns_buftype (self.dtype), self.realbuf)\n\t\n\tdef imag (self):\t# Returns a view, so you can assign self via it\n\t\treturn ndarray (self.shape, ns_buftype (self.dtype), self.imagbuf)\n\t\n\tdef __neg__ (self):\n\t\tresult = empty (self.shape, self.dtype)\n\t\tif self.ns_complex:\n\t\t\tfor i in range (self.size):\n\t\t\t\tresult.realbuf [i] = -self.realbuf [i]\n\t\t\t\tresult.imagbuf [i] = -self.imagbuf [i]\n\t\telse:\n\t\t\tfor i in range (self.size):\n\t\t\t\tresult.realbuf [i] = -self.realbuf [i]\n\t\t\t\n\t\treturn result\t\n\t\t\t\n\tdef __ns_inv__ (self):\n\t\tresult = empty (self.shape, self.dtype)\n\t\t\t\n\t\tif self.ns_complex:\n\t\t\tfor i in range (self.size):\n\t\t\t\treal = self.realbuf [i]\n\t\t\t\timag = self.imagbuf [i]\n\t\t\t\tdenom = real * real + imag * imag\n\t\t\t\t\n\t\t\t\tresult.realbuf [i] = real / denom\n\t\t\t\tresult.imagbuf [i] = -imag / denom\n\t\telse:\n\t\t\tfor i in range (self.size):\n\t\t\t\tresult.realbuf [i] = 1 / self.realbuf [i]\n\t\t\t\n\t\treturn result\t\n\t\t\t\n\tdef __add__ (self, other):\n\t\tresult = empty (self.shape, self.dtype)\n\t\t\n\t\tif type (other) == ndarray:\n\t\t\tif self.ns_complex:\n\t\t\t\tfor i in range (self.size):\n\t\t\t\t\tresult.realbuf [i] = self.realbuf [i] + other.realbuf [i]\n\t\t\t\t\tresult.imagbuf [i] = self.imagbuf [i] + other.imagbuf [i]\n\t\t\telse:\n\t\t\t\tfor i in range (self.size):\n\t\t\t\t\tresult.realbuf [i] = self.realbuf [i] + other.realbuf [i]\n\t\telse:\n\t\t\tif self.ns_complex:\n\t\t\t\tfor i in range (self.size):\n\t\t\t\t\tresult.realbuf [i] = self.realbuf [i] + other.real\n\t\t\t\t\tresult.imagbuf [i] = self.imagbuf [i] + other.imag\n\t\t\telse:\n\t\t\t\tfor i in range (self.size):\n\t\t\t\t\tresult.realbuf [i] = self.realbuf [i] + other\n\t\t\t\t\t\n\t\treturn result\n\t\t\n\tdef __radd__ (self, scalar):\t# scalar + array -> array.__radd__ (scalar)\n\t\treturn self.__add__ (scalar)\n\t\t\n\tdef __sub__ (self, other):\n\t\tresult = empty (self.shape, self.dtype)\n\t\t\n\t\tif type (other) == ndarray:\n\t\t\tif self.ns_complex:\n\t\t\t\tfor i in range (self.size):\n\t\t\t\t\tresult.realbuf [i] = self.realbuf [i] - other.realbuf [i]\n\t\t\t\t\tresult.imagbuf [i] = self.imagbuf [i] - other.imagbuf [i]\n\t\t\telse:\n\t\t\t\tfor i in range (self.size):\n\t\t\t\t\tresult.realbuf [i] = self.realbuf [i] - other.realbuf [i]\n\t\telse:\n\t\t\tif self.ns_complex:\n\t\t\t\tfor i in range (self.size):\n\t\t\t\t\tresult.realbuf [i] = self.realbuf [i] - other.real\n\t\t\t\t\tresult.imagbuf [i] = self.imagbuf [i] - other.imag\n\t\t\telse:\n\t\t\t\tfor i in range (self.size):\n\t\t\t\t\tresult.realbuf [i] = self.realbuf [i] - other\n\t\t\t\t\t\n\t\treturn result\n\t\t\n\tdef __rsub__ (self, scalar):\t# scalar - array -> array.__rsub__ (scalar)\n\t\treturn self.__neg__ () .__add__ (scalar)\n\t\t\n\tdef __mul__ (self, other):\n\t\tresult = empty (self.shape, self.dtype)\n\t\t\n\t\tif type (other) == ndarray:\n\t\t\tif self.ns_complex:\n\t\t\t\tfor i in range (self.size):\n\t\t\t\t\tresult.realbuf [i] = self.realbuf [i] * other.realbuf [i] - self.imagbuf [i] * other.imagbuf [i]\n\t\t\t\t\tresult.imagbuf [i] = self.realbuf [i] * other.imagbuf [i] + self.imagbuf [i] * other.realbuf [i]\n\t\t\telse:\n\t\t\t\tfor i in range (self.size):\n\t\t\t\t\tresult.realbuf [i] = self.realbuf [i] * other.realbuf [i]\n\t\telse:\n\t\t\tif self.ns_complex:\n\t\t\t\tfor i in range (self.size):\n\t\t\t\t\tresult.realbuf [i] = self.realbuf [i] * other.real - self.imagbuf [i] * other.imag\n\t\t\t\t\tresult.imagbuf [i] = self.realbuf [i] * other.imag + self.imagbuf [i] * other.real\n\t\t\telse:\n\t\t\t\tfor i in range (self.size):\n\t\t\t\t\tresult.realbuf [i] = self.realbuf [i] * other\n\t\t\t\t\t\n\t\treturn result\n\t\t\n\tdef __rmul__ (self, scalar):\t# scalar * array -> array.__rmul__ (scalar)\n\t\treturn self.__mul__ (scalar)\n\t\t\n\tdef __div__ (self, other):\n\t\tresult = empty (self.shape, self.dtype)\n\t\t\n\t\tif type (other) == ndarray:\n\t\t\tif self.ns_complex:\n\t\t\t\tfor i in range (self.size):\n\t\t\t\t\treal = other.realbuf [i]\n\t\t\t\t\timag = other.imagbuf [i]\n\t\t\t\t\tdenom = real * real + imag * imag\n\t\t\t\t\n\t\t\t\t\tresult.realbuf [i] = (self.realbuf [i] * real + self.imagbuf [i] * imag) / denom\n\t\t\t\t\tresult.imagbuf [i] = (self.imagbuf [i] * real - self.realbuf [i] * imag) / denom\n\t\t\telse:\n\t\t\t\tfor i in range (self.size):\n\t\t\t\t\tresult.realbuf [i] = self.realbuf [i] / other.realbuf [i]\n\t\telse:\n\t\t\tif self.ns_complex:\n\t\t\t\treal = other.real\n\t\t\t\timag = other.imag\n\t\t\t\tdenom = real * real + imag * imag\n\t\t\t\t\n\t\t\t\tfor i in range (self.size):\n\t\t\t\t\tresult.realbuf [i] = (self.realbuf [i] * real + self.imagbuf [i] * imag) / denom\n\t\t\t\t\tresult.imagbuf [i] = (self.imagbuf [i] * real - self.realbuf [i] * imag) / denom\n\t\t\telse:\n\t\t\t\tfor i in range (self.size):\n\t\t\t\t\tresult.realbuf [i] = self.realbuf [i] / other\n\t\t\t\t\t\n\t\treturn result\n\t\t\n\tdef __rdiv__ (self, scalar):\t# scalar / array -> array.__rdiv__ (scalar)\n\t\treturn self.__ns_inv__ () .__mul__ (scalar)\n\t\t\n\tdef __matmul__ (self, other):\n\t\tresult = empty ((self.ns_nrows, other.ns_ncols), self.dtype)\n\t\t\n\t\tif self.ns_complex:\n\t\t\tiresult = 0\n\t\t\tfor irow in range (self.ns_nrows):\n\t\t\t\tfor icol in range (other.ns_ncols):\n\t\t\t\t\tresult.realbuf [iresult] = 0\n\t\t\t\t\tresult.imagbuf [iresult] = 0\n\t\t\t\t\tiself = self.ns_ncols * irow\n\t\t\t\t\tiother = icol\n\t\t\t\t\tfor iterm in range (self.ns_ncols):\n\t\t\t\t\t\tresult.realbuf [iresult] += self.realbuf [iself] * other.realbuf [iother] - self.imagbuf [iself] * other.imagbuf [iother]\n\t\t\t\t\t\tresult.imagbuf [iresult] += self.realbuf [iself] * other.imagbuf [iother] + self.imagbuf [__postinc__ (iself)] * other.realbuf [iother]\n\t\t\t\t\t\tiother += other.ns_ncols\n\t\t\t\t\tiresult += 1\n\t\telse:\n\t\t\tiresult = 0\n\t\t\tfor irow in range (self.ns_nrows):\n\t\t\t\tfor icol in range (other.ns_ncols):\n\t\t\t\t\tresult.realbuf [iresult] = 0\n\t\t\t\t\tiself = self.ns_ncols * irow\n\t\t\t\t\tiother = icol\n\t\t\t\t\tfor iterm in range (self.ns_ncols):\n\t\t\t\t\t\tresult.realbuf [iresult] += self.realbuf [__postinc__ (iself)] * other.realbuf [iother]\n\t\t\t\t\t\tiother += other.ns_ncols\n\t\t\t\t\tiresult += 1\n\t\t\t\n\t\treturn result\n\t\t\ndef empty (shape, dtype = 'float64'):\n\tresult = ndarray (\n\t\tshape,\n\t\tdtype\n\t)\n\tresult.realbuf = ns_createbuf (False, dtype, result.size)\n\tresult.imagbuf = ns_createbuf (True, dtype, result.size)\n\treturn result\n\t\ndef array (obj, dtype = 'float64'):\t\n\tif Array.isArray (obj):\n\t\tif len (obj):\n\t\t\tif Array.isArray (obj [0]):\n\t\t\t\tresult = empty ((obj.length, obj [0] .length), dtype)\n\t\t\t\tiresult = 0\n\t\t\t\tif result.ns_complex:\n\t\t\t\t\tfor irow in range (result.ns_nrows):\n\t\t\t\t\t\tfor icol in range (result.ns_ncols):\n\t\t\t\t\t\t\telement = complex (obj [irow][icol])\n\t\t\t\t\t\t\tresult.realbuf [iresult] = element.real\n\t\t\t\t\t\t\tresult.imagbuf [__postinc__ (iresult)] = element.imag\n\t\t\t\telse:\n\t\t\t\t\tfor irow in range (result.ns_nrows):\n\t\t\t\t\t\tfor icol in range (result.ns_ncols):\n\t\t\t\t\t\t\tresult.realbuf [__postinc__ (iresult)] = obj [irow][icol]\n\t\t\telse:\n\t\t\t\tresult = empty ((obj.length, ), dtype)\n\t\t\t\tif result.ns_complex:\n\t\t\t\t\tfor i in range (result.size):\n\t\t\t\t\t\telement = complex (obj [i])\n\t\t\t\t\t\tresult.realbuf [i] = element.real \n\t\t\t\t\t\tresult.imagbuf [i] = element.imag\n\t\t\t\telse:\n\t\t\t\t\tfor i in range (result.size):\n\t\t\t\t\t\tresult.realbuf [i] = obj [i]\n\t\telse:\n\t\t\tresult = empty ((0, ), dtype)\n\telse:\t# Assume obj is an ndarray\n\t\tresult = empty (obj.shape, dtype)\n\t\t\n\t\tresult.realbuf.set (obj.realbuf)\n\t\tif obj.ns_complex:\n\t\t\tresult.imagbuf.set (obj.imagbuf)\n\t\t\t\n\treturn result\n\t\t\ndef copy (obj):\n\treturn array (obj, obj.dtype)\n\t\ndef hsplit (ary, nparts):\n\tresult = [empty ((ary.ns_nrows, ary.ns_ncols / nparts), ary.dtype) for ipart in range (nparts)]\n\t\n\tisource = 0\n\tif ary.ns_complex:\n\t\tfor irow in range (ary.ns_nrows):\n\t\t\tfor part in result:\n\t\t\t\titarget = part.ns_ncols * irow\n\t\t\t\tfor icol in range (part.ns_ncols):\n\t\t\t\t\tpart.realbuf [itarget] = ary.realbuf [isource]\n\t\t\t\t\tpart.imagbuf [__postinc__ (itarget)] = ary.imagbuf [__postinc__ (isource)]\n\telse:\n\t\tfor irow in range (ary.ns_nrows):\n\t\t\tfor part in result:\n\t\t\t\titarget = part.ns_ncols * irow\n\t\t\t\tfor icol in range (part.ns_ncols):\n\t\t\t\t\tpart.realbuf [__postinc__ (itarget)] = ary.realbuf [__postinc__ (isource)]\n\t\t\t\t\t\n\treturn result\n\t\ndef vsplit (ary, nparts):\n\tresult = [empty ((ary.ns_nrows / nparts, ary.ns_ncols), array.dtype) for ipart in range (nparts)]\n\n\tisource = 0\n\tif ary.ns_complex:\n\t\tfor part in result:\n\t\t\tfor itarget in range (part.size):\n\t\t\t\tpart.realbuf [itarget] = ary.realbuf [isource]\n\t\t\t\tpart.imagbuf [itarget] = ary.imagbuf [__postinc__ (isource)]\n\telse:\n\t\tfor part in result:\n\t\t\tfor itarget in range (part.size):\n\t\t\t\tpart.realbuf [itarget] = ary.realbuf [__postinc__ (isource)]\n\t\t\t\t\t\n\treturn result\n\t\ndef hstack (tup):\n\tncols = 0\n\tfor part in tup:\n\t\tncols += part.ns_ncols\n\t\t\t\t\n\tresult = empty ((tup [0] .ns_nrows, ncols), tup [0] .dtype)\n\t\n\titarget = 0\n\tif result.ns_complex:\n\t\tfor irow in range (result.ns_nrows):\n\t\t\tfor part in tup:\n\t\t\t\tisource = part.ns_ncols * irow\n\t\t\t\tfor icol in range (part.ns_ncols):\n\t\t\t\t\tresult.realbuf [itarget] = part.realbuf [isource]\n\t\t\t\t\tresult.imagbuf [__postinc__ (itarget)] = part.imagbuf [__postinc__ (isource)]\n\telse:\n\t\tfor irow in range (result.ns_nrows):\n\t\t\tfor part in tup:\n\t\t\t\tisource = part.ns_ncols * irow\n\t\t\t\tfor icol in range (part.ns_ncols):\n\t\t\t\t\tresult.realbuf [__postinc__ (itarget)] = part.realbuf [__postinc__ (isource)]\n\t\t\t\t\n\treturn result\n\t\ndef vstack (tup):\n\tnrows = 0\n\tfor part in tup:\n\t\tnrows += part.ns_nrows\n\t\t\n\tresult = empty ((nrows, tup [0].ns_ncols), tup [0] .dtype)\n\t\n\titarget = 0\n\tif result.ns_complex:\n\t\tfor part in tup:\n\t\t\tfor isource in range (part.size):\n\t\t\t\tresult.realbuf [itarget] = part.realbuf [isource]\n\t\t\t\tresult.imagbuf [__postinc__ (itarget)] = part.imagbuf [isource]\n\telse:\n\t\tfor part in tup:\n\t\t\tfor isource in range (part.size):\n\t\t\t\tresult.realbuf [__postinc__ (itarget)] = part.realbuf [isource]\n\t\t\t\t\n\treturn result\n\t\t\t\ndef round (a, decimals = 0):\t# Truncation rather than bankers rounding, for speed\n\tresult = empty (a.shape, a.dtype)\n\n\tif a.ns_complex:\n\t\tfor i in range (a.size):\n\t\t\tresult.realbuf [i] = a.realbuf [i] .toFixed (decimals)\n\t\t\tresult.imagbuf [i] = a.imagbuf [i] .toFixed (decimals)\n\telse:\n\t\tfor i in range (a.size):\n\t\t\tresult.realbuf [i] = a.realbuf [i] .toFixed (decimals)\n\t\t\n\treturn result\n\t\t\ndef zeros (shape, dtype = 'float64'):\n\tresult = empty (shape, dtype)\n\n\tif result.ns_complex:\n\t\tfor i in range (result.size):\n\t\t\tresult.realbuf [i] = 0\n\t\t\tresult.imagbuf [i] = 0\n\telse:\n\t\tfor i in range (result.size):\n\t\t\tresult.realbuf [i] = 0\n\t\t\t\n\treturn result\n\t\ndef ones (shape, dtype = 'float64'):\n\tresult = empty (shape, dtype)\n\t\n\tif result.ns_complex:\n\t\tfor i in range (result.size):\n\t\t\tresult.realbuf [i] = 1\n\t\t\tresult.imagbuf [i] = 0\n\telse:\n\t\tfor i in range (result.size):\n\t\t\tresult.realbuf [i] = 1\n\t\t\t\n\treturn result\n\t\ndef identity (n, dtype = 'float64'):\n\tresult = zeros ((n, n), dtype)\n\t\n\ti = 0\n\tshift = n + 1\n\tfor j in range (n):\n\t\tresult.realbuf [i] = 1\n\t\ti += shift\n\t\n\treturn result\n\t",
		"__pragma__ ('noanno')\n\nimport numscrypt as ns\n\n__pragma__ ('js', '{}', __include__ ('numscrypt/fft/__javascript__/fft_nayuki_precalc_fixed.js') .replace ('// \"use strict\";', ''))\n\ndef fft (a):\n\tfftn = __new__ (FFTNayuki (a.size))\n\tresult = ns.copy (a)\n\tr = result.real ()\n\ti = result.imag ()\n\t__pragma__ ('opov')\n\t\n\tprint (111, r.tolist () [0:10])\n\tprint (222, i.tolist () [0:10])\n\tconsole.dir (r)\n\tconsole.dir (i)\n\tfftn.forward (r, i)\n\tprint (333, r.tolist () [0:10])\n\tprint (444, i.tolist () [0:10])\n\n\t__pragma__ ('noopov')\n\treturn result\n\ndef ifft (a):\n\tfftn = __new__ (FFTNayuki (a.size))\n\tresult = ns.copy (a)\n\treal = result.real () #.__div__ (a.size)\n\timag = result.imag () #.__div__ (a.size)\n\tfftn.inverse (real, imag)\n\treturn result\n\t\n'''\ndef fft2 (a):\n\tif a.ns_natural:\n\t\tdre = a.real () .data\n\t\tdim = a.imag () .data\n\telse:\t\t\t\t\t\t\t\t\t# Force natural order\n\t\tdre = hstack ([a.real ()]) .data\n\t\tdim = hstack ([a.imag ()]) .data\n\tfor irow in a.shape [0]:\n\t\t# fft (row)\n\t# Transpose? Natural order?\n\ndef ifft2 (a):\n\t# !!! Assure natural order\n'''",
		"import numscrypt as ns\n\ndef inv (a):\n\t# Work directly with flat data atoms in natural order speeds up by factor 70 (!)\n\tif a.ns_complex:\n\t\treturn cinv (a)\n\telse:\n\t\treturn rinv (a)\n\ndef rinv (a):\n\t# Leave original matrix intact\n\tb = ns.hstack ((a, ns.identity (a.shape [0], a.dtype)))\t# b will always have natural order\n\treal = b.realbuf\n\tnrows, ncols = b.shape\n\t\n\t# Use each row of the matrix as pivot row\\n\n\tfor ipiv in range (nrows):\n\n\t\t# Swap rows if needed to get a nonzero pivot\n\t\tif not real [ipiv * ncols + ipiv]:\n\t\t\tfor irow in range (ipiv + 1, nrows):\n\t\t\t\tif real [irow * ncols + ipiv]:\n\t\t\t\t\tfor icol in range (ncols):\n\t\t\t\t\t\tt = real [irow * ncols + icol]\n\t\t\t\t\t\treal [irow * ncols + icol] = b [ipiv * ncols + icol]\n\t\t\t\t\t\treal [ipiv * ncols + icol] = t\n\t\t\t\t\tbreak\n\t\t\t\t\t\t\t\t\n\t\t# Make pivot element 1\n\t\tpiv = real [ipiv * ncols + ipiv]\n\t\tfor icol in range (ipiv, ncols):\n\t\t\treal [ipiv * ncols + icol] /= piv\n\t\t\t\n\t\t# Sweep other rows to get all zeroes in pivot column\n\t\tfor irow in range (nrows):\n\t\t\tif irow != ipiv:\n\t\t\t\tfactor = real [irow * ncols + ipiv]\n\t\t\t\tfor icol in range (ncols):\n\t\t\t\t\treal [irow * ncols + icol] -= factor * real [ipiv * ncols + icol]\n\t\t\t\t\t\n\t# Chop of left matrix, return right matrix\n\treturn ns.hsplit (b, 2)[1]\n\t\ndef cinv (a):\t# for speed, don't use 'complex' or operator overloading\n\t# Leave original matrix intact\n\tb = ns.hstack ((a, ns.identity (a.shape [0], a.dtype)))\t# b will always have natural order\n\t\n\treal = b.realbuf\n\timag = b.imagbuf\n\tnrows, ncols = b.shape\n\t\n\t# Use each row of the matrix as pivot row\\n\n\tfor ipiv in range (nrows):\n\t\tipiv_flat = ipiv * ncols + ipiv\n\t\t\n\t\t# Swap rows if needed to get a nonzero pivot\n\t\tif not (real [ipiv_flat] or imag [ipiv_flat]):\n\t\t\tfor irow in range (ipiv + 1, nrows):\n\t\t\t\tiswap = irow * ncols + ipiv\n\t\t\t\tif real [iswap] or imag [iswap]:\n\t\t\t\t\tfor icol in range (ncols):\n\t\t\t\t\t\tisource = irow * ncols + icol\n\t\t\t\t\t\titarget = ipiv * ncols + icol\n\t\t\t\t\t\t\n\t\t\t\t\t\tt = real [isource]\n\t\t\t\t\t\treal [isource] = real [itarget]\n\t\t\t\t\t\treal [itarget] = t\n\t\t\t\t\t\t\n\t\t\t\t\t\tt = imag [isource_flat]\n\t\t\t\t\t\timag [isource] = imag [itarget]\n\t\t\t\t\t\timag [itarget] = t\n\t\t\t\t\tbreak\n\t\t\n\t\t# Make pivot element 1\n\t\tpivre = real [ipiv_flat]\n\t\tpivim = imag [ipiv_flat]\n\t\t\n\t\tdenom = pivre * pivre + pivim * pivim\n\t\t\n\t\tfor icol in range (ipiv, ncols):\n\t\t\ticur = ipiv * ncols + icol\n\t\t\t\n\t\t\toldre = real [icur]\n\t\t\toldim = imag [icur]\n\n\t\t\treal [icur] = (oldre * pivre + oldim * pivim) / denom\t\t\t\n\t\t\timag [icur] = (oldim * pivre - oldre * pivim) / denom\n\t\t\n\t\t# Sweep other rows to get all zeroes in pivot column\n\t\tfor irow in range (nrows):\n\t\t\tif irow != ipiv: \n\t\t\t\tifac = irow * ncols + ipiv\n\t\t\t\tfacre = real [ifac]\n\t\t\t\tfacim = imag [ifac]\n\t\t\t\tfor icol in range (ncols):\n\t\t\t\t\titarget = irow * ncols + icol\n\t\t\t\t\tisource = ipiv * ncols + icol\n\t\t\t\t\t\n\t\t\t\t\toldre = real [isource]\n\t\t\t\t\toldim = imag [isource]\n\t\t\t\t\t\n\t\t\t\t\treal [itarget] -= (facre * oldre - facim * oldim)\n\t\t\t\t\timag [itarget] -= (facre * oldim + facim * oldre)\n\t\t\t\t\t\n\t# Chop of left matrix, return right matrix\n\treturn ns.hsplit (b, 2)[1]\n\t",
		"# First run a test from the command prompt, generating an HTML file.\n# The output of the test is stored in a DIV.\n# Also the script is automatically included in the HTML file.\n# Loading the HTML file will run the script.\n# This will compare the output of the script running in the browswer to the output in the DIV.\n# If those two match, the test reports OK, else it reports failure.\n\nfrom org.transcrypt.stubs.browser import *\nfrom org.transcrypt.stubs.browser import __main__, __envir__, __pragma__\n# Don't import __envir__ from __base__ since it will overwrite __buildin__.__envir__ in the browser\n# Import from stubs will be skipped in the browser\n# ... The ice is a bit thin here\n\n__pragma__ ('nokwargs')\n\nimport itertools\n\nokColor = 'green'\nerrorColor = 'red'\nhighlightColor = 'yellow'\ntestletNameColor = 'blue'\n\nclass AutoTester:\n\tdef __init__ (self, symbols = []):\n\t\tself.symbols = symbols\n\t\tself.referenceBuffer = []\n\t\tself.testBuffer = []\n\t\tself.messageDivId = 'message'\n\t\tself.referenceDivId = 'python'\n\t\tself.testDivId = 'transcrypt'\n\t\t\n\tdef sortedRepr (self, any):\t# When using sets or dicts, use elemens or keys of one type, in sort order\n\t\tdef tryGetNumKey (key):\n\t\t\tif type (key) == str:\t# Try to interpret key as numerical, see comment with repr function in __builtins__\n\t\t\t\ttry:\n\t\t\t\t\treturn int (key)\n\t\t\t\texcept:\n\t\t\t\t\ttry:\n\t\t\t\t\t\treturn float (key)\n\t\t\t\t\texcept:\n\t\t\t\t\t\treturn key\n\t\t\telse:\n\t\t\t\treturn key\n\t\t\t\t\n\t\tif type (any) == dict:\n\t\t\treturn '{' + ', '.join ([\n\t\t\t\t'{}: {}'.format (repr (key), repr (any [key]))\n\t\t\t\tfor index, key in enumerate (sorted ([tryGetNumKey (key) for key in any.keys ()], key = lambda aKey: str (aKey)))\n\t\t\t]) + '}'\n\t\telif type (any) == set:\n\t\t\tif len (any):\n\t\t\t\treturn '{' + ', '.join (sorted ([str (item) for item in list (any)])) + '}'\n\t\t\telse:\n\t\t\t\treturn repr (any)\n\t\telif type (any) == range:\n\t\t\treturn repr (list (any))\n\t\telse:\n\t\t\treturn repr (any)\n\t\t\t\n\tdef check (self, *args):\n\t\titem = ' '.join ([self.sortedRepr (arg) for arg in args])\t# N.B. stubs.browser provides a special sorting repr\n\t\tif __envir__.executor_name == __envir__.transpiler_name:\n\t\t\tself.testBuffer.append (item)\n\t\telse:\n\t\t\tself.referenceBuffer.append (item)\n\t\t\n\tdef dump (self, filePrename):\n\t\tfor minified in (False, True):\n\t\t\tminiInfix = '.min' if minified else ''\n\t\t\twith open ('{}{}.html'.format (filePrename, miniInfix), 'w') as aFile:\t\t\t\n\t\t\t\taFile.write ('<b>Status:</b>\\n')\n\t\t\t\taFile.write ('<div id=\"{}\"></div><br><br>\\n\\n'.format (self.messageDivId))\n\t\t\t\t\n\t\t\t\taFile.write ('<b>CPython output:</b>\\n')\n\t\t\t\taFile.write ('<div id=\"{}\">{}</div><br><br>\\n\\n'.format (self.referenceDivId, ' | '.join (self.referenceBuffer)))\n\t\t\t\t\n\t\t\t\taFile.write ('<b>Transcrypt output:</b>\\n')\n\t\t\t\taFile.write ('<div id=\"{}\"></div>\\n\\n'.format (self.testDivId))\n\n\t\t\t\taFile.write ('<script src=\"{}/{}{}.js\"></script>\\n\\n'.format (__envir__.target_subdir, filePrename, miniInfix))\n\t\t\t\t\n\tdef compare (self):\n\t\tself.referenceBuffer = document.getElementById (self.referenceDivId) .innerHTML.split (' | ')\n\t\tfor index, (testItem, referenceItem) in enumerate (zip (self.testBuffer, self.referenceBuffer)):\n\t\t\tif testItem != referenceItem:\n\t\t\t\tdocument.getElementById (self.messageDivId) .innerHTML = '<div style=\"color: {}\"><b>Test failed</b></div>'.format (errorColor)\n\t\t\t\tfor buffer, divId, accentColor in ((self.referenceBuffer, self.referenceDivId, okColor), (self.testBuffer, self.testDivId, errorColor)):\n\t\t\t\t\tbuffer = itertools.chain (buffer [ : index], [\n\t\t\t\t\t\t'<div style=\"display: inline; color: {}; background-color: {}\">!!!<b><i>{}</i></b></div>'.format (accentColor, highlightColor, buffer [index])\n\t\t\t\t\t], buffer [index + 1 : ])\n\t\t\t\t\tdocument.getElementById (divId) .innerHTML = ' | '.join (buffer)\n\t\t\t\tbreak\n\t\telse:\t\t\n\t\t\tdocument.getElementById (self.messageDivId) .innerHTML = '<div style=\"color: {}\">Test succeeded</div>'.format (okColor)\n\t\t\tdocument.getElementById (self.testDivId) .innerHTML = ' | '.join (self.testBuffer)\n\t\t\t\n\tdef run (self, testlet, testletName):\n\t\tself.check ('<div style=\"display: inline; color: {}\"> --- Testlet: {} --- </div><br>'.format (testletNameColor, testletName))\n\t\ttestlet.run (self)\n\t\tself.check ('<br><br>')\n\t\t\t\n\tdef done (self):\n\t\tif __envir__.executor_name == __envir__.transpiler_name:\n\t\t\tself.compare ()\n\t\telse:\n\t\t\tself.dump (__main__.__file__ [ : -3] .replace ('\\\\', '/') .rsplit ('/', 1) [-1])\n",
		"import org.transcrypt.autotester\n\nimport basics\nimport module_linalg\nimport module_fft\n\nautoTester = org.transcrypt.autotester.AutoTester ()\n\nautoTester.run (basics, 'basics')\nautoTester.run (module_linalg, 'module_linalg')\nautoTester.run (module_fft, 'module_fft')\n\nautoTester.done ()\n"
	],
	"mappings": "AAAA;AAAA;AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ACVA;AAAA;AAAA;AAAA;AAAA;AAAA;AAWA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AAGA;AAAA;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAEA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AAEA;AACA;AAAA;AAKA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAKA;AACA;AACA;AAAA;AAKA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAAA;AAIA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AACA;AACA;AACA;AAEA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ACzLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACh2CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AACA;AAAA;AAOA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAIA;AAMA;AAEA;AAEA;AAMA;AAEA;AACA;AAEA;AAMA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAOA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAIA;AAKA;AAGA;AACA;AACA;AAIA;AACA;AAEA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AAGA;AAMA;AAEA;AACA;AAEA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AChPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjUA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ACrDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAEA;AAIA;AACA;AACA;AAAA;AAQA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AAAA;AACA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAFA;AADA;AAAA;AAAA;AAAA;AASA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAEA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAEA;AAIA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ACpEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AACA;AACA;AAAA;AAQA;AAIA;AAMA;AAEA;AAEA;AAGA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AACA;AAMA;AAOA;AAEA;AAEA;AAGA;AAMA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ACxEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAypBA;AA9oBA;AAEA;AAAA;AACA;AAEA;AAQA;AACA;AAAA;AAEA;AACA;AAAA;AAQA;AAEA;AAAA;AAKA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAUA;AACA;AAEA;AACA;AACA;AAAA;AAEA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AAEA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAEA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAEA;AACA;AACA;AAGA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAGA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAIA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAGA;AAGA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAKA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAIA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAGA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAIA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAEA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAEA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAIA;AACA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAGA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAGA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAEA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAEA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAEA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ACzpBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AC9BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;AAEA;AACA;AACA;AAAA;AAAA;AAGA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AACA;AAAA;AAAA;AAIA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAEA;AAEA;AAEA;AACA;AACA;AAAA;AAAA;AAGA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ACzGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAyGA;AA1FA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ACzGA;AAAA;AAYA;AAAA;AAAA;AAAA;AAZA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA"
}