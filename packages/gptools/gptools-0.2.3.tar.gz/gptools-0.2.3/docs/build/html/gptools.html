<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>gptools package &mdash; gptools 0.2 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="gptools 0.2 documentation" href="index.html" />
    <link rel="next" title="gptools.kernel package" href="gptools.kernel.html" />
    <link rel="prev" title="gptools: Gaussian process regression with support for arbitrary derivatives" href="index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="np-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="gptools.kernel.html" title="gptools.kernel package"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="index.html" title="gptools: Gaussian process regression with support for arbitrary derivatives"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">gptools 0.2 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="gptools-package">
<h1>gptools package<a class="headerlink" href="#gptools-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="subpackages">
<h2>Subpackages<a class="headerlink" href="#subpackages" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="gptools.kernel.html">gptools.kernel package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="gptools.kernel.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="gptools.kernel.html#module-gptools.kernel.core">gptools.kernel.core module</a></li>
<li class="toctree-l2"><a class="reference internal" href="gptools.kernel.html#module-gptools.kernel.gibbs">gptools.kernel.gibbs module</a></li>
<li class="toctree-l2"><a class="reference internal" href="gptools.kernel.html#module-gptools.kernel.matern">gptools.kernel.matern module</a></li>
<li class="toctree-l2"><a class="reference internal" href="gptools.kernel.html#module-gptools.kernel.noise">gptools.kernel.noise module</a></li>
<li class="toctree-l2"><a class="reference internal" href="gptools.kernel.html#module-gptools.kernel.rational_quadratic">gptools.kernel.rational_quadratic module</a></li>
<li class="toctree-l2"><a class="reference internal" href="gptools.kernel.html#module-gptools.kernel.squared_exponential">gptools.kernel.squared_exponential module</a></li>
<li class="toctree-l2"><a class="reference internal" href="gptools.kernel.html#module-gptools.kernel.warping">gptools.kernel.warping module</a></li>
<li class="toctree-l2"><a class="reference internal" href="gptools.kernel.html#module-gptools.kernel">Module contents</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-gptools.error_handling">
<span id="gptools-error-handling-module"></span><h2>gptools.error_handling module<a class="headerlink" href="#module-gptools.error_handling" title="Permalink to this headline">¶</a></h2>
<p>Contains exceptions specific to the <a class="reference internal" href="#module-gptools" title="gptools"><tt class="xref py py-mod docutils literal"><span class="pre">gptools</span></tt></a> package.</p>
<dl class="exception">
<dt id="gptools.error_handling.GPArgumentError">
<em class="property">exception </em><tt class="descclassname">gptools.error_handling.</tt><tt class="descname">GPArgumentError</tt><a class="reference internal" href="_modules/gptools/error_handling.html#GPArgumentError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.error_handling.GPArgumentError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">exceptions.Exception</span></tt></p>
<p>Exception class raised when an incorrect combination of keyword arguments is given.</p>
</dd></dl>

</div>
<div class="section" id="module-gptools.gaussian_process">
<span id="gptools-gaussian-process-module"></span><h2>gptools.gaussian_process module<a class="headerlink" href="#module-gptools.gaussian_process" title="Permalink to this headline">¶</a></h2>
<p>Provides the base <a class="reference internal" href="#gptools.gaussian_process.GaussianProcess" title="gptools.gaussian_process.GaussianProcess"><tt class="xref py py-class docutils literal"><span class="pre">GaussianProcess</span></tt></a> class.</p>
<dl class="class">
<dt id="gptools.gaussian_process.GaussianProcess">
<em class="property">class </em><tt class="descclassname">gptools.gaussian_process.</tt><tt class="descname">GaussianProcess</tt><big>(</big><em>k</em>, <em>noise_k=None</em>, <em>X=None</em>, <em>y=None</em>, <em>err_y=0</em>, <em>n=0</em>, <em>T=None</em>, <em>diag_factor=100.0</em>, <em>mu=None</em><big>)</big><a class="reference internal" href="_modules/gptools/gaussian_process.html#GaussianProcess"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.gaussian_process.GaussianProcess" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Gaussian process.</p>
<p>If called with one argument, an untrained Gaussian process is constructed
and data must be added with the <a class="reference internal" href="#gptools.gaussian_process.GaussianProcess.add_data" title="gptools.gaussian_process.GaussianProcess.add_data"><tt class="xref py py-meth docutils literal"><span class="pre">add_data()</span></tt></a> method. If called with
the optional keywords, the values given are used as the data. It is always
possible to add additional data with <a class="reference internal" href="#gptools.gaussian_process.GaussianProcess.add_data" title="gptools.gaussian_process.GaussianProcess.add_data"><tt class="xref py py-meth docutils literal"><span class="pre">add_data()</span></tt></a>.</p>
<p>Note that the attributes have no write protection, but you should always
add data with <a class="reference internal" href="#gptools.gaussian_process.GaussianProcess.add_data" title="gptools.gaussian_process.GaussianProcess.add_data"><tt class="xref py py-meth docutils literal"><span class="pre">add_data()</span></tt></a> to ensure internal consistency.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>k</strong> : <a class="reference internal" href="gptools.kernel.html#gptools.kernel.core.Kernel" title="gptools.kernel.core.Kernel"><tt class="xref py py-class docutils literal"><span class="pre">Kernel</span></tt></a> instance</p>
<blockquote>
<div><p>Kernel instance corresponding to the desired noise-free covariance
kernel of the Gaussian process. The noise is handled separately either
through specification of <cite>err_y</cite>, or in a separate kernel. This allows
noise-free predictions when needed.</p>
</div></blockquote>
<p><strong>noise_k</strong> : <a class="reference internal" href="gptools.kernel.html#gptools.kernel.core.Kernel" title="gptools.kernel.core.Kernel"><tt class="xref py py-class docutils literal"><span class="pre">Kernel</span></tt></a> instance</p>
<blockquote>
<div><p>Kernel instance corresponding to the noise portion of the desired
covariance kernel of the Gaussian process. Note that you DO NOT need to
specify this if the extent of the noise you want to represent is
contained in <cite>err_y</cite> (or if your data are noiseless). Default value is
None, which results in the <a class="reference internal" href="gptools.kernel.html#gptools.kernel.noise.ZeroKernel" title="gptools.kernel.noise.ZeroKernel"><tt class="xref py py-class docutils literal"><span class="pre">ZeroKernel</span></tt></a>
(noise specified elsewhere or not present).</p>
</div></blockquote>
<p><strong>diag_factor</strong> : float, optional</p>
<blockquote>
<div><p>Factor of <tt class="xref py py-attr docutils literal"><span class="pre">sys.float_info.epsilon</span></tt> which is added to the
diagonal of the total <cite>K</cite> matrix to improve the stability of the
Cholesky decomposition. If you are having issues, try increasing this by
a factor of 10 at a time. Default is 1e2.</p>
</div></blockquote>
<p><strong>mu</strong> : <a class="reference internal" href="#gptools.mean.MeanFunction" title="gptools.mean.MeanFunction"><tt class="xref py py-class docutils literal"><span class="pre">MeanFunction</span></tt></a> instance</p>
<blockquote>
<div><p>The mean function of the Gaussian process. Default is None (zero mean
prior).</p>
</div></blockquote>
<p><strong>NOTE</strong> :</p>
<blockquote>
<div><p>The following are all passed to <a class="reference internal" href="#gptools.gaussian_process.GaussianProcess.add_data" title="gptools.gaussian_process.GaussianProcess.add_data"><tt class="xref py py-meth docutils literal"><span class="pre">add_data()</span></tt></a>, refer to its
docstring.</p>
</div></blockquote>
<p><strong>X</strong> : array, (<cite>M</cite>, <cite>D</cite>), optional</p>
<blockquote>
<div><p><cite>M</cite> input values of dimension <cite>D</cite>. Default value is None (no data).</p>
</div></blockquote>
<p><strong>y</strong> : array, (<cite>M</cite>,), optional</p>
<blockquote>
<div><p><cite>M</cite> data target values. Default value is None (no data).</p>
</div></blockquote>
<p><strong>err_y</strong> : array, (<cite>M</cite>,), optional</p>
<blockquote>
<div><p>Error (given as standard deviation) in the <cite>M</cite> training target values.
Default value is 0 (noiseless observations).</p>
</div></blockquote>
<p><strong>n</strong> : array, (<cite>M</cite>, <cite>D</cite>) or scalar float, optional</p>
<blockquote>
<div><p>Non-negative integer values only. Degree of derivative for each target.
If <cite>n</cite> is a scalar it is taken to be the value for all points in <cite>y</cite>.
Otherwise, the length of n must equal the length of <cite>y</cite>. Default value
is 0 (observation of target value). If non-integer values are passed,
they will be silently rounded.</p>
</div></blockquote>
<p><strong>T</strong> : array, (<cite>M</cite>, <cite>N</cite>), optional</p>
<blockquote>
<div><p>Linear transformation to get from latent variables to data in the
argument <cite>y</cite>. When <cite>T</cite> is passed the argument <cite>y</cite> holds the transformed
quantities <cite>y=TY(X)</cite> where <cite>y</cite> are the observed values of the
transformed quantities, <cite>T</cite> is the transformation matrix and <cite>Y(X)</cite> is
the underlying (untransformed) values of the function to be fit that
enter into the transformation. When <cite>T</cite> is <cite>M</cite>-by-<cite>N</cite> and <cite>y</cite> has <cite>M</cite>
elements, <cite>X</cite> and <cite>n</cite> will both be <cite>N</cite>-by-<cite>D</cite>. Default is None (no
transformation).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>GPArgumentError</strong> :</p>
<blockquote>
<div><p>Gave <cite>X</cite> but not <cite>y</cite> (or vice versa).</p>
</div></blockquote>
<p><strong>ValueError</strong> :</p>
<blockquote class="last">
<div><p>Training data rejected by <a class="reference internal" href="#gptools.gaussian_process.GaussianProcess.add_data" title="gptools.gaussian_process.GaussianProcess.add_data"><tt class="xref py py-meth docutils literal"><span class="pre">add_data()</span></tt></a>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#gptools.gaussian_process.GaussianProcess.add_data" title="gptools.gaussian_process.GaussianProcess.add_data"><tt class="xref py py-obj docutils literal"><span class="pre">add_data</span></tt></a></dt>
<dd>Used to process <cite>X</cite>, <cite>y</cite>, <cite>err_y</cite> and to add data to the process.</dd>
</dl>
</div>
<p class="rubric">Attributes</p>
<table border="1" class="docutils">
<colgroup>
<col width="6%" />
<col width="23%" />
<col width="72%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>k</td>
<td><a class="reference internal" href="gptools.kernel.html#gptools.kernel.core.Kernel" title="gptools.kernel.core.Kernel"><tt class="xref py py-class docutils literal"><span class="pre">Kernel</span></tt></a> instance</td>
<td>The non-noise portion of the covariance kernel.</td>
</tr>
<tr class="row-even"><td>noise_k</td>
<td><a class="reference internal" href="gptools.kernel.html#gptools.kernel.core.Kernel" title="gptools.kernel.core.Kernel"><tt class="xref py py-class docutils literal"><span class="pre">Kernel</span></tt></a> instance</td>
<td>The noise portion of the covariance kernel.</td>
</tr>
<tr class="row-odd"><td>X</td>
<td>array, (<cite>M</cite>, <cite>D</cite>)</td>
<td>The <cite>M</cite> training input values, each of which is of dimension <cite>D</cite>.</td>
</tr>
<tr class="row-even"><td>y</td>
<td>array, (<cite>M</cite>,)</td>
<td>The <cite>M</cite> training target values.</td>
</tr>
<tr class="row-odd"><td>err_y</td>
<td>array, (<cite>M</cite>,)</td>
<td>The error in the <cite>M</cite> training input values.</td>
</tr>
<tr class="row-even"><td>n</td>
<td>array, (<cite>M</cite>, <cite>D</cite>)</td>
<td>The orders of derivatives that each of the <cite>M</cite> training points represent, indicating the order of derivative with respect to each of the <cite>D</cite> dimensions.</td>
</tr>
<tr class="row-odd"><td>T</td>
<td>array, (<cite>M</cite>, <cite>N</cite>)</td>
<td>The transformation matrix applied to the data. If this is not None, <cite>X</cite> and <cite>n</cite> will be <cite>N</cite>-by-<cite>D</cite>.</td>
</tr>
<tr class="row-even"><td>K_up_to_date</td>
<td>bool</td>
<td>True if no data have been added since the last time the internal state was updated with a call to <a class="reference internal" href="#gptools.gaussian_process.GaussianProcess.compute_K_L_alpha_ll" title="gptools.gaussian_process.GaussianProcess.compute_K_L_alpha_ll"><tt class="xref py py-meth docutils literal"><span class="pre">compute_K_L_alpha_ll()</span></tt></a>.</td>
</tr>
<tr class="row-odd"><td>K</td>
<td>array, (<cite>M</cite>, <cite>M</cite>)</td>
<td>Covariance matrix between all of the training inputs.</td>
</tr>
<tr class="row-even"><td>noise_K</td>
<td>array, (<cite>M</cite>, <cite>M</cite>)</td>
<td>Noise portion of the covariance matrix between all of the training inputs. Only includes the noise from <tt class="xref py py-attr docutils literal"><span class="pre">noise_k</span></tt>, not from <tt class="xref py py-attr docutils literal"><span class="pre">err_y</span></tt>.</td>
</tr>
<tr class="row-odd"><td>L</td>
<td>array, (<cite>M</cite>, <cite>M</cite>)</td>
<td>Cholesky decomposition of the combined covariance matrix between all of the training inputs.</td>
</tr>
<tr class="row-even"><td>alpha</td>
<td>array, (<cite>M</cite>, 1)</td>
<td>Solution to <img class="math" src="_images/math/c33f8ed1bfd0168b7efe9940567eeacd69628ddf.png" alt="K\alpha=y"/>.</td>
</tr>
<tr class="row-odd"><td>ll</td>
<td>float</td>
<td>Log-likelihood of the data given the model.</td>
</tr>
<tr class="row-even"><td>diag_factor</td>
<td>float</td>
<td>The factor of <tt class="xref py py-attr docutils literal"><span class="pre">sys.float_info.epsilon</span></tt> which is added to the diagonal of the <cite>K</cite> matrix to improve stability.</td>
</tr>
<tr class="row-odd"><td>mu</td>
<td><a class="reference internal" href="#gptools.mean.MeanFunction" title="gptools.mean.MeanFunction"><tt class="xref py py-class docutils literal"><span class="pre">MeanFunction</span></tt></a> instance</td>
<td>The mean function.</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="gptools.gaussian_process.GaussianProcess.hyperprior">
<tt class="descname">hyperprior</tt><a class="reference internal" href="_modules/gptools/gaussian_process.html#GaussianProcess.hyperprior"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.gaussian_process.GaussianProcess.hyperprior" title="Permalink to this definition">¶</a></dt>
<dd><p>Combined hyperprior for the kernel, noise kernel and (if present) mean function.</p>
</dd></dl>

<dl class="attribute">
<dt id="gptools.gaussian_process.GaussianProcess.fixed_params">
<tt class="descname">fixed_params</tt><a class="reference internal" href="_modules/gptools/gaussian_process.html#GaussianProcess.fixed_params"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.gaussian_process.GaussianProcess.fixed_params" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="gptools.gaussian_process.GaussianProcess.params">
<tt class="descname">params</tt><a class="reference internal" href="_modules/gptools/gaussian_process.html#GaussianProcess.params"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.gaussian_process.GaussianProcess.params" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="gptools.gaussian_process.GaussianProcess.param_bounds">
<tt class="descname">param_bounds</tt><a class="reference internal" href="_modules/gptools/gaussian_process.html#GaussianProcess.param_bounds"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.gaussian_process.GaussianProcess.param_bounds" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="gptools.gaussian_process.GaussianProcess.param_names">
<tt class="descname">param_names</tt><a class="reference internal" href="_modules/gptools/gaussian_process.html#GaussianProcess.param_names"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.gaussian_process.GaussianProcess.param_names" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="gptools.gaussian_process.GaussianProcess.free_params">
<tt class="descname">free_params</tt><a class="reference internal" href="_modules/gptools/gaussian_process.html#GaussianProcess.free_params"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.gaussian_process.GaussianProcess.free_params" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="gptools.gaussian_process.GaussianProcess.free_param_bounds">
<tt class="descname">free_param_bounds</tt><a class="reference internal" href="_modules/gptools/gaussian_process.html#GaussianProcess.free_param_bounds"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.gaussian_process.GaussianProcess.free_param_bounds" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="gptools.gaussian_process.GaussianProcess.free_param_names">
<tt class="descname">free_param_names</tt><a class="reference internal" href="_modules/gptools/gaussian_process.html#GaussianProcess.free_param_names"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.gaussian_process.GaussianProcess.free_param_names" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="gptools.gaussian_process.GaussianProcess.add_data">
<tt class="descname">add_data</tt><big>(</big><em>X</em>, <em>y</em>, <em>err_y=0</em>, <em>n=0</em>, <em>T=None</em><big>)</big><a class="reference internal" href="_modules/gptools/gaussian_process.html#GaussianProcess.add_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.gaussian_process.GaussianProcess.add_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Add data to the training data set of the GaussianProcess instance.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>X</strong> : array, (<cite>M</cite>, <cite>D</cite>)</p>
<blockquote>
<div><p><cite>M</cite> input values of dimension <cite>D</cite>.</p>
</div></blockquote>
<p><strong>y</strong> : array, (<cite>M</cite>,)</p>
<blockquote>
<div><p><cite>M</cite> target values.</p>
</div></blockquote>
<p><strong>err_y</strong> : array, (<cite>M</cite>,) or scalar float, optional</p>
<blockquote>
<div><p>Non-negative values only. Error given as standard deviation) in the
<cite>M</cite> target values. If <cite>err_y</cite> is a scalar, the data set is taken to
be homoscedastic (constant error). Otherwise, the length of <cite>err_y</cite>
must equal the length of <cite>y</cite>. Default value is 0 (noiseless
observations).</p>
</div></blockquote>
<p><strong>n</strong> : array, (<cite>M</cite>, <cite>D</cite>) or scalar float, optional</p>
<blockquote>
<div><p>Non-negative integer values only. Degree of derivative for each
target. If <cite>n</cite> is a scalar it is taken to be the value for all
points in <cite>y</cite>. Otherwise, the length of n must equal the length of
<cite>y</cite>. Default value is 0 (observation of target value). If
non-integer values are passed, they will be silently rounded.</p>
</div></blockquote>
<p><strong>T</strong> : array, (<cite>M</cite>, <cite>N</cite>), optional</p>
<blockquote>
<div><p>Linear transformation to get from latent variables to data in the
argument <cite>y</cite>. When <cite>T</cite> is passed the argument <cite>y</cite> holds the
transformed quantities <cite>y=TY(X)</cite> where <cite>y</cite> are the observed values
of the transformed quantities, <cite>T</cite> is the transformation matrix and
<cite>Y(X)</cite> is the underlying (untransformed) values of the function to
be fit that enter into the transformation. When <cite>T</cite> is <cite>M</cite>-by-<cite>N</cite>
and <cite>y</cite> has <cite>M</cite> elements, <cite>X</cite> and <cite>n</cite> will both be <cite>N</cite>-by-<cite>D</cite>.
Default is None (no transformation).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>ValueError</strong> :</p>
<blockquote class="last">
<div><p>Bad shapes for any of the inputs, negative values for <cite>err_y</cite> or <cite>n</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gptools.gaussian_process.GaussianProcess.condense_duplicates">
<tt class="descname">condense_duplicates</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/gptools/gaussian_process.html#GaussianProcess.condense_duplicates"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.gaussian_process.GaussianProcess.condense_duplicates" title="Permalink to this definition">¶</a></dt>
<dd><p>Condense duplicate points using a transformation matrix.</p>
<p>This is useful if you have multiple non-transformed points at the same
location or multiple transformed points that use the same quadrature
points.</p>
<p>Won&#8217;t change the GP if all of the rows of [X, n] are unique. Will create
a transformation matrix T if necessary. Note that the order of the
points in [X, n] will be arbitrary after this operation.</p>
</dd></dl>

<dl class="method">
<dt id="gptools.gaussian_process.GaussianProcess.remove_outliers">
<tt class="descname">remove_outliers</tt><big>(</big><em>thresh=3</em>, <em>**predict_kwargs</em><big>)</big><a class="reference internal" href="_modules/gptools/gaussian_process.html#GaussianProcess.remove_outliers"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.gaussian_process.GaussianProcess.remove_outliers" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove outliers from the GP.</p>
<p>Removes points that are more than <cite>thresh</cite> * <cite>err_y</cite> away from the GP
mean. Note that this is only very rough in that it ignores the
uncertainty in the GP mean at any given point. But you should only be
using this as a rough way of removing bad channels, anyways!</p>
<p>Returns the values that were removed and a boolean array indicating
where the removed points were.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>thresh</strong> : float, optional</p>
<blockquote>
<div><p>The threshold as a multiplier times <cite>err_y</cite>. Default is 3 (i.e.,
throw away all 3-sigma points).</p>
</div></blockquote>
<p><strong>**predict_kwargs</strong> : optional kwargs</p>
<blockquote>
<div><p>All additional kwargs are passed to <a class="reference internal" href="#gptools.gaussian_process.GaussianProcess.predict" title="gptools.gaussian_process.GaussianProcess.predict"><tt class="xref py py-meth docutils literal"><span class="pre">predict()</span></tt></a>. You can, for
instance, use this to make it use MCMC to evaluate the mean. (If you
don&#8217;t use MCMC, then the current value of the hyperparameters is
used.)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>X_bad</strong> : array</p>
<blockquote>
<div><p>Input values of the bad points.</p>
</div></blockquote>
<p><strong>y_bad</strong> : array</p>
<blockquote>
<div><p>Bad values.</p>
</div></blockquote>
<p><strong>err_y_bad</strong> : array</p>
<blockquote>
<div><p>Uncertainties on the bad values.</p>
</div></blockquote>
<p><strong>n_bad</strong> : array</p>
<blockquote>
<div><p>Derivative order of the bad values.</p>
</div></blockquote>
<p><strong>bad_idxs</strong> : array</p>
<blockquote>
<div><p>Array of booleans with the original shape of X with True wherever
a point was taken to be bad and subsequently removed.</p>
</div></blockquote>
<p><strong>T_bad</strong> : array</p>
<blockquote class="last">
<div><p>Transformation matrix of returned points. Only returned if
<tt class="xref py py-attr docutils literal"><span class="pre">T</span></tt> is not None for the instance.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gptools.gaussian_process.GaussianProcess.optimize_hyperparameters">
<tt class="descname">optimize_hyperparameters</tt><big>(</big><em>method='SLSQP'</em>, <em>opt_kwargs={}</em>, <em>verbose=False</em>, <em>random_starts=None</em>, <em>num_proc=None</em><big>)</big><a class="reference internal" href="_modules/gptools/gaussian_process.html#GaussianProcess.optimize_hyperparameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.gaussian_process.GaussianProcess.optimize_hyperparameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Optimize the hyperparameters by maximizing the log likelihood.</p>
<p>Leaves the <a class="reference internal" href="#gptools.gaussian_process.GaussianProcess" title="gptools.gaussian_process.GaussianProcess"><tt class="xref py py-class docutils literal"><span class="pre">GaussianProcess</span></tt></a> instance in the optimized state.</p>
<p>If <tt class="xref py py-func docutils literal"><span class="pre">scipy.optimize.minimize()</span></tt> is not available (i.e., if your
<tt class="xref py py-mod docutils literal"><span class="pre">scipy</span></tt> version is older than 0.11.0) then <tt class="xref py py-func docutils literal"><span class="pre">fmin_slsqp()</span></tt>
is used independent of what you set for the <cite>method</cite> keyword.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>method</strong> : str, optional</p>
<blockquote>
<div><p>The method to pass to <tt class="xref py py-func docutils literal"><span class="pre">scipy.optimize.minimize()</span></tt>.
Refer to that function&#8217;s docstring for valid options. Default
is &#8216;SLSQP&#8217;. See note above about behavior with older versions of
<tt class="xref py py-mod docutils literal"><span class="pre">scipy</span></tt>.</p>
</div></blockquote>
<p><strong>opt_kwargs</strong> : dict, optional</p>
<blockquote>
<div><p>Dictionary of extra keywords to pass to
<tt class="xref py py-func docutils literal"><span class="pre">scipy.optimize.minimize()</span></tt>. Refer to that function&#8217;s
docstring for valid options. Note that if you use <cite>jac</cite> = True (i.e.,
optimization function returns Jacobian) you should also set <cite>args</cite>
= (True,) to tell <a class="reference internal" href="#gptools.gaussian_process.GaussianProcess.update_hyperparameters" title="gptools.gaussian_process.GaussianProcess.update_hyperparameters"><tt class="xref py py-meth docutils literal"><span class="pre">update_hyperparameters()</span></tt></a> to compute and
return the Jacobian. Default is: {}.</p>
</div></blockquote>
<p><strong>verbose</strong> : bool, optional</p>
<blockquote>
<div><p>Whether or not the output should be verbose. If True, the entire
<tt class="xref py py-class docutils literal"><span class="pre">Result</span></tt> object from <tt class="xref py py-func docutils literal"><span class="pre">scipy.optimize.minimize()</span></tt> is
printed. If False, status information is only printed if the
<cite>success</cite> flag from <tt class="xref py py-func docutils literal"><span class="pre">minimize()</span></tt> is False. Default is False.</p>
</div></blockquote>
<p><strong>random_starts</strong> : non-negative int, optional</p>
<blockquote>
<div><p>Number of times to randomly perturb the starting guesses
(distributed uniformly within their bounds) in order to seek the
global minimum. If None, then <cite>num_proc</cite> random starts will be
performed. Default is None (do number of random starts equal to the
number of processors allocated). Note that for <cite>random_starts</cite> != 0,
the initial guesses provided are not actually used.</p>
</div></blockquote>
<p><strong>num_proc</strong> : non-negative int or None</p>
<blockquote class="last">
<div><p>Number of processors to use with random starts. If 0, processing is
not done in parallel. If None, all available processors are used.
Default is None (use all available processors).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gptools.gaussian_process.GaussianProcess.predict">
<tt class="descname">predict</tt><big>(</big><em>Xstar</em>, <em>n=0</em>, <em>noise=False</em>, <em>return_std=True</em>, <em>return_cov=False</em>, <em>full_output=False</em>, <em>return_samples=False</em>, <em>num_samples=1</em>, <em>samp_kwargs={}</em>, <em>use_MCMC=False</em>, <em>full_MC=False</em>, <em>rejection_func=None</em>, <em>ddof=1</em>, <em>output_transform=None</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/gptools/gaussian_process.html#GaussianProcess.predict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.gaussian_process.GaussianProcess.predict" title="Permalink to this definition">¶</a></dt>
<dd><p>Predict the mean and covariance at the inputs <cite>Xstar</cite>.</p>
<p>The order of the derivative is given by <cite>n</cite>. The keyword <cite>noise</cite> sets
whether or not noise is included in the prediction.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>Xstar</strong> : array, (<cite>M</cite>, <cite>D</cite>)</p>
<blockquote>
<div><p><cite>M</cite> test input values of dimension <cite>D</cite>.</p>
</div></blockquote>
<p><strong>n</strong> : array, (<cite>M</cite>, <cite>D</cite>) or scalar, non-negative int, optional</p>
<blockquote>
<div><p>Order of derivative to predict (0 is the base quantity). If <cite>n</cite> is
scalar, the value is used for all points in <cite>Xstar</cite>. If non-integer
values are passed, they will be silently rounded. Default is 0
(return base quantity).</p>
</div></blockquote>
<p><strong>noise</strong> : bool, optional</p>
<blockquote>
<div><p>Whether or not noise should be included in the covariance. Default
is False (no noise in covariance).</p>
</div></blockquote>
<p><strong>return_std</strong> : bool, optional</p>
<blockquote>
<div><p>Set to True to compute and return the standard deviation for the
predictions, False to skip this step. Default is True (return tuple
of (<cite>mean</cite>, <cite>std</cite>)).</p>
</div></blockquote>
<p><strong>return_cov</strong> : bool, optional</p>
<blockquote>
<div><p>Set to True to compute and return the full covariance matrix for the
predictions. This overrides the <cite>return_std</cite> keyword. If you want
both the standard deviation and covariance matrix pre-computed, use
the <cite>full_output</cite> keyword.</p>
</div></blockquote>
<p><strong>full_output</strong> : bool, optional</p>
<blockquote>
<div><p>Set to True to return the full outputs in a dictionary with keys:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="5%" />
<col width="95%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>mean</td>
<td>mean of GP at requested points</td>
</tr>
<tr class="row-even"><td>std</td>
<td>standard deviation of GP at requested points</td>
</tr>
<tr class="row-odd"><td>cov</td>
<td>covariance matrix for values of GP at requested points</td>
</tr>
<tr class="row-even"><td>samp</td>
<td>random samples of GP at requested points (only if <cite>return_sample</cite> is True)</td>
</tr>
</tbody>
</table>
</div></blockquote>
</div></blockquote>
<p><strong>return_samples</strong> : bool, optional</p>
<blockquote>
<div><p>Set to True to compute and return samples of the GP in addition to
computing the mean. Only done if <cite>full_output</cite> is True. Default is
False.</p>
</div></blockquote>
<p><strong>num_samples</strong> : int, optional</p>
<blockquote>
<div><p>Number of samples to compute. If using MCMC this is the number of
samples per MCMC sample, if using present values of hyperparameters
this is the number of samples actually returned. Default is 1.</p>
</div></blockquote>
<p><strong>samp_kwargs</strong> : dict, optional</p>
<blockquote>
<div><p>Additional keywords to pass to <a class="reference internal" href="#gptools.gaussian_process.GaussianProcess.draw_sample" title="gptools.gaussian_process.GaussianProcess.draw_sample"><tt class="xref py py-meth docutils literal"><span class="pre">draw_sample()</span></tt></a> if
<cite>return_samples</cite> is True. Default is {}.</p>
</div></blockquote>
<p><strong>use_MCMC</strong> : bool, optional</p>
<blockquote>
<div><p>Set to True to use <a class="reference internal" href="#gptools.gaussian_process.GaussianProcess.predict_MCMC" title="gptools.gaussian_process.GaussianProcess.predict_MCMC"><tt class="xref py py-meth docutils literal"><span class="pre">predict_MCMC()</span></tt></a> to evaluate the prediction
marginalized over the hyperparameters.</p>
</div></blockquote>
<p><strong>full_MC</strong> : bool, optional</p>
<blockquote>
<div><p>Set to True to compute the mean and covariance matrix using Monte
Carlo sampling of the posterior. The samples will also be returned
if full_output is True. Default is False (don&#8217;t use full sampling).</p>
</div></blockquote>
<p><strong>rejection_func</strong> : callable, optional</p>
<blockquote>
<div><p>Any samples where this function evaluates False will be rejected,
where it evaluates True they will be kept. Default is None (no
rejection). Only has an effect if <cite>full_MC</cite> is True.</p>
</div></blockquote>
<p><strong>ddof</strong> : int, optional</p>
<blockquote>
<div><p>The degree of freedom correction to use when computing the covariance
matrix when <cite>full_MC</cite> is True. Default is 1 (unbiased estimator).</p>
</div></blockquote>
<p><strong>output_transform: array, (`L`, `M`), optional</strong> :</p>
<blockquote>
<div><p>Matrix to use to transform the output vector of length <cite>M</cite> to one of
length <cite>L</cite>. This can, for instance, be used to compute integrals.</p>
</div></blockquote>
<p><strong>**kwargs</strong> : optional kwargs</p>
<blockquote>
<div><p>All additional kwargs are passed to <a class="reference internal" href="#gptools.gaussian_process.GaussianProcess.predict_MCMC" title="gptools.gaussian_process.GaussianProcess.predict_MCMC"><tt class="xref py py-meth docutils literal"><span class="pre">predict_MCMC()</span></tt></a> if
<cite>use_MCMC</cite> is True.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>mean</strong> : array, (<cite>M</cite>,)</p>
<blockquote>
<div><p>Predicted GP mean. Only returned if <cite>full_output</cite> is False.</p>
</div></blockquote>
<p><strong>std</strong> : array, (<cite>M</cite>,)</p>
<blockquote>
<div><p>Predicted standard deviation, only returned if <cite>return_std</cite> is True, <cite>return_cov</cite> is False and <cite>full_output</cite> is False.</p>
</div></blockquote>
<p><strong>cov</strong> : array, (<cite>M</cite>, <cite>M</cite>)</p>
<blockquote>
<div><p>Predicted covariance matrix, only returned if <cite>return_cov</cite> is True and <cite>full_output</cite> is False.</p>
</div></blockquote>
<p><strong>full_output</strong> : dict</p>
<blockquote>
<div><p>Dictionary with fields for mean, std, cov and possibly random samples. Only returned if <cite>full_output</cite> is True.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>ValueError</strong> :</p>
<blockquote class="last">
<div><p>If <cite>n</cite> is not consistent with the shape of <cite>Xstar</cite> or is not entirely
composed of non-negative integers.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gptools.gaussian_process.GaussianProcess.plot">
<tt class="descname">plot</tt><big>(</big><em>X=None, n=0, ax=None, envelopes=[1, 3], base_alpha=0.375, return_prediction=False, return_std=True, full_output=False, plot_kwargs={}, **kwargs</em><big>)</big><a class="reference internal" href="_modules/gptools/gaussian_process.html#GaussianProcess.plot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.gaussian_process.GaussianProcess.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots the Gaussian process using the current hyperparameters. Only for num_dim &lt;= 2.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>X</strong> : array-like (<cite>M</cite>,) or (<cite>M</cite>, <cite>num_dim</cite>), optional</p>
<blockquote>
<div><p>The values to evaluate the Gaussian process at. If None, then 100
points between the minimum and maximum of the data&#8217;s X are used.
Default is None (use 100 points between min and max).</p>
</div></blockquote>
<p><strong>n</strong> : int or list, optional</p>
<blockquote>
<div><p>The order of derivative to compute. For num_dim=1, this must be an
int. For num_dim=2, this must be a list of ints of length 2.
Default is 0 (don&#8217;t take derivative).</p>
</div></blockquote>
<p><strong>ax</strong> : axis instance, optional</p>
<blockquote>
<div><p>Axis to plot the result on. If no axis is passed, one is created.
If the string &#8216;gca&#8217; is passed, the current axis (from plt.gca())
is used. If X_dim = 2, the axis must be 3d.</p>
</div></blockquote>
<p><strong>envelopes: list of float, optional</strong> :</p>
<blockquote>
<div><p>+/-n*sigma envelopes to plot. Default is [1, 3].</p>
</div></blockquote>
<p><strong>base_alpha</strong> : float, optional</p>
<blockquote>
<div><p>Alpha value to use for +/-1*sigma envelope. All other envelopes env
are drawn with base_alpha/env. Default is 0.375.</p>
</div></blockquote>
<p><strong>return_prediction</strong> : bool, optional</p>
<blockquote>
<div><p>If True, the predicted values are also returned. Default is False.</p>
</div></blockquote>
<p><strong>return_std</strong> : bool, optional</p>
<blockquote>
<div><p>If True, the standard deviation is computed and returned along with
the mean when <cite>return_prediction</cite> is True. Default is True.</p>
</div></blockquote>
<p><strong>full_output</strong> : bool, optional</p>
<blockquote>
<div><p>Set to True to return the full outputs in a dictionary with keys:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="5%" />
<col width="95%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>mean</td>
<td>mean of GP at requested points</td>
</tr>
<tr class="row-even"><td>std</td>
<td>standard deviation of GP at requested points</td>
</tr>
<tr class="row-odd"><td>cov</td>
<td>covariance matrix for values of GP at requested points</td>
</tr>
<tr class="row-even"><td>samp</td>
<td>random samples of GP at requested points (only if <cite>return_sample</cite> is True)</td>
</tr>
</tbody>
</table>
</div></blockquote>
</div></blockquote>
<p><strong>plot_kwargs</strong> : dict, optional</p>
<blockquote>
<div><p>The entries in this dictionary are passed as kwargs to the plotting
command used to plot the mean. Use this to, for instance, change the
color, line width and line style.</p>
</div></blockquote>
<p><strong>**kwargs</strong> : extra arguments for predict, optional</p>
<blockquote>
<div><p>Extra arguments that are passed to <a class="reference internal" href="#gptools.gaussian_process.GaussianProcess.predict" title="gptools.gaussian_process.GaussianProcess.predict"><tt class="xref py py-meth docutils literal"><span class="pre">predict()</span></tt></a>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>ax</strong> : axis instance</p>
<blockquote>
<div><p>The axis instance used.</p>
</div></blockquote>
<p><strong>mean</strong> : <tt class="xref py py-class docutils literal"><span class="pre">Array</span></tt>, (<cite>M</cite>,)</p>
<blockquote>
<div><p>Predicted GP mean. Only returned if <cite>return_prediction</cite> is True and <cite>full_output</cite> is False.</p>
</div></blockquote>
<p><strong>std</strong> : <tt class="xref py py-class docutils literal"><span class="pre">Array</span></tt>, (<cite>M</cite>,)</p>
<blockquote>
<div><p>Predicted standard deviation, only returned if <cite>return_prediction</cite> and <cite>return_std</cite> are True and <cite>full_output</cite> is False.</p>
</div></blockquote>
<p><strong>full_output</strong> : dict</p>
<blockquote class="last">
<div><p>Dictionary with fields for mean, std, cov and possibly random samples. Only returned if <cite>return_prediction</cite> and <cite>full_output</cite> are True.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gptools.gaussian_process.GaussianProcess.draw_sample">
<tt class="descname">draw_sample</tt><big>(</big><em>Xstar</em>, <em>n=0</em>, <em>num_samp=1</em>, <em>rand_vars=None</em>, <em>rand_type='standard normal'</em>, <em>diag_factor=1000.0</em>, <em>method='cholesky'</em>, <em>num_eig=None</em>, <em>mean=None</em>, <em>cov=None</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/gptools/gaussian_process.html#GaussianProcess.draw_sample"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.gaussian_process.GaussianProcess.draw_sample" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw a sample evaluated at the given points <cite>Xstar</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>Xstar</strong> : array, (<cite>M</cite>, <cite>D</cite>)</p>
<blockquote>
<div><p><cite>M</cite> test input values of dimension <cite>D</cite>.</p>
</div></blockquote>
<p><strong>n</strong> : array, (<cite>M</cite>, <cite>D</cite>) or scalar, non-negative int, optional</p>
<blockquote>
<div><p>Derivative order to evaluate at. Default is 0 (evaluate value).</p>
</div></blockquote>
<p><strong>noise</strong> : bool, optional</p>
<blockquote>
<div><p>Whether or not to include the noise components of the kernel in the
sample. Default is False (no noise in samples).</p>
</div></blockquote>
<p><strong>num_samp</strong> : Positive int, optional</p>
<blockquote>
<div><p>Number of samples to draw. Default is 1. Cannot be used in
conjunction with <cite>rand_vars</cite>: If you pass both <cite>num_samp</cite> and
<cite>rand_vars</cite>, <cite>num_samp</cite> will be silently ignored.</p>
</div></blockquote>
<p><strong>rand_vars</strong> : array, (<cite>M</cite>, <cite>P</cite>), optional</p>
<blockquote>
<div><p>Vector of random variables <img class="math" src="_images/math/e5fc41b391867da81606413e3389c7efc73abaf0.png" alt="u"/> to use in constructing the
sample <img class="math" src="_images/math/6cae2c0be9bffc14723f18bf98dba86669b258a7.png" alt="y_* = f_* + Lu"/>, where <img class="math" src="_images/math/3aa8f5548a5d73bfbdbe9e417edbb2f5a6b79448.png" alt="K=LL^T"/>. If None,
values will be produced using
<tt class="xref py py-func docutils literal"><span class="pre">numpy.random.multivariate_normal()</span></tt>. This allows you to use
pseudo/quasi random numbers generated by an external routine.
Default is None (use <tt class="xref py py-func docutils literal"><span class="pre">multivariate_normal()</span></tt> directly).</p>
</div></blockquote>
<p><strong>rand_type</strong> : {&#8216;standard normal&#8217;, &#8216;uniform&#8217;}, optional</p>
<blockquote>
<div><p>Type of distribution the inputs are given with.</p>
<blockquote>
<div><ul class="simple">
<li>&#8216;standard normal&#8217;: Standard (<cite>mu</cite> = 0, <cite>sigma</cite> = 1) normal
distribution (this is the default)</li>
<li>&#8216;uniform&#8217;: Uniform distribution on [0, 1). In this case
the required Gaussian variables are produced with inversion.</li>
</ul>
</div></blockquote>
</div></blockquote>
<p><strong>diag_factor</strong> : float, optional</p>
<blockquote>
<div><p>Number (times machine epsilon) added to the diagonal of the
covariance matrix prior to computing its Cholesky decomposition.
This is necessary as sometimes the decomposition will fail because,
to machine precision, the matrix appears to not be positive definite.
If you are getting errors from <tt class="xref py py-func docutils literal"><span class="pre">scipy.linalg.cholesky()</span></tt>, try
increasing this an order of magnitude at a time. This parameter only
has an effect when using rand_vars. Default value is 1e3.</p>
</div></blockquote>
<p><strong>method</strong> : {&#8216;cholesky&#8217;, &#8216;eig&#8217;}, optional</p>
<blockquote>
<div><p>Method to use for constructing the matrix square root. Default is
&#8216;cholesky&#8217; (use lower-triangular Cholesky decomposition).</p>
<blockquote>
<div><ul class="simple">
<li>&#8216;cholesky&#8217;: Perform Cholesky decomposition on the covariance
matrix: <img class="math" src="_images/math/3aa8f5548a5d73bfbdbe9e417edbb2f5a6b79448.png" alt="K=LL^T"/>, use <img class="math" src="_images/math/0a5711c7a37994043b2bc3bb374adca232491762.png" alt="L"/> as the matrix square
root.</li>
<li>&#8216;eig&#8217;: Perform an eigenvalue decomposition on the covariance
matrix: <img class="math" src="_images/math/82af3ba391cc6adf3b3f301b22c6b8820758d683.png" alt="K=Q \Lambda Q^{-1}"/>, use <img class="math" src="_images/math/d7302a5bc50831565eb56ac300472d4688d692ed.png" alt="Q\Lambda^{1/2}"/>
as the matrix square root.</li>
</ul>
</div></blockquote>
</div></blockquote>
<p><strong>num_eig</strong> : int or None, optional</p>
<blockquote>
<div><p>Number of eigenvalues to compute. Can range from 1 to <cite>M</cite> (the
number of test points). If it is None, then all eigenvalues are
computed. Default is None (compute all eigenvalues). This keyword
only has an effect if <cite>method</cite> is &#8216;eig&#8217;.</p>
</div></blockquote>
<p><strong>mean</strong> : array, (<cite>M</cite>,)</p>
<blockquote>
<div><p>If you have pre-computed the mean and covariance matrix, then you
can simply pass them in with the <cite>mean</cite> and <cite>cov</cite> keywords to save
on having to call <a class="reference internal" href="#gptools.gaussian_process.GaussianProcess.predict" title="gptools.gaussian_process.GaussianProcess.predict"><tt class="xref py py-meth docutils literal"><span class="pre">predict()</span></tt></a>.</p>
</div></blockquote>
<p><strong>cov</strong> : array, (<cite>M</cite>, <cite>M</cite>)</p>
<blockquote>
<div><p>If you have pre-computed the mean and covariance matrix, then you
can simply pass them in with the <cite>mean</cite> and <cite>cov</cite> keywords to save
on having to call <a class="reference internal" href="#gptools.gaussian_process.GaussianProcess.predict" title="gptools.gaussian_process.GaussianProcess.predict"><tt class="xref py py-meth docutils literal"><span class="pre">predict()</span></tt></a>.</p>
</div></blockquote>
<p><strong>**kwargs</strong> : optional kwargs</p>
<blockquote>
<div><p>All extra keyword arguments are passed to <a class="reference internal" href="#gptools.gaussian_process.GaussianProcess.predict" title="gptools.gaussian_process.GaussianProcess.predict"><tt class="xref py py-meth docutils literal"><span class="pre">predict()</span></tt></a> when
evaluating the mean and covariance matrix of the GP.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>samples</strong> : <tt class="xref py py-class docutils literal"><span class="pre">Array</span></tt> (<cite>M</cite>, <cite>P</cite>) or (<cite>M</cite>, <cite>num_samp</cite>)</p>
<blockquote>
<div><p>Samples evaluated at the <cite>M</cite> points.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>ValueError</strong> :</p>
<blockquote class="last">
<div><p>If rand_type or method is invalid.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gptools.gaussian_process.GaussianProcess.update_hyperparameters">
<tt class="descname">update_hyperparameters</tt><big>(</big><em>new_params</em>, <em>exit_on_bounds=True</em>, <em>inf_on_error=True</em><big>)</big><a class="reference internal" href="_modules/gptools/gaussian_process.html#GaussianProcess.update_hyperparameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.gaussian_process.GaussianProcess.update_hyperparameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the kernel&#8217;s hyperparameters to the new parameters.</p>
<p>This will call <a class="reference internal" href="#gptools.gaussian_process.GaussianProcess.compute_K_L_alpha_ll" title="gptools.gaussian_process.GaussianProcess.compute_K_L_alpha_ll"><tt class="xref py py-meth docutils literal"><span class="pre">compute_K_L_alpha_ll()</span></tt></a> to update the state
accordingly.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>new_params</strong> : <tt class="xref py py-class docutils literal"><span class="pre">Array</span></tt> or other Array-like, length dictated by kernel</p>
<blockquote>
<div><p>New parameters to use.</p>
</div></blockquote>
<p><strong>exit_on_bounds</strong> : bool, optional</p>
<blockquote>
<div><p>If True, the method will automatically exit if the hyperparameters
are impossible given the hyperprior, without trying to update the
internal state. This is useful during MCMC sampling and optimization.
Default is True (don&#8217;t perform update for impossible hyperparameters).</p>
</div></blockquote>
<p><strong>inf_on_error</strong> : bool, optional</p>
<blockquote>
<div><p>If True, the method will return <cite>scipy.inf</cite> if the hyperparameters
produce a linear algebra error upon trying to update the Gaussian
process. Default is True (catch errors and return infinity).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>-1*ll</strong> : float</p>
<blockquote class="last">
<div><p>The updated log likelihood.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gptools.gaussian_process.GaussianProcess.compute_K_L_alpha_ll">
<tt class="descname">compute_K_L_alpha_ll</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/gptools/gaussian_process.html#GaussianProcess.compute_K_L_alpha_ll"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.gaussian_process.GaussianProcess.compute_K_L_alpha_ll" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute <cite>K</cite>, <cite>L</cite>, <cite>alpha</cite> and log-likelihood according to the first part of Algorithm 2.1 in R&amp;W.</p>
<p>Computes <cite>K</cite> and the noise portion of <cite>K</cite> using <a class="reference internal" href="#gptools.gaussian_process.GaussianProcess.compute_Kij" title="gptools.gaussian_process.GaussianProcess.compute_Kij"><tt class="xref py py-meth docutils literal"><span class="pre">compute_Kij()</span></tt></a>,
computes <cite>L</cite> using <tt class="xref py py-func docutils literal"><span class="pre">scipy.linalg.cholesky()</span></tt>, then computes
<cite>alpha</cite> as <cite>L.T\(L\y)</cite>.</p>
<p>Only does the computation if <tt class="xref py py-attr docutils literal"><span class="pre">K_up_to_date</span></tt> is False &#8211;
otherwise leaves the existing values.</p>
</dd></dl>

<dl class="attribute">
<dt id="gptools.gaussian_process.GaussianProcess.num_dim">
<tt class="descname">num_dim</tt><a class="reference internal" href="_modules/gptools/gaussian_process.html#GaussianProcess.num_dim"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.gaussian_process.GaussianProcess.num_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of dimensions of the input data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>num_dim: int</strong> :</p>
<blockquote class="last">
<div><p>The number of dimensions of the input data as defined in the kernel.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gptools.gaussian_process.GaussianProcess.compute_Kij">
<tt class="descname">compute_Kij</tt><big>(</big><em>Xi</em>, <em>Xj</em>, <em>ni</em>, <em>nj</em>, <em>noise=False</em>, <em>hyper_deriv=None</em><big>)</big><a class="reference internal" href="_modules/gptools/gaussian_process.html#GaussianProcess.compute_Kij"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.gaussian_process.GaussianProcess.compute_Kij" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute covariance matrix between datasets <cite>Xi</cite> and <cite>Xj</cite>.</p>
<p>Specify the orders of derivatives at each location with the <cite>ni</cite>, <cite>nj</cite>
arrays. The <cite>include_noise</cite> flag is passed to the covariance kernel to
indicate whether noise is to be included (i.e., for evaluation of
<img class="math" src="_images/math/552708a78251e9a3f1f7518de516805fd83afcaf.png" alt="K+\sigma I"/> versus <img class="math" src="_images/math/d6cb20e025d1309b132c41f7b67bc682cc2f49f0.png" alt="K_*"/>).</p>
<p>If <cite>Xj</cite> is None, the symmetric matrix <img class="math" src="_images/math/eca7297da0f883330dbdc5c9ed92174799120959.png" alt="K(X, X)"/> is formed.</p>
<p>Note that type and dimension checking is NOT performed, as it is assumed
the data are from inside the instance and have hence been sanitized by
<a class="reference internal" href="#gptools.gaussian_process.GaussianProcess.add_data" title="gptools.gaussian_process.GaussianProcess.add_data"><tt class="xref py py-meth docutils literal"><span class="pre">add_data()</span></tt></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>Xi</strong> : array, (<cite>M</cite>, <cite>D</cite>)</p>
<blockquote>
<div><p><cite>M</cite> input values of dimension <cite>D</cite>.</p>
</div></blockquote>
<p><strong>Xj</strong> : array, (<cite>P</cite>, <cite>D</cite>)</p>
<blockquote>
<div><p><cite>P</cite> input values of dimension <cite>D</cite>.</p>
</div></blockquote>
<p><strong>ni</strong> : array, (<cite>M</cite>,), non-negative integers</p>
<blockquote>
<div><p><cite>M</cite> derivative orders with respect to the <cite>Xi</cite> coordinates.</p>
</div></blockquote>
<p><strong>nj</strong> : array, (<cite>P</cite>,), non-negative integers</p>
<blockquote>
<div><p><cite>P</cite> derivative orders with respect to the <cite>Xj</cite> coordinates.</p>
</div></blockquote>
<p><strong>noise</strong> : bool, optional</p>
<blockquote>
<div><p>If True, uses the noise kernel, otherwise uses the regular kernel.
Default is False (use regular kernel).</p>
</div></blockquote>
<p><strong>hyper_deriv</strong> : None or non-negative int</p>
<blockquote>
<div><p>Index of the hyperparameter to compute the first derivative with
respect to. If None, no derivatives are taken. Default is None (no
hyperparameter derivatives).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>Kij</strong> : array, (<cite>M</cite>, <cite>P</cite>)</p>
<blockquote class="last">
<div><p>Covariance matrix between <cite>Xi</cite> and <cite>Xj</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gptools.gaussian_process.GaussianProcess.compute_ll_matrix">
<tt class="descname">compute_ll_matrix</tt><big>(</big><em>bounds</em>, <em>num_pts</em><big>)</big><a class="reference internal" href="_modules/gptools/gaussian_process.html#GaussianProcess.compute_ll_matrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.gaussian_process.GaussianProcess.compute_ll_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the log likelihood over the (free) parameter space.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>bounds</strong> : 2-tuple or list of 2-tuples with length equal to the number of free parameters</p>
<blockquote>
<div><p>Bounds on the range to use for each of the parameters. If a single
2-tuple is given, it will be used for each of the parameters.</p>
</div></blockquote>
<p><strong>num_pts</strong> : int or list of ints with length equal to the number of free parameters</p>
<blockquote>
<div><p>If a single int is given, it will be used for each of the parameters.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>ll_vals</strong> : <tt class="xref py py-class docutils literal"><span class="pre">Array</span></tt></p>
<blockquote class="last">
<div><blockquote>
<div><p>The log likelihood for each of the parameter possibilities.</p>
</div></blockquote>
<dl class="docutils">
<dt>param_vals <span class="classifier-delimiter">:</span> <span class="classifier">List of <tt class="xref py py-class docutils literal"><span class="pre">Array</span></tt></span></dt>
<dd><p class="first last">The parameter values used.</p>
</dd>
</dl>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gptools.gaussian_process.GaussianProcess.sample_hyperparameter_posterior">
<tt class="descname">sample_hyperparameter_posterior</tt><big>(</big><em>nwalkers=200</em>, <em>nsamp=500</em>, <em>burn=0</em>, <em>thin=1</em>, <em>num_proc=None</em>, <em>sampler=None</em>, <em>plot_posterior=False</em>, <em>plot_chains=False</em>, <em>sampler_type='ensemble'</em>, <em>ntemps=20</em>, <em>sampler_a=2.0</em><big>)</big><a class="reference internal" href="_modules/gptools/gaussian_process.html#GaussianProcess.sample_hyperparameter_posterior"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.gaussian_process.GaussianProcess.sample_hyperparameter_posterior" title="Permalink to this definition">¶</a></dt>
<dd><p>Produce samples from the posterior for the hyperparameters using MCMC.</p>
<p>Returns the sampler created, because storing it stops the GP from being
pickleable. To add more samples to a previous sampler, pass the sampler
instance in the <cite>sampler</cite> keyword.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>nwalkers</strong> : int, optional</p>
<blockquote>
<div><p>The number of walkers to use in the sampler. Should be on the order
of several hundred. Default is 200.</p>
</div></blockquote>
<p><strong>nsamp</strong> : int, optional</p>
<blockquote>
<div><p>Number of samples (per walker) to take. Default is 500.</p>
</div></blockquote>
<p><strong>burn</strong> : int, optional</p>
<blockquote>
<div><p>This keyword only has an effect on the corner plot produced when
<cite>plot_posterior</cite> is True and the flattened chain plot produced
when <cite>plot_chains</cite> is True. To perform computations with burn-in,
see <a class="reference internal" href="#gptools.gaussian_process.GaussianProcess.compute_from_MCMC" title="gptools.gaussian_process.GaussianProcess.compute_from_MCMC"><tt class="xref py py-meth docutils literal"><span class="pre">compute_from_MCMC()</span></tt></a>. The number of samples to discard
at the beginning of the chain. Default is 0.</p>
</div></blockquote>
<p><strong>thin</strong> : int, optional</p>
<blockquote>
<div><p>This keyword only has an effect on the corner plot produced when
<cite>plot_posterior</cite> is True and the flattened chain plot produced
when <cite>plot_chains</cite> is True. To perform computations with thinning,
see <a class="reference internal" href="#gptools.gaussian_process.GaussianProcess.compute_from_MCMC" title="gptools.gaussian_process.GaussianProcess.compute_from_MCMC"><tt class="xref py py-meth docutils literal"><span class="pre">compute_from_MCMC()</span></tt></a>. Every <cite>thin</cite>-th sample is kept.
Default is 1.</p>
</div></blockquote>
<p><strong>num_proc</strong> : int or None, optional</p>
<blockquote>
<div><p>Number of processors to use. If None, all available processors are
used. Default is None (use all available processors).</p>
</div></blockquote>
<p><strong>sampler</strong> : <tt class="xref py py-class docutils literal"><span class="pre">Sampler</span></tt> instance</p>
<blockquote>
<div><p>The sampler to use. If the sampler already has samples, the most
recent sample will be used as the starting point. Otherwise a
random sample from the hyperprior will be used.</p>
</div></blockquote>
<p><strong>plot_posterior</strong> : bool, optional</p>
<blockquote>
<div><p>If True, a corner plot of the posterior for the hyperparameters
will be generated. Default is False.</p>
</div></blockquote>
<p><strong>plot_chains</strong> : bool, optional</p>
<blockquote>
<div><p>If True, a plot showing the history and autocorrelation of the
chains will be produced.</p>
</div></blockquote>
<p><strong>sampler_type</strong> : str, optional</p>
<blockquote>
<div><p>The type of sampler to use. Valid options are &#8220;ensemble&#8221; (affine-
invariant ensemble sampler) and &#8220;pt&#8221; (parallel-tempered ensemble
sampler).</p>
</div></blockquote>
<p><strong>ntemps</strong> : int, optional</p>
<blockquote>
<div><p>Number of temperatures to use with the parallel-tempered ensemble
sampler.</p>
</div></blockquote>
<p><strong>sampler_a</strong> : float, optional</p>
<blockquote class="last">
<div><p>Scale of the proposal distribution.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gptools.gaussian_process.GaussianProcess.compute_from_MCMC">
<tt class="descname">compute_from_MCMC</tt><big>(</big><em>X</em>, <em>n=0</em>, <em>return_mean=True</em>, <em>return_std=True</em>, <em>return_cov=False</em>, <em>return_samples=False</em>, <em>num_samples=1</em>, <em>noise=False</em>, <em>samp_kwargs={}</em>, <em>sampler=None</em>, <em>flat_trace=None</em>, <em>burn=0</em>, <em>thin=1</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/gptools/gaussian_process.html#GaussianProcess.compute_from_MCMC"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.gaussian_process.GaussianProcess.compute_from_MCMC" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute desired quantities from MCMC samples of the hyperparameter posterior.</p>
<p>The return will be a list with a number of rows equal to the number of
hyperparameter samples. The columns depend on the state of the boolean
flags, but will be some subset of (mean, stddev, cov, samples), in that
order. Samples will be the raw output of <a class="reference internal" href="#gptools.gaussian_process.GaussianProcess.draw_sample" title="gptools.gaussian_process.GaussianProcess.draw_sample"><tt class="xref py py-meth docutils literal"><span class="pre">draw_sample()</span></tt></a>, so you
will need to remember to convert to an array and flatten if you want to
work with a single sample.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>X</strong> : array-like (<cite>M</cite>,) or (<cite>M</cite>, <cite>num_dim</cite>)</p>
<blockquote>
<div><p>The values to evaluate the Gaussian process at.</p>
</div></blockquote>
<p><strong>n</strong> : non-negative int or list, optional</p>
<blockquote>
<div><p>The order of derivative to compute. For num_dim=1, this must be an
int. For num_dim=2, this must be a list of ints of length 2.
Default is 0 (don&#8217;t take derivative).</p>
</div></blockquote>
<p><strong>return_mean</strong> : bool, optional</p>
<blockquote>
<div><p>If True, the mean will be computed at each hyperparameter sample.
Default is True (compute mean).</p>
</div></blockquote>
<p><strong>return_std</strong> : bool, optional</p>
<blockquote>
<div><p>If True, the standard deviation will be computed at each
hyperparameter sample. Default is True (compute stddev).</p>
</div></blockquote>
<p><strong>return_cov</strong> : bool, optional</p>
<blockquote>
<div><p>If True, the covariance matrix will be computed at each
hyperparameter sample. Default is True (compute stddev).</p>
</div></blockquote>
<p><strong>return_samples</strong> : bool, optional</p>
<blockquote>
<div><p>If True, random sample(s) will be computed at each hyperparameter
sample. Default is False (do not compute samples).</p>
</div></blockquote>
<p><strong>num_samples</strong> : int, optional</p>
<blockquote>
<div><p>Compute this many samples if <cite>return_sample</cite> is True. Default is 1.</p>
</div></blockquote>
<p><strong>noise</strong> : bool, optional</p>
<blockquote>
<div><p>If True, noise is included in the predictions and samples. Default
is False (do not include noise).</p>
</div></blockquote>
<p><strong>samp_kwargs</strong> : dict, optional</p>
<blockquote>
<div><p>If <cite>return_sample</cite> is True, the contents of this dictionary will be
passed as kwargs to <a class="reference internal" href="#gptools.gaussian_process.GaussianProcess.draw_sample" title="gptools.gaussian_process.GaussianProcess.draw_sample"><tt class="xref py py-meth docutils literal"><span class="pre">draw_sample()</span></tt></a>.</p>
</div></blockquote>
<p><strong>sampler</strong> : <tt class="xref py py-class docutils literal"><span class="pre">Sampler</span></tt> instance or None, optional</p>
<blockquote>
<div><p><tt class="xref py py-class docutils literal"><span class="pre">Sampler</span></tt> instance that has already been run to the extent
desired on the hyperparameter posterior. If None, a new sampler will
be created with <a class="reference internal" href="#gptools.gaussian_process.GaussianProcess.sample_hyperparameter_posterior" title="gptools.gaussian_process.GaussianProcess.sample_hyperparameter_posterior"><tt class="xref py py-meth docutils literal"><span class="pre">sample_hyperparameter_posterior()</span></tt></a>. In this
case, all extra kwargs will be passed on, allowing you to set the
number of samples, etc. Default is None (create sampler).</p>
</div></blockquote>
<p><strong>flat_trace</strong> : array-like (<cite>nsamp</cite>, <cite>ndim</cite>) or None, optional</p>
<blockquote>
<div><p>Flattened trace with samples of the free hyperparameters. If present,
overrides <cite>sampler</cite>. This allows you to use a sampler other than the
ones from <tt class="xref py py-mod docutils literal"><span class="pre">emcee</span></tt>, or to specify arbitrary values you wish
to evaluate the curve at. Note that this WILL be thinned and burned
according to the following two kwargs. &#8220;Flat&#8221; refers to the fact
that you must have combined all chains into a single one. Default is
None (use <cite>sampler</cite>).</p>
</div></blockquote>
<p><strong>burn</strong> : int, optional</p>
<blockquote>
<div><p>The number of samples to discard at the beginning of the chain.
Default is 0.</p>
</div></blockquote>
<p><strong>thin</strong> : int, optional</p>
<blockquote>
<div><p>Every <cite>thin</cite>-th sample is kept. Default is 1.</p>
</div></blockquote>
<p><strong>num_proc</strong> : int, optional</p>
<blockquote>
<div><p>The number of processors to use for evaluation. This is used both
when calling the sampler and when evaluating the Gaussian process.
If None, the number of available processors will be used. If zero,
evaluation will proceed in parallel. Default is to use all available
processors.</p>
</div></blockquote>
<p><strong>**kwargs</strong> : extra optional kwargs</p>
<blockquote>
<div><p>All additional kwargs are passed to
<a class="reference internal" href="#gptools.gaussian_process.GaussianProcess.sample_hyperparameter_posterior" title="gptools.gaussian_process.GaussianProcess.sample_hyperparameter_posterior"><tt class="xref py py-meth docutils literal"><span class="pre">sample_hyperparameter_posterior()</span></tt></a>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> : dict</p>
<blockquote class="last">
<div><p>A dictionary having some or all of the fields &#8216;mean&#8217;, &#8216;std&#8217;, &#8216;cov&#8217;
and &#8216;samp&#8217;. Each entry is a list of array-like. The length of this
list is equal to the number of hyperparameter samples used, and the
entries have the following shapes:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="17%" />
<col width="83%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>mean</td>
<td>(<cite>M</cite>,)</td>
</tr>
<tr class="row-even"><td>std</td>
<td>(<cite>M</cite>,)</td>
</tr>
<tr class="row-odd"><td>cov</td>
<td>(<cite>M</cite>, <cite>M</cite>)</td>
</tr>
<tr class="row-even"><td>samp</td>
<td>(<cite>M</cite>, <cite>num_samples</cite>)</td>
</tr>
</tbody>
</table>
</div></blockquote>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gptools.gaussian_process.GaussianProcess.predict_MCMC">
<tt class="descname">predict_MCMC</tt><big>(</big><em>X</em>, <em>ddof=1</em>, <em>full_MC=False</em>, <em>rejection_func=None</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/gptools/gaussian_process.html#GaussianProcess.predict_MCMC"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.gaussian_process.GaussianProcess.predict_MCMC" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a prediction using MCMC samples.</p>
<p>This is essentially a convenient wrapper of <a class="reference internal" href="#gptools.gaussian_process.GaussianProcess.compute_from_MCMC" title="gptools.gaussian_process.GaussianProcess.compute_from_MCMC"><tt class="xref py py-meth docutils literal"><span class="pre">compute_from_MCMC()</span></tt></a>,
designed to act more or less interchangeably with <a class="reference internal" href="#gptools.gaussian_process.GaussianProcess.predict" title="gptools.gaussian_process.GaussianProcess.predict"><tt class="xref py py-meth docutils literal"><span class="pre">predict()</span></tt></a>.</p>
<p>Computes the mean of the GP posterior marginalized over the
hyperparameters using iterated expectations. If <cite>return_std</cite> is True,
uses the law of total variance to compute the variance of the GP
posterior marginalized over the hyperparameters. If <cite>return_cov</cite> is True,
uses the law of total covariance to compute the entire covariance of the
GP posterior marginalized over the hyperparameters. If both <cite>return_cov</cite>
and <cite>return_std</cite> are True, then both the covariance matrix and standard
deviation array will be returned.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>X</strong> : array-like (<cite>M</cite>,) or (<cite>M</cite>, <cite>num_dim</cite>)</p>
<blockquote>
<div><p>The values to evaluate the Gaussian process at.</p>
</div></blockquote>
<p><strong>ddof</strong> : int, optional</p>
<blockquote>
<div><p>The degree of freedom correction to use when computing the variance.
Default is 1 (standard Bessel correction for unbiased estimate).</p>
</div></blockquote>
<p><strong>return_std</strong> : bool, optional</p>
<blockquote>
<div><p>If True, the standard deviation is also computed. Default is True.</p>
</div></blockquote>
<p><strong>full_MC</strong> : bool, optional</p>
<blockquote>
<div><p>Set to True to compute the mean and covariance matrix using Monte
Carlo sampling of the posterior. The samples will also be returned
if full_output is True. Default is False (don&#8217;t use full sampling).</p>
</div></blockquote>
<p><strong>rejection_func</strong> : callable, optional</p>
<blockquote>
<div><p>Any samples where this function evaluates False will be rejected,
where it evaluates True they will be kept. Default is None (no
rejection). Only has an effect if <cite>full_MC</cite> is True.</p>
</div></blockquote>
<p><strong>ddof</strong> : int, optional</p>
<p><strong>**kwargs</strong> : optional kwargs</p>
<blockquote class="last">
<div><p>All additional kwargs are passed directly to
<a class="reference internal" href="#gptools.gaussian_process.GaussianProcess.compute_from_MCMC" title="gptools.gaussian_process.GaussianProcess.compute_from_MCMC"><tt class="xref py py-meth docutils literal"><span class="pre">compute_from_MCMC()</span></tt></a>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="gptools.gaussian_process.Constraint">
<em class="property">class </em><tt class="descclassname">gptools.gaussian_process.</tt><tt class="descname">Constraint</tt><big>(</big><em>gp</em>, <em>boundary_val=0.0</em>, <em>n=0</em>, <em>loc='min'</em>, <em>type_='gt'</em>, <em>bounds=None</em><big>)</big><a class="reference internal" href="_modules/gptools/gaussian_process.html#Constraint"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.gaussian_process.Constraint" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Implements an inequality constraint on the value of the mean or its derivatives.</p>
<p>Provides a callable such as can be passed to SLSQP or COBYLA to implement
the constraint when using <tt class="xref py py-func docutils literal"><span class="pre">scipy.optimize.minimize()</span></tt>.</p>
<p>The function defaults implement a constraint that forces the mean value to
be positive everywhere.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>gp</strong> : <a class="reference internal" href="#gptools.gaussian_process.GaussianProcess" title="gptools.gaussian_process.GaussianProcess"><tt class="xref py py-class docutils literal"><span class="pre">GaussianProcess</span></tt></a></p>
<blockquote>
<div><p>The <a class="reference internal" href="#gptools.gaussian_process.GaussianProcess" title="gptools.gaussian_process.GaussianProcess"><tt class="xref py py-class docutils literal"><span class="pre">GaussianProcess</span></tt></a> instance to create the constraint on.</p>
</div></blockquote>
<p><strong>boundary_val</strong> : float, optional</p>
<blockquote>
<div><p>Boundary value for the constraint. For <cite>type_</cite> = &#8216;gt&#8217;, this is the lower
bound, for <cite>type_</cite> = &#8216;lt&#8217;, this is the upper bound. Default is 0.0.</p>
</div></blockquote>
<p><strong>n</strong> : non-negative int, optional</p>
<blockquote>
<div><p>Derivative order to evaluate. Default is 0 (value of the mean). Note
that non-int values are silently cast to int.</p>
</div></blockquote>
<p><strong>loc</strong> : {&#8216;min&#8217;, &#8216;max&#8217;}, float or Array-like of float (<cite>num_dim</cite>,), optional</p>
<blockquote>
<div><p>Which extreme of the mean to use, or location to evaluate at.</p>
<ul class="simple">
<li>If &#8216;min&#8217;, the minimum of the mean (optionally over <cite>bounds</cite>) is used.</li>
<li>If &#8216;max&#8217;, the maximum of the mean (optionally over <cite>bounds</cite>) is used.</li>
<li>If a float (valid for <cite>num_dim</cite> = 1 only) or Array of float, the mean
is evaluated at the given X value.</li>
</ul>
<p>Default is &#8216;min&#8217; (use function minimum).</p>
</div></blockquote>
<p><strong>type_</strong> : {&#8216;gt&#8217;, &#8216;lt&#8217;}, optional</p>
<blockquote>
<div><p>What type of inequality constraint to implement.</p>
<ul class="simple">
<li>If &#8216;gt&#8217;, a greater-than-or-equals constraint is used.</li>
<li>If &#8216;lt&#8217;, a less-than-or-equals constraint is used.</li>
</ul>
<p>Default is &#8216;gt&#8217; (greater-than-or-equals).</p>
</div></blockquote>
<p><strong>bounds</strong> : 2-tuple of float or 2-tuple Array-like of float (<cite>num_dim</cite>,) or None, optional</p>
<blockquote>
<div><p>Bounds to use when <cite>loc</cite> is &#8216;min&#8217; or &#8216;max&#8217;.</p>
<ul class="simple">
<li>If None, the bounds are taken to be the extremes of the training data.
For multivariate data, &#8220;extremes&#8221; essentially means the smallest
hypercube oriented parallel to the axes that encapsulates all of the
training inputs. (I.e., <tt class="docutils literal"><span class="pre">(gp.X.min(axis=0),</span> <span class="pre">gp.X.max(axis=0))</span></tt>)</li>
<li>If <cite>bounds</cite> is a 2-tuple, then this is used as (<cite>lower</cite>, <cite>upper</cite>)
where lower` and <cite>upper</cite> are Array-like with dimensions (<cite>num_dim</cite>,).</li>
<li>If <cite>num_dim</cite> is 1 then <cite>lower</cite> and <cite>upper</cite> can be scalar floats.</li>
</ul>
<p>Default is None (use extreme values of training data).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>TypeError</strong> :</p>
<blockquote>
<div><p>If <cite>gp</cite> is not an instance of <a class="reference internal" href="#gptools.gaussian_process.GaussianProcess" title="gptools.gaussian_process.GaussianProcess"><tt class="xref py py-class docutils literal"><span class="pre">GaussianProcess</span></tt></a>.</p>
</div></blockquote>
<p><strong>ValueError</strong> :</p>
<blockquote>
<div><p>If <cite>n</cite> is negative.</p>
</div></blockquote>
<p><strong>ValueError</strong> :</p>
<blockquote>
<div><p>If <cite>loc</cite> is not &#8216;min&#8217;, &#8216;max&#8217; or an Array-like of the correct dimensions.</p>
</div></blockquote>
<p><strong>ValueError</strong> :</p>
<blockquote>
<div><p>If <cite>type_</cite> is not &#8216;gt&#8217; or &#8216;lt&#8217;.</p>
</div></blockquote>
<p><strong>ValueError</strong> :</p>
<blockquote class="last">
<div><p>If <cite>bounds</cite> is not None or length 2 or if the elements of bounds don&#8217;t
have the right dimensions.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="gptools.gaussian_process.Constraint.__call__">
<tt class="descname">__call__</tt><big>(</big><em>params</em><big>)</big><a class="reference internal" href="_modules/gptools/gaussian_process.html#Constraint.__call__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.gaussian_process.Constraint.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a non-negative number if the constraint is satisfied.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>params</strong> : Array-like, length dictated by kernel</p>
<blockquote>
<div><p>New parameters to use.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>val</strong> : float</p>
<blockquote class="last">
<div><p>Value of the constraint. <tt class="xref py py-class docutils literal"><span class="pre">minimize</span></tt> will attempt to keep
this non-negative.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-gptools.gp_utils">
<span id="gptools-gp-utils-module"></span><h2>gptools.gp_utils module<a class="headerlink" href="#module-gptools.gp_utils" title="Permalink to this headline">¶</a></h2>
<p>Provides convenient utilities for working with the classes and results from <a class="reference internal" href="#module-gptools" title="gptools"><tt class="xref py py-mod docutils literal"><span class="pre">gptools</span></tt></a>.</p>
<p>This module specifically contains utilities that need to interact directly with
the GaussianProcess object, and hence can present circular import problems when
incorporated in the main utils submodule.</p>
<dl class="function">
<dt id="gptools.gp_utils.parallel_compute_ll_matrix">
<tt class="descclassname">gptools.gp_utils.</tt><tt class="descname">parallel_compute_ll_matrix</tt><big>(</big><em>gp</em>, <em>bounds</em>, <em>num_pts</em>, <em>num_proc=None</em><big>)</big><a class="reference internal" href="_modules/gptools/gp_utils.html#parallel_compute_ll_matrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.gp_utils.parallel_compute_ll_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute matrix of the log likelihood over the parameter space in parallel.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>bounds</strong> : 2-tuple or list of 2-tuples with length equal to the number of free parameters</p>
<blockquote>
<div><p>Bounds on the range to use for each of the parameters. If a single
2-tuple is given, it will be used for each of the parameters.</p>
</div></blockquote>
<p><strong>num_pts</strong> : int or list of ints with length equal to the number of free parameters</p>
<blockquote>
<div><p>The number of points to use for each parameters. If a single int is
given, it will be used for each of the parameters.</p>
</div></blockquote>
<p><strong>num_proc</strong> : Positive int or None, optional</p>
<blockquote>
<div><p>Number of processes to run the parallel computation with. If set to
None, ALL available cores are used. Default is None (use all available
cores).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>ll_vals</strong> : array</p>
<blockquote>
<div><p>The log likelihood for each of the parameter possibilities.</p>
</div></blockquote>
<p><strong>param_vals</strong> : list of array</p>
<blockquote class="last">
<div><p>The parameter values used.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="gptools.gp_utils.slice_plot">
<tt class="descclassname">gptools.gp_utils.</tt><tt class="descname">slice_plot</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/gptools/gp_utils.html#slice_plot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.gp_utils.slice_plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs a plot that lets you look at slices through a multidimensional array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>vals</strong> : array, (<cite>M</cite>, <cite>D</cite>, <cite>P</cite>, ...)</p>
<blockquote>
<div><p>Multidimensional array to visualize.</p>
</div></blockquote>
<p><strong>x_vals_1</strong> : array, (<cite>M</cite>,)</p>
<blockquote>
<div><p>Values along the first dimension.</p>
</div></blockquote>
<p><strong>x_vals_2</strong> : array, (<cite>D</cite>,)</p>
<blockquote>
<div><p>Values along the second dimension.</p>
</div></blockquote>
<p><strong>x_vals_3</strong> : array, (<cite>P</cite>,)</p>
<blockquote>
<div><p>Values along the third dimension.</p>
<p><strong>...and so on. At least four arguments must be provided.</strong></p>
</div></blockquote>
<p><strong>names</strong> : list of strings, optional</p>
<blockquote>
<div><p>Names for each of the parameters at hand. If None, sequential numerical
identifiers will be used. Length must be equal to the number of
dimensions of <cite>vals</cite>. Default is None.</p>
</div></blockquote>
<p><strong>n</strong> : Positive int, optional</p>
<blockquote>
<div><p>Number of contours to plot. Default is 100.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>f</strong> : <tt class="xref py py-class docutils literal"><span class="pre">Figure</span></tt></p>
<blockquote>
<div><p>The Matplotlib figure instance created.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>GPArgumentError</strong> :</p>
<blockquote class="last">
<div><p>If the number of arguments is less than 4.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="gptools.gp_utils.arrow_respond">
<tt class="descclassname">gptools.gp_utils.</tt><tt class="descname">arrow_respond</tt><big>(</big><em>slider</em>, <em>event</em><big>)</big><a class="reference internal" href="_modules/gptools/gp_utils.html#arrow_respond"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.gp_utils.arrow_respond" title="Permalink to this definition">¶</a></dt>
<dd><p>Event handler for arrow key events in plot windows.</p>
<p>Pass the slider object to update as a masked argument using a lambda function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">lambda</span> <span class="n">evt</span><span class="p">:</span> <span class="n">arrow_respond</span><span class="p">(</span><span class="n">my_slider</span><span class="p">,</span> <span class="n">evt</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>slider</strong> : Slider instance associated with this handler.</p>
<p class="last"><strong>event</strong> : Event to be handled.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-gptools.mean">
<span id="gptools-mean-module"></span><h2>gptools.mean module<a class="headerlink" href="#module-gptools.mean" title="Permalink to this headline">¶</a></h2>
<p>Provides classes for defining explicit, parametric mean functions.</p>
<p>To provide the necessary hooks to optimize/sample the hyperparameters, your mean
function must be wrapped with <a class="reference internal" href="#gptools.mean.MeanFunction" title="gptools.mean.MeanFunction"><tt class="xref py py-class docutils literal"><span class="pre">MeanFunction</span></tt></a> before being passed to
<tt class="xref py py-class docutils literal"><span class="pre">GaussianProcess</span></tt>. The function must have the calling fingerprint
<cite>fun(X, n, p1, p2, ...)</cite>, where <cite>X</cite> is an array with shape <cite>(M, N)</cite>, <cite>n</cite> is a
vector with length <cite>D</cite> and <cite>p1</cite>, <cite>p2</cite>, ... are the (hyper)parameters of the mean
function, given as individual arguments.</p>
<dl class="class">
<dt id="gptools.mean.MeanFunction">
<em class="property">class </em><tt class="descclassname">gptools.mean.</tt><tt class="descname">MeanFunction</tt><big>(</big><em>fun</em>, <em>num_params=None</em>, <em>initial_params=None</em>, <em>fixed_params=None</em>, <em>param_bounds=None</em>, <em>param_names=None</em>, <em>enforce_bounds=False</em>, <em>hyperprior=None</em><big>)</big><a class="reference internal" href="_modules/gptools/mean.html#MeanFunction"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.mean.MeanFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Wrapper to turn a function into a form useable by <tt class="xref py py-class docutils literal"><span class="pre">GaussianProcess</span></tt>.</p>
<p>This lets you define a simple function <cite>fun(X, n, p1, p2, ...)</cite> that
operates on an (<cite>M</cite>, <cite>D</cite>) array <cite>X</cite>, taking the derivatives indicated by the
vector <cite>n</cite> with length <cite>D</cite> (one derivative order for each dimension). The
function should evaluate this derivative at all points in <cite>X</cite>, returning an
array of length <cite>M</cite>. <a class="reference internal" href="#gptools.mean.MeanFunction" title="gptools.mean.MeanFunction"><tt class="xref py py-class docutils literal"><span class="pre">MeanFunction</span></tt></a> takes care of looping over the
different derivatives requested by <tt class="xref py py-class docutils literal"><span class="pre">GaussianProcess</span></tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fun</strong> : callable</p>
<blockquote>
<div><p>Must have fingerprint <cite>fun(X, n, p1, p2, ...)</cite> where <cite>X</cite> is an array
with shape (<cite>M</cite>, <cite>D</cite>), <cite>n</cite> is an array of non-negative integers with
length <cite>D</cite> representing the order of derivative orders to take for each
dimension and <cite>p1</cite>, <cite>p2</cite>, ... are the parameters of the mean function.</p>
</div></blockquote>
<p><strong>num_params</strong> : Non-negative int, optional</p>
<blockquote>
<div><p>Number of parameters in the model. Default is to determine the number of
parameters by inspection of <cite>fun</cite> or the other arguments provided.</p>
</div></blockquote>
<p><strong>initial_params</strong> : Array, (<cite>num_params</cite>,), optional</p>
<blockquote>
<div><p>Initial values to set for the hyperparameters. Default is None, in
which case 1 is used for the initial values.</p>
</div></blockquote>
<p><strong>fixed_params</strong> : Array of bool, (<cite>num_params</cite>,), optional</p>
<blockquote>
<div><p>Sets which hyperparameters are considered fixed when optimizing the log
likelihood. A True entry corresponds to that element being
fixed (where the element ordering is as defined in the class).
Default value is None (no hyperparameters are fixed).</p>
</div></blockquote>
<p><strong>param_bounds</strong> : list of 2-tuples (<cite>num_params</cite>,), optional</p>
<blockquote>
<div><p>List of bounds for each of the hyperparameters. Each 2-tuple is of the
form (lower`, <cite>upper</cite>). If there is no bound in a given direction, it
works best to set it to something big like 1e16. Default is (0.0, 1e16)
for each hyperparameter. Note that this is overridden by the <cite>hyperprior</cite>
keyword, if present.</p>
</div></blockquote>
<p><strong>param_names</strong> : list of str (<cite>num_params</cite>,), optional</p>
<blockquote>
<div><p>List of labels for the hyperparameters. Default is all empty strings.</p>
</div></blockquote>
<p><strong>enforce_bounds</strong> : bool, optional</p>
<blockquote>
<div><p>If True, an attempt to set a hyperparameter outside of its bounds will
result in the hyperparameter being set right at its bound. If False,
bounds are not enforced inside the kernel. Default is False (do not
enforce bounds).</p>
</div></blockquote>
<p><strong>hyperprior</strong> : <tt class="xref py py-class docutils literal"><span class="pre">JointPrior</span></tt> instance or list, optional</p>
<blockquote class="last">
<div><p>Joint prior distribution for all hyperparameters. Can either be given
as a <tt class="xref py py-class docutils literal"><span class="pre">JointPrior</span></tt> instance or a list of <cite>num_params</cite>
callables or <tt class="xref py py-class docutils literal"><span class="pre">rv_frozen</span></tt> instances from <tt class="xref py py-mod docutils literal"><span class="pre">scipy.stats</span></tt>,
in which case a <tt class="xref py py-class docutils literal"><span class="pre">IndependentJointPrior</span></tt> is constructed with
these as the independent priors on each hyperparameter. Default is a
uniform PDF on all hyperparameters.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="gptools.mean.MeanFunction.__call__">
<tt class="descname">__call__</tt><big>(</big><em>X</em>, <em>n</em><big>)</big><a class="reference internal" href="_modules/gptools/mean.html#MeanFunction.__call__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.mean.MeanFunction.__call__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="gptools.mean.MeanFunction.param_bounds">
<tt class="descname">param_bounds</tt><a class="reference internal" href="_modules/gptools/mean.html#MeanFunction.param_bounds"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.mean.MeanFunction.param_bounds" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="gptools.mean.MeanFunction.set_hyperparams">
<tt class="descname">set_hyperparams</tt><big>(</big><em>new_params</em><big>)</big><a class="reference internal" href="_modules/gptools/mean.html#MeanFunction.set_hyperparams"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.mean.MeanFunction.set_hyperparams" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the free hyperparameters to the new parameter values in new_params.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>new_params</strong> : <tt class="xref py py-class docutils literal"><span class="pre">Array</span></tt> or other Array-like, (len(<tt class="xref py py-attr docutils literal"><span class="pre">self.params</span></tt>),)</p>
<blockquote class="last">
<div><p>New parameter values, ordered as dictated by the docstring for the
class.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="gptools.mean.MeanFunction.num_free_params">
<tt class="descname">num_free_params</tt><a class="reference internal" href="_modules/gptools/mean.html#MeanFunction.num_free_params"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.mean.MeanFunction.num_free_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of free parameters.</p>
</dd></dl>

<dl class="attribute">
<dt id="gptools.mean.MeanFunction.free_param_idxs">
<tt class="descname">free_param_idxs</tt><a class="reference internal" href="_modules/gptools/mean.html#MeanFunction.free_param_idxs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.mean.MeanFunction.free_param_idxs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the indices of the free parameters in the main arrays of parameters, etc.</p>
</dd></dl>

<dl class="attribute">
<dt id="gptools.mean.MeanFunction.free_params">
<tt class="descname">free_params</tt><a class="reference internal" href="_modules/gptools/mean.html#MeanFunction.free_params"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.mean.MeanFunction.free_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the values of the free hyperparameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>free_params</strong> : <tt class="xref py py-class docutils literal"><span class="pre">Array</span></tt></p>
<blockquote class="last">
<div><p>Array of the free parameters, in order.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="gptools.mean.MeanFunction.free_param_bounds">
<tt class="descname">free_param_bounds</tt><a class="reference internal" href="_modules/gptools/mean.html#MeanFunction.free_param_bounds"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.mean.MeanFunction.free_param_bounds" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the bounds of the free hyperparameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>free_param_bounds</strong> : <tt class="xref py py-class docutils literal"><span class="pre">Array</span></tt></p>
<blockquote class="last">
<div><p>Array of the bounds of the free parameters, in order.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="gptools.mean.MeanFunction.free_param_names">
<tt class="descname">free_param_names</tt><a class="reference internal" href="_modules/gptools/mean.html#MeanFunction.free_param_names"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.mean.MeanFunction.free_param_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the names of the free hyperparameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>free_param_names</strong> : <tt class="xref py py-class docutils literal"><span class="pre">Array</span></tt></p>
<blockquote class="last">
<div><p>Array of the names of the free parameters, in order.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="gptools.mean.constant">
<tt class="descclassname">gptools.mean.</tt><tt class="descname">constant</tt><big>(</big><em>X</em>, <em>n</em>, <em>mu</em><big>)</big><a class="reference internal" href="_modules/gptools/mean.html#constant"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.mean.constant" title="Permalink to this definition">¶</a></dt>
<dd><p>Function implementing a constant mean suitable for use with <a class="reference internal" href="#gptools.mean.MeanFunction" title="gptools.mean.MeanFunction"><tt class="xref py py-class docutils literal"><span class="pre">MeanFunction</span></tt></a>.</p>
</dd></dl>

<dl class="class">
<dt id="gptools.mean.ConstantMeanFunction">
<em class="property">class </em><tt class="descclassname">gptools.mean.</tt><tt class="descname">ConstantMeanFunction</tt><big>(</big><em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/gptools/mean.html#ConstantMeanFunction"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.mean.ConstantMeanFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#gptools.mean.MeanFunction" title="gptools.mean.MeanFunction"><tt class="xref py py-class docutils literal"><span class="pre">gptools.mean.MeanFunction</span></tt></a></p>
<p>Class implementing a constant mean function suitable for use with <tt class="xref py py-class docutils literal"><span class="pre">GaussianProcess</span></tt>.</p>
<p>All kwargs are passed to <a class="reference internal" href="#gptools.mean.MeanFunction" title="gptools.mean.MeanFunction"><tt class="xref py py-class docutils literal"><span class="pre">MeanFunction</span></tt></a>. If you do not pass
<cite>hyperprior</cite> or <cite>param_bounds</cite>, the hyperprior for the mean is taken to be
uniform over [-1e3, 1e3].</p>
</dd></dl>

<dl class="function">
<dt id="gptools.mean.mtanh">
<tt class="descclassname">gptools.mean.</tt><tt class="descname">mtanh</tt><big>(</big><em>alpha</em>, <em>z</em><big>)</big><a class="reference internal" href="_modules/gptools/mean.html#mtanh"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.mean.mtanh" title="Permalink to this definition">¶</a></dt>
<dd><p>Modified hyperbolic tangent function mtanh(z; alpha).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>alpha</strong> : float</p>
<blockquote>
<div><p>The core slope of the mtanh.</p>
</div></blockquote>
<p><strong>z</strong> : float or array</p>
<blockquote class="last">
<div><p>The coordinate of the mtanh.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="gptools.mean.mtanh_profile">
<tt class="descclassname">gptools.mean.</tt><tt class="descname">mtanh_profile</tt><big>(</big><em>X</em>, <em>n</em>, <em>x0</em>, <em>delta</em>, <em>alpha</em>, <em>h</em>, <em>b</em><big>)</big><a class="reference internal" href="_modules/gptools/mean.html#mtanh_profile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.mean.mtanh_profile" title="Permalink to this definition">¶</a></dt>
<dd><p>Profile used with the mtanh function to fit profiles, suitable for use with <a class="reference internal" href="#gptools.mean.MeanFunction" title="gptools.mean.MeanFunction"><tt class="xref py py-class docutils literal"><span class="pre">MeanFunction</span></tt></a>.</p>
<p>Only supports univariate data!</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>X</strong> : array, (<cite>M</cite>, 1)</p>
<blockquote>
<div><p>The points to evaluate at.</p>
</div></blockquote>
<p><strong>n</strong> : array, (1,)</p>
<blockquote>
<div><p>The order of derivative to compute. Only up to first derivatives are
supported.</p>
</div></blockquote>
<p><strong>x0</strong> : float</p>
<blockquote>
<div><p>Pedestal center</p>
</div></blockquote>
<p><strong>delta</strong> : float</p>
<blockquote>
<div><p>Pedestal halfwidth</p>
</div></blockquote>
<p><strong>alpha</strong> : float</p>
<blockquote>
<div><p>Core slope</p>
</div></blockquote>
<p><strong>h</strong> : float</p>
<blockquote>
<div><p>Pedestal height</p>
</div></blockquote>
<p><strong>b</strong> : float</p>
<blockquote class="last">
<div><p>Pedestal foot</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="gptools.mean.MtanhMeanFunction1d">
<em class="property">class </em><tt class="descclassname">gptools.mean.</tt><tt class="descname">MtanhMeanFunction1d</tt><big>(</big><em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/gptools/mean.html#MtanhMeanFunction1d"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.mean.MtanhMeanFunction1d" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#gptools.mean.MeanFunction" title="gptools.mean.MeanFunction"><tt class="xref py py-class docutils literal"><span class="pre">gptools.mean.MeanFunction</span></tt></a></p>
<p>Profile with mtanh edge, suitable for use with <tt class="xref py py-class docutils literal"><span class="pre">GaussianProcess</span></tt>.</p>
<p>All kwargs are passed to <a class="reference internal" href="#gptools.mean.MeanFunction" title="gptools.mean.MeanFunction"><tt class="xref py py-class docutils literal"><span class="pre">MeanFunction</span></tt></a>. If <cite>hyperprior</cite> and
<cite>param_bounds</cite> are not passed then the hyperprior is taken to be uniform
over the following intervals:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="42%" />
<col width="33%" />
<col width="25%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>x0</td>
<td>0.98</td>
<td>1.1</td>
</tr>
<tr class="row-even"><td>delta</td>
<td>0.0</td>
<td>0.1</td>
</tr>
<tr class="row-odd"><td>alpha</td>
<td>-0.5</td>
<td>0.5</td>
</tr>
<tr class="row-even"><td>h</td>
<td>0</td>
<td>5</td>
</tr>
<tr class="row-odd"><td>b</td>
<td>0</td>
<td>0.5</td>
</tr>
</tbody>
</table>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="gptools.mean.linear">
<tt class="descclassname">gptools.mean.</tt><tt class="descname">linear</tt><big>(</big><em>X</em>, <em>n</em>, <em>*args</em><big>)</big><a class="reference internal" href="_modules/gptools/mean.html#linear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.mean.linear" title="Permalink to this definition">¶</a></dt>
<dd><p>Linear mean function of arbitrary dimension, suitable for use with <a class="reference internal" href="#gptools.mean.MeanFunction" title="gptools.mean.MeanFunction"><tt class="xref py py-class docutils literal"><span class="pre">MeanFunction</span></tt></a>.</p>
<p>The form is <img class="math" src="_images/math/95afdb27bf102accec9154050c8c891d3ed4b8a4.png" alt="m_0 * X[:, 0] + m_1 * X[:, 1] + \dots + b"/>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>X</strong> : array, (<cite>M</cite>, <cite>D</cite>)</p>
<blockquote>
<div><p>The points to evaluate the model at.</p>
</div></blockquote>
<p><strong>n</strong> : array of non-negative int, (<cite>D</cite>)</p>
<blockquote>
<div><p>The derivative order to take, specified as an integer order for each
dimension in <cite>X</cite>.</p>
</div></blockquote>
<p><strong>*args</strong> : num_dim+1 floats</p>
<blockquote class="last">
<div><p>The slopes for each dimension, plus the constant term. Must be of the
form <cite>m0, m1, ..., b</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="gptools.mean.LinearMeanFunction">
<em class="property">class </em><tt class="descclassname">gptools.mean.</tt><tt class="descname">LinearMeanFunction</tt><big>(</big><em>num_dim=1</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/gptools/mean.html#LinearMeanFunction"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.mean.LinearMeanFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#gptools.mean.MeanFunction" title="gptools.mean.MeanFunction"><tt class="xref py py-class docutils literal"><span class="pre">gptools.mean.MeanFunction</span></tt></a></p>
<p>Linear mean function suitable for use with <tt class="xref py py-class docutils literal"><span class="pre">GaussianProcess</span></tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>num_dim</strong> : positive int, optional</p>
<blockquote>
<div><p>The number of dimensions of the input data. Default is 1.</p>
</div></blockquote>
<p><strong>**kwargs</strong> : optional kwargs</p>
<blockquote class="last">
<div><p>All extra kwargs are passed to <a class="reference internal" href="#gptools.mean.MeanFunction" title="gptools.mean.MeanFunction"><tt class="xref py py-class docutils literal"><span class="pre">MeanFunction</span></tt></a>. If <cite>hyperprior</cite>
and <cite>param_bounds</cite> are not specified, all parameters are taken to have
a uniform hyperprior over [-1e3, 1e3].</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-gptools.utils">
<span id="gptools-utils-module"></span><h2>gptools.utils module<a class="headerlink" href="#module-gptools.utils" title="Permalink to this headline">¶</a></h2>
<p>Provides convenient utilities for working with the classes and results from <a class="reference internal" href="#module-gptools" title="gptools"><tt class="xref py py-mod docutils literal"><span class="pre">gptools</span></tt></a>.</p>
<dl class="class">
<dt id="gptools.utils.LessThanUniformPotential">
<em class="property">class </em><tt class="descclassname">gptools.utils.</tt><tt class="descname">LessThanUniformPotential</tt><big>(</big><em>l_idx</em>, <em>g_idx</em><big>)</big><a class="reference internal" href="_modules/gptools/utils.html#LessThanUniformPotential"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.utils.LessThanUniformPotential" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Class to implement a potential to enforce an inequality constraint.</p>
<p>Specifically lets you change the param with l_idx to have a uniform prior
between its lower bound and the param with g_idx.</p>
<p>Returns log((ub-lb)/(theta[g_idx]-lb)) if theta[l_idx] &lt;= theta[g_idx],
double_min otherwise.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>l_idx</strong> : int</p>
<blockquote>
<div><p>Index of the parameter that is required to be lesser.</p>
</div></blockquote>
<p><strong>g_idx</strong> : int</p>
<blockquote class="last">
<div><p>Index of the parameter that is required to be greater.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="gptools.utils.LessThanUniformPotential.__call__">
<tt class="descname">__call__</tt><big>(</big><em>theta</em>, <em>k</em><big>)</big><a class="reference internal" href="_modules/gptools/utils.html#LessThanUniformPotential.__call__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.utils.LessThanUniformPotential.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the log-density of the potential.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>theta</strong> : array-like</p>
<blockquote>
<div><p>Array of the hyperparameters.</p>
</div></blockquote>
<p><strong>k</strong> : Kernel instance</p>
<blockquote>
<div><p>The kernel the hyperparameters apply to.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>f</strong> : float</p>
<blockquote class="last">
<div><p>Returns log((ub-lb)/(theta[g_idx]-lb)) if the condition is met, -inf if not.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="gptools.utils.JeffreysPrior">
<em class="property">class </em><tt class="descclassname">gptools.utils.</tt><tt class="descname">JeffreysPrior</tt><big>(</big><em>idx</em>, <em>bounds</em><big>)</big><a class="reference internal" href="_modules/gptools/utils.html#JeffreysPrior"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.utils.JeffreysPrior" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Class to implement a Jeffreys prior over a finite range. Returns log-density.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>idx</strong> : int</p>
<blockquote>
<div><p>The index this prior applies to.</p>
</div></blockquote>
<p><strong>bounds</strong> : 2-tuple</p>
<blockquote class="last">
<div><p>The bounds for the parameter this prior corresponds to: (lb, ub).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="gptools.utils.JeffreysPrior.__call__">
<tt class="descname">__call__</tt><big>(</big><em>theta</em><big>)</big><a class="reference internal" href="_modules/gptools/utils.html#JeffreysPrior.__call__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.utils.JeffreysPrior.__call__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="gptools.utils.JeffreysPrior.interval">
<tt class="descname">interval</tt><big>(</big><em>alpha</em><big>)</big><a class="reference internal" href="_modules/gptools/utils.html#JeffreysPrior.interval"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.utils.JeffreysPrior.interval" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="gptools.utils.LinearPrior">
<em class="property">class </em><tt class="descclassname">gptools.utils.</tt><tt class="descname">LinearPrior</tt><big>(</big><em>idx</em>, <em>bounds</em><big>)</big><a class="reference internal" href="_modules/gptools/utils.html#LinearPrior"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.utils.LinearPrior" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Class to implement a linear prior. Returns log-density.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>idx</strong> : int</p>
<blockquote>
<div><p>The index this prior applies to.</p>
</div></blockquote>
<p><strong>bounds</strong> : 2-tuple</p>
<blockquote class="last">
<div><p>The bounds for the parameter this prior corresponds to: (lb, ub).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="gptools.utils.LinearPrior.__call__">
<tt class="descname">__call__</tt><big>(</big><em>theta</em><big>)</big><a class="reference internal" href="_modules/gptools/utils.html#LinearPrior.__call__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.utils.LinearPrior.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the log-density of the uniform prior.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>theta</strong> : array-like, or float</p>
<blockquote>
<div><p>Value of values of the hyperparameter.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>f</strong> : <tt class="xref py py-class docutils literal"><span class="pre">Array</span></tt> or float</p>
<blockquote class="last">
<div><p>Returns log(2/(b-a)^2) + log(b-theta) if theta is in bounds, -inf
if theta is out of bounds.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gptools.utils.LinearPrior.interval">
<tt class="descname">interval</tt><big>(</big><em>alpha</em><big>)</big><a class="reference internal" href="_modules/gptools/utils.html#LinearPrior.interval"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.utils.LinearPrior.interval" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="gptools.utils.UniformPrior">
<em class="property">class </em><tt class="descclassname">gptools.utils.</tt><tt class="descname">UniformPrior</tt><big>(</big><em>idx</em>, <em>bounds</em><big>)</big><a class="reference internal" href="_modules/gptools/utils.html#UniformPrior"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.utils.UniformPrior" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Class to implement a uniform prior. Returns log-density.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>idx</strong> : int</p>
<blockquote>
<div><p>The index this prior applies to.</p>
</div></blockquote>
<p><strong>bounds</strong> : 2-tuple</p>
<blockquote class="last">
<div><p>The bounds for the parameter this prior corresponds to: (lb, ub).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="gptools.utils.UniformPrior.__call__">
<tt class="descname">__call__</tt><big>(</big><em>theta</em><big>)</big><a class="reference internal" href="_modules/gptools/utils.html#UniformPrior.__call__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.utils.UniformPrior.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the log-PDF of the uniform prior.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>theta</strong> : array-like</p>
<blockquote>
<div><p>Values of the hyperparameters.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>f</strong> : <tt class="xref py py-class docutils literal"><span class="pre">Array</span></tt> or float</p>
<blockquote class="last">
<div><p>Returns -log(ub - lb) if theta is scalar and in bounds, double_min
if theta is scalar and out of bounds and an appropriately-shaped
array if theta is array-like.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gptools.utils.UniformPrior.interval">
<tt class="descname">interval</tt><big>(</big><em>alpha</em><big>)</big><a class="reference internal" href="_modules/gptools/utils.html#UniformPrior.interval"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.utils.UniformPrior.interval" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="gptools.utils.UniformPrior.rvs">
<tt class="descname">rvs</tt><big>(</big><em>size=None</em><big>)</big><a class="reference internal" href="_modules/gptools/utils.html#UniformPrior.rvs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.utils.UniformPrior.rvs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="gptools.utils.JointPrior">
<em class="property">class </em><tt class="descclassname">gptools.utils.</tt><tt class="descname">JointPrior</tt><a class="reference internal" href="_modules/gptools/utils.html#JointPrior"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.utils.JointPrior" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Abstract class for objects implementing joint priors over hyperparameters.</p>
<dl class="method">
<dt id="gptools.utils.JointPrior.__call__">
<tt class="descname">__call__</tt><big>(</big><em>theta</em><big>)</big><a class="reference internal" href="_modules/gptools/utils.html#JointPrior.__call__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.utils.JointPrior.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the prior log-PDF at the given values of the hyperparameters, theta.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>theta</strong> : array-like, (<cite>num_params</cite>,)</p>
<blockquote class="last">
<div><p>The hyperparameters to evaluate the log-PDF at.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gptools.utils.JointPrior.random_draw">
<tt class="descname">random_draw</tt><big>(</big><em>size=None</em><big>)</big><a class="reference internal" href="_modules/gptools/utils.html#JointPrior.random_draw"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.utils.JointPrior.random_draw" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw random samples of the hyperparameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>size</strong> : None, int or array-like, optional</p>
<blockquote class="last">
<div><p>The number/shape of samples to draw. If None, only one sample is
returned. Default is None.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gptools.utils.JointPrior.__mul__">
<tt class="descname">__mul__</tt><big>(</big><em>other</em><big>)</big><a class="reference internal" href="_modules/gptools/utils.html#JointPrior.__mul__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.utils.JointPrior.__mul__" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply two <a class="reference internal" href="#gptools.utils.JointPrior" title="gptools.utils.JointPrior"><tt class="xref py py-class docutils literal"><span class="pre">JointPrior</span></tt></a> instances together.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="gptools.utils.CombinedBounds">
<em class="property">class </em><tt class="descclassname">gptools.utils.</tt><tt class="descname">CombinedBounds</tt><big>(</big><em>l1</em>, <em>l2</em><big>)</big><a class="reference internal" href="_modules/gptools/utils.html#CombinedBounds"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.utils.CombinedBounds" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Object to support reassignment of the bounds from a combined prior.</p>
<dl class="method">
<dt id="gptools.utils.CombinedBounds.__getitem__">
<tt class="descname">__getitem__</tt><big>(</big><em>pos</em><big>)</big><a class="reference internal" href="_modules/gptools/utils.html#CombinedBounds.__getitem__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.utils.CombinedBounds.__getitem__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="gptools.utils.CombinedBounds.__setitem__">
<tt class="descname">__setitem__</tt><big>(</big><em>pos</em>, <em>value</em><big>)</big><a class="reference internal" href="_modules/gptools/utils.html#CombinedBounds.__setitem__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.utils.CombinedBounds.__setitem__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="gptools.utils.CombinedBounds.__len__">
<tt class="descname">__len__</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/gptools/utils.html#CombinedBounds.__len__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.utils.CombinedBounds.__len__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="gptools.utils.CombinedBounds.__invert__">
<tt class="descname">__invert__</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/gptools/utils.html#CombinedBounds.__invert__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.utils.CombinedBounds.__invert__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="gptools.utils.MaskedBounds">
<em class="property">class </em><tt class="descclassname">gptools.utils.</tt><tt class="descname">MaskedBounds</tt><big>(</big><em>a</em>, <em>m</em><big>)</big><a class="reference internal" href="_modules/gptools/utils.html#MaskedBounds"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.utils.MaskedBounds" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Object to support reassignment of free parameter bounds.</p>
<dl class="method">
<dt id="gptools.utils.MaskedBounds.__getitem__">
<tt class="descname">__getitem__</tt><big>(</big><em>pos</em><big>)</big><a class="reference internal" href="_modules/gptools/utils.html#MaskedBounds.__getitem__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.utils.MaskedBounds.__getitem__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="gptools.utils.MaskedBounds.__setitem__">
<tt class="descname">__setitem__</tt><big>(</big><em>pos</em>, <em>value</em><big>)</big><a class="reference internal" href="_modules/gptools/utils.html#MaskedBounds.__setitem__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.utils.MaskedBounds.__setitem__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="gptools.utils.MaskedBounds.__len__">
<tt class="descname">__len__</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/gptools/utils.html#MaskedBounds.__len__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.utils.MaskedBounds.__len__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="gptools.utils.ProductJointPrior">
<em class="property">class </em><tt class="descclassname">gptools.utils.</tt><tt class="descname">ProductJointPrior</tt><big>(</big><em>p1</em>, <em>p2</em><big>)</big><a class="reference internal" href="_modules/gptools/utils.html#ProductJointPrior"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.utils.ProductJointPrior" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#gptools.utils.JointPrior" title="gptools.utils.JointPrior"><tt class="xref py py-class docutils literal"><span class="pre">gptools.utils.JointPrior</span></tt></a></p>
<p>Product of two independent priors.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>p1, p2: :py:class:`JointPrior` instances</strong> :</p>
<blockquote class="last">
<div><p>The two priors to merge.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="gptools.utils.ProductJointPrior.bounds">
<tt class="descname">bounds</tt><a class="reference internal" href="_modules/gptools/utils.html#ProductJointPrior.bounds"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.utils.ProductJointPrior.bounds" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="gptools.utils.ProductJointPrior.__call__">
<tt class="descname">__call__</tt><big>(</big><em>theta</em><big>)</big><a class="reference internal" href="_modules/gptools/utils.html#ProductJointPrior.__call__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.utils.ProductJointPrior.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the prior log-PDF at the given values of the hyperparameters, theta.</p>
<p>The log-PDFs of the two priors are summed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>theta</strong> : array-like, (<cite>num_params</cite>,)</p>
<blockquote class="last">
<div><p>The hyperparameters to evaluate the log-PDF at.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gptools.utils.ProductJointPrior.random_draw">
<tt class="descname">random_draw</tt><big>(</big><em>size=None</em><big>)</big><a class="reference internal" href="_modules/gptools/utils.html#ProductJointPrior.random_draw"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.utils.ProductJointPrior.random_draw" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw random samples of the hyperparameters.</p>
<p>The outputs of the two priors are stacked vertically.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>size</strong> : None, int or array-like, optional</p>
<blockquote class="last">
<div><p>The number/shape of samples to draw. If None, only one sample is
returned. Default is None.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="gptools.utils.UniformJointPrior">
<em class="property">class </em><tt class="descclassname">gptools.utils.</tt><tt class="descname">UniformJointPrior</tt><big>(</big><em>bounds</em><big>)</big><a class="reference internal" href="_modules/gptools/utils.html#UniformJointPrior"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.utils.UniformJointPrior" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#gptools.utils.JointPrior" title="gptools.utils.JointPrior"><tt class="xref py py-class docutils literal"><span class="pre">gptools.utils.JointPrior</span></tt></a></p>
<p>Uniform prior over the specified bounds.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>bounds</strong> : list of tuples, (<cite>num_params</cite>,)</p>
<blockquote class="last">
<div><p>The bounds for each of the random variables.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="gptools.utils.UniformJointPrior.__call__">
<tt class="descname">__call__</tt><big>(</big><em>theta</em><big>)</big><a class="reference internal" href="_modules/gptools/utils.html#UniformJointPrior.__call__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.utils.UniformJointPrior.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the prior log-PDF at the given values of the hyperparameters, theta.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>theta</strong> : array-like, (<cite>num_params</cite>,)</p>
<blockquote class="last">
<div><p>The hyperparameters to evaluate the log-PDF at.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gptools.utils.UniformJointPrior.random_draw">
<tt class="descname">random_draw</tt><big>(</big><em>size=None</em><big>)</big><a class="reference internal" href="_modules/gptools/utils.html#UniformJointPrior.random_draw"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.utils.UniformJointPrior.random_draw" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw random samples of the hyperparameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>size</strong> : None, int or array-like, optional</p>
<blockquote class="last">
<div><p>The number/shape of samples to draw. If None, only one sample is
returned. Default is None.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="gptools.utils.CoreEdgeJointPrior">
<em class="property">class </em><tt class="descclassname">gptools.utils.</tt><tt class="descname">CoreEdgeJointPrior</tt><big>(</big><em>bounds</em><big>)</big><a class="reference internal" href="_modules/gptools/utils.html#CoreEdgeJointPrior"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.utils.CoreEdgeJointPrior" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#gptools.utils.UniformJointPrior" title="gptools.utils.UniformJointPrior"><tt class="xref py py-class docutils literal"><span class="pre">gptools.utils.UniformJointPrior</span></tt></a></p>
<p>Prior for use with Gibbs kernel warping functions with an inequality constraint between the core and edge length scales.</p>
<dl class="method">
<dt id="gptools.utils.CoreEdgeJointPrior.__call__">
<tt class="descname">__call__</tt><big>(</big><em>theta</em><big>)</big><a class="reference internal" href="_modules/gptools/utils.html#CoreEdgeJointPrior.__call__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.utils.CoreEdgeJointPrior.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the prior log-PDF at the given values of the hyperparameters, theta.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>theta</strong> : array-like, (<cite>num_params</cite>,)</p>
<blockquote class="last">
<div><p>The hyperparameters to evaluate the log-PDF at.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gptools.utils.CoreEdgeJointPrior.random_draw">
<tt class="descname">random_draw</tt><big>(</big><em>size=None</em><big>)</big><a class="reference internal" href="_modules/gptools/utils.html#CoreEdgeJointPrior.random_draw"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.utils.CoreEdgeJointPrior.random_draw" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw random samples of the hyperparameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>size</strong> : None, int or array-like, optional</p>
<blockquote class="last">
<div><p>The number/shape of samples to draw. If None, only one sample is
returned. Default is None.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="gptools.utils.CoreMidEdgeJointPrior">
<em class="property">class </em><tt class="descclassname">gptools.utils.</tt><tt class="descname">CoreMidEdgeJointPrior</tt><big>(</big><em>bounds</em><big>)</big><a class="reference internal" href="_modules/gptools/utils.html#CoreMidEdgeJointPrior"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.utils.CoreMidEdgeJointPrior" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#gptools.utils.UniformJointPrior" title="gptools.utils.UniformJointPrior"><tt class="xref py py-class docutils literal"><span class="pre">gptools.utils.UniformJointPrior</span></tt></a></p>
<p>Prior for use with Gibbs kernel warping functions with an inequality constraint between the core, mid and edge length scales and the core-mid and mid-edge joins.</p>
<dl class="method">
<dt id="gptools.utils.CoreMidEdgeJointPrior.__call__">
<tt class="descname">__call__</tt><big>(</big><em>theta</em><big>)</big><a class="reference internal" href="_modules/gptools/utils.html#CoreMidEdgeJointPrior.__call__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.utils.CoreMidEdgeJointPrior.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the prior log-PDF at the given values of the hyperparameters, theta.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>theta</strong> : array-like, (<cite>num_params</cite>,)</p>
<blockquote class="last">
<div><p>The hyperparameters to evaluate the log-PDF at.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gptools.utils.CoreMidEdgeJointPrior.random_draw">
<tt class="descname">random_draw</tt><big>(</big><em>size=None</em><big>)</big><a class="reference internal" href="_modules/gptools/utils.html#CoreMidEdgeJointPrior.random_draw"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.utils.CoreMidEdgeJointPrior.random_draw" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw random samples of the hyperparameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>size</strong> : None, int or array-like, optional</p>
<blockquote class="last">
<div><p>The number/shape of samples to draw. If None, only one sample is
returned. Default is None.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="gptools.utils.IndependentJointPrior">
<em class="property">class </em><tt class="descclassname">gptools.utils.</tt><tt class="descname">IndependentJointPrior</tt><big>(</big><em>univariate_priors</em><big>)</big><a class="reference internal" href="_modules/gptools/utils.html#IndependentJointPrior"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.utils.IndependentJointPrior" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#gptools.utils.JointPrior" title="gptools.utils.JointPrior"><tt class="xref py py-class docutils literal"><span class="pre">gptools.utils.JointPrior</span></tt></a></p>
<p>Joint prior for which each hyperparameter is independent.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>univariate_priors</strong> : list of callables or rv_frozen, (<cite>num_params</cite>,)</p>
<blockquote class="last">
<div><p>The univariate priors for each hyperparameter. Entries in this list
can either be a callable that takes as an argument the entire list of
hyperparameters or a frozen instance of a distribution from
<tt class="xref py py-mod docutils literal"><span class="pre">scipy.stats</span></tt>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="gptools.utils.IndependentJointPrior.__call__">
<tt class="descname">__call__</tt><big>(</big><em>theta</em><big>)</big><a class="reference internal" href="_modules/gptools/utils.html#IndependentJointPrior.__call__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.utils.IndependentJointPrior.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the prior log-PDF at the given values of the hyperparameters, theta.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>theta</strong> : array-like, (<cite>num_params</cite>,)</p>
<blockquote class="last">
<div><p>The hyperparameters to evaluate the log-PDF at.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="gptools.utils.IndependentJointPrior.bounds">
<tt class="descname">bounds</tt><a class="reference internal" href="_modules/gptools/utils.html#IndependentJointPrior.bounds"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.utils.IndependentJointPrior.bounds" title="Permalink to this definition">¶</a></dt>
<dd><p>The bounds of the random variable.</p>
</dd></dl>

<dl class="method">
<dt id="gptools.utils.IndependentJointPrior.random_draw">
<tt class="descname">random_draw</tt><big>(</big><em>size=None</em><big>)</big><a class="reference internal" href="_modules/gptools/utils.html#IndependentJointPrior.random_draw"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.utils.IndependentJointPrior.random_draw" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw random samples of the hyperparameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>size</strong> : None, int or array-like, optional</p>
<blockquote class="last">
<div><p>The number/shape of samples to draw. If None, only one sample is
returned. Default is None.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="gptools.utils.NormalJointPrior">
<em class="property">class </em><tt class="descclassname">gptools.utils.</tt><tt class="descname">NormalJointPrior</tt><big>(</big><em>mu</em>, <em>sigma</em><big>)</big><a class="reference internal" href="_modules/gptools/utils.html#NormalJointPrior"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.utils.NormalJointPrior" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#gptools.utils.JointPrior" title="gptools.utils.JointPrior"><tt class="xref py py-class docutils literal"><span class="pre">gptools.utils.JointPrior</span></tt></a></p>
<p>Joint prior for which each hyperparameter has a normal prior with fixed hyper-hyperparameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>mu</strong> : list of float, same size as <cite>sigma</cite></p>
<blockquote>
<div><p>Means of the hyperparameters.</p>
</div></blockquote>
<p><strong>sigma</strong> : list of float</p>
<blockquote class="last">
<div><p>Standard deviations of the hyperparameters.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="gptools.utils.NormalJointPrior.__call__">
<tt class="descname">__call__</tt><big>(</big><em>theta</em><big>)</big><a class="reference internal" href="_modules/gptools/utils.html#NormalJointPrior.__call__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.utils.NormalJointPrior.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the prior log-PDF at the given values of the hyperparameters, theta.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>theta</strong> : array-like, (<cite>num_params</cite>,)</p>
<blockquote class="last">
<div><p>The hyperparameters to evaluate the log-PDF at.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="gptools.utils.NormalJointPrior.bounds">
<tt class="descname">bounds</tt><a class="reference internal" href="_modules/gptools/utils.html#NormalJointPrior.bounds"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.utils.NormalJointPrior.bounds" title="Permalink to this definition">¶</a></dt>
<dd><p>The bounds of the random variable.</p>
</dd></dl>

<dl class="method">
<dt id="gptools.utils.NormalJointPrior.random_draw">
<tt class="descname">random_draw</tt><big>(</big><em>size=None</em><big>)</big><a class="reference internal" href="_modules/gptools/utils.html#NormalJointPrior.random_draw"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.utils.NormalJointPrior.random_draw" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw random samples of the hyperparameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>size</strong> : None, int or array-like, optional</p>
<blockquote class="last">
<div><p>The number/shape of samples to draw. If None, only one sample is
returned. Default is None.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="gptools.utils.LogNormalJointPrior">
<em class="property">class </em><tt class="descclassname">gptools.utils.</tt><tt class="descname">LogNormalJointPrior</tt><big>(</big><em>mu</em>, <em>sigma</em><big>)</big><a class="reference internal" href="_modules/gptools/utils.html#LogNormalJointPrior"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.utils.LogNormalJointPrior" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#gptools.utils.JointPrior" title="gptools.utils.JointPrior"><tt class="xref py py-class docutils literal"><span class="pre">gptools.utils.JointPrior</span></tt></a></p>
<p>Joint prior for which each hyperparameter has a log-normal prior with fixed hyper-hyperparameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>mu</strong> : list of float, same size as <cite>sigma</cite></p>
<blockquote>
<div><p>Means of the logarithms of the hyperparameters.</p>
</div></blockquote>
<p><strong>sigma</strong> : list of float</p>
<blockquote class="last">
<div><p>Standard deviations of the logarithms of the hyperparameters.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="gptools.utils.LogNormalJointPrior.__call__">
<tt class="descname">__call__</tt><big>(</big><em>theta</em><big>)</big><a class="reference internal" href="_modules/gptools/utils.html#LogNormalJointPrior.__call__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.utils.LogNormalJointPrior.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the prior log-PDF at the given values of the hyperparameters, theta.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>theta</strong> : array-like, (<cite>num_params</cite>,)</p>
<blockquote class="last">
<div><p>The hyperparameters to evaluate the log-PDF at.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="gptools.utils.LogNormalJointPrior.bounds">
<tt class="descname">bounds</tt><a class="reference internal" href="_modules/gptools/utils.html#LogNormalJointPrior.bounds"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.utils.LogNormalJointPrior.bounds" title="Permalink to this definition">¶</a></dt>
<dd><p>The bounds of the random variable.</p>
</dd></dl>

<dl class="method">
<dt id="gptools.utils.LogNormalJointPrior.random_draw">
<tt class="descname">random_draw</tt><big>(</big><em>size=None</em><big>)</big><a class="reference internal" href="_modules/gptools/utils.html#LogNormalJointPrior.random_draw"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.utils.LogNormalJointPrior.random_draw" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw random samples of the hyperparameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>size</strong> : None, int or array-like, optional</p>
<blockquote class="last">
<div><p>The number/shape of samples to draw. If None, only one sample is
returned. Default is None.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="gptools.utils.GammaJointPrior">
<em class="property">class </em><tt class="descclassname">gptools.utils.</tt><tt class="descname">GammaJointPrior</tt><big>(</big><em>a</em>, <em>b</em><big>)</big><a class="reference internal" href="_modules/gptools/utils.html#GammaJointPrior"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.utils.GammaJointPrior" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#gptools.utils.JointPrior" title="gptools.utils.JointPrior"><tt class="xref py py-class docutils literal"><span class="pre">gptools.utils.JointPrior</span></tt></a></p>
<p>Joint prior for which each hyperparameter has a gamma prior with fixed hyper-hyperparameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>a</strong> : list of float, same size as <cite>b</cite></p>
<blockquote>
<div><p>Shape parameters.</p>
</div></blockquote>
<p><strong>b</strong> : list of float</p>
<blockquote class="last">
<div><p>Rate parameters.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="gptools.utils.GammaJointPrior.__call__">
<tt class="descname">__call__</tt><big>(</big><em>theta</em><big>)</big><a class="reference internal" href="_modules/gptools/utils.html#GammaJointPrior.__call__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.utils.GammaJointPrior.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the prior log-PDF at the given values of the hyperparameters, theta.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>theta</strong> : array-like, (<cite>num_params</cite>,)</p>
<blockquote class="last">
<div><p>The hyperparameters to evaluate the log-PDF at.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="gptools.utils.GammaJointPrior.bounds">
<tt class="descname">bounds</tt><a class="reference internal" href="_modules/gptools/utils.html#GammaJointPrior.bounds"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.utils.GammaJointPrior.bounds" title="Permalink to this definition">¶</a></dt>
<dd><p>The bounds of the random variable.</p>
</dd></dl>

<dl class="method">
<dt id="gptools.utils.GammaJointPrior.random_draw">
<tt class="descname">random_draw</tt><big>(</big><em>size=None</em><big>)</big><a class="reference internal" href="_modules/gptools/utils.html#GammaJointPrior.random_draw"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.utils.GammaJointPrior.random_draw" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw random samples of the hyperparameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>size</strong> : None, int or array-like, optional</p>
<blockquote class="last">
<div><p>The number/shape of samples to draw. If None, only one sample is
returned. Default is None.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="gptools.utils.wrap_fmin_slsqp">
<tt class="descclassname">gptools.utils.</tt><tt class="descname">wrap_fmin_slsqp</tt><big>(</big><em>fun</em>, <em>guess</em>, <em>opt_kwargs={}</em><big>)</big><a class="reference internal" href="_modules/gptools/utils.html#wrap_fmin_slsqp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.utils.wrap_fmin_slsqp" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper for <tt class="xref py py-func docutils literal"><span class="pre">fmin_slsqp()</span></tt> to allow it to be called with <tt class="xref py py-func docutils literal"><span class="pre">minimize()</span></tt>-like syntax.</p>
<p>This is included to enable the code to run with <tt class="xref py py-mod docutils literal"><span class="pre">scipy</span></tt> versions
older than 0.11.0.</p>
<p>Accepts <cite>opt_kwargs</cite> in the same format as used by
<tt class="xref py py-func docutils literal"><span class="pre">scipy.optimize.minimize()</span></tt>, with the additional precondition
that the keyword <cite>method</cite> has already been removed by the calling code.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fun</strong> : callable</p>
<blockquote>
<div><p>The function to minimize.</p>
</div></blockquote>
<p><strong>guess</strong> : sequence</p>
<blockquote>
<div><p>The initial guess for the parameters.</p>
</div></blockquote>
<p><strong>opt_kwargs</strong> : dict, optional</p>
<blockquote>
<div><p>Dictionary of extra keywords to pass to
<tt class="xref py py-func docutils literal"><span class="pre">scipy.optimize.minimize()</span></tt>. Refer to that function&#8217;s
docstring for valid options. The keywords &#8216;jac&#8217;, &#8216;hess&#8217; and &#8216;hessp&#8217;
are ignored. Note that if you were planning to use <cite>jac</cite> = True
(i.e., optimization function returns Jacobian) and have set
<cite>args</cite> = (True,) to tell <tt class="xref py py-meth docutils literal"><span class="pre">update_hyperparameters()</span></tt> to
compute and return the Jacobian this may cause unexpected behavior.
Default is: {}.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>Result</strong> : namedtuple</p>
<blockquote>
<div><p><tt class="xref py py-class docutils literal"><span class="pre">namedtuple</span></tt> that mimics the fields of the
<tt class="xref py py-class docutils literal"><span class="pre">Result</span></tt> object returned by
<tt class="xref py py-func docutils literal"><span class="pre">scipy.optimize.minimize()</span></tt>. Has the following fields:</p>
<table border="1" class="docutils">
<colgroup>
<col width="7%" />
<col width="7%" />
<col width="86%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>status</td>
<td>int</td>
<td>Code indicating the exit mode of the optimizer (<cite>imode</cite> from <tt class="xref py py-func docutils literal"><span class="pre">fmin_slsqp()</span></tt>)</td>
</tr>
<tr class="row-even"><td>success</td>
<td>bool</td>
<td>Boolean indicating whether or not the optimizer thinks a minimum was found.</td>
</tr>
<tr class="row-odd"><td>fun</td>
<td>float</td>
<td>Value of the optimized function (-1*LL).</td>
</tr>
<tr class="row-even"><td>x</td>
<td>ndarray</td>
<td>Optimal values of the hyperparameters.</td>
</tr>
<tr class="row-odd"><td>message</td>
<td>str</td>
<td>String describing the exit state (<cite>smode</cite> from <tt class="xref py py-func docutils literal"><span class="pre">fmin_slsqp()</span></tt>)</td>
</tr>
<tr class="row-even"><td>nit</td>
<td>int</td>
<td>Number of iterations.</td>
</tr>
</tbody>
</table>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>ValueError</strong> :</p>
<blockquote class="last">
<div><p>Invalid constraint type in <cite>constraints</cite>. (See documentation for <tt class="xref py py-func docutils literal"><span class="pre">scipy.optimize.minimize()</span></tt>.)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="gptools.utils.incomplete_bell_poly">
<tt class="descclassname">gptools.utils.</tt><tt class="descname">incomplete_bell_poly</tt><big>(</big><em>n</em>, <em>k</em>, <em>x</em><big>)</big><a class="reference internal" href="_modules/gptools/utils.html#incomplete_bell_poly"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.utils.incomplete_bell_poly" title="Permalink to this definition">¶</a></dt>
<dd><p>Recursive evaluation of the incomplete Bell polynomial <img class="math" src="_images/math/408f3fa0d82c63aec59918bb42ac86e25cf127ff.png" alt="B_{n, k}(x)"/>.</p>
<p>Evaluates the incomplete Bell polynomial <img class="math" src="_images/math/01f9f21d2fed895877f5ea73c001d0cc9863017f.png" alt="B_{n, k}(x_1, x_2, \dots, x_{n-k+1})"/>,
also known as the partial Bell polynomial or the Bell polynomial of the
second kind. This polynomial is useful in the evaluation of (the univariate)
Faa di Bruno&#8217;s formula which generalizes the chain rule to higher order
derivatives.</p>
<p>The implementation here is based on the implementation in:
<tt class="xref py py-func docutils literal"><span class="pre">sympy.functions.combinatorial.numbers.bell._bell_incomplete_poly()</span></tt>
Following that function&#8217;s documentation, the polynomial is computed
according to the recurrence formula:</p>
<div class="math">
<p><img src="_images/math/ea359128f87875759457beb3bd1f8c069472a539.png" alt="B_{n, k}(x_1, x_2, \dots, x_{n-k+1}) = \sum_{m=1}^{n-k+1}x_m\binom{n-1}{m-1}B_{n-m, k-1}(x_1, x_2, \dots, x_{n-m-k})"/></p>
</div><div class="line-block">
<div class="line">The end cases are:</div>
<div class="line"><img class="math" src="_images/math/d643062bed95d2150a4868d9431f10d97d8c3beb.png" alt="B_{0, 0} = 1"/></div>
<div class="line"><img class="math" src="_images/math/215038d81313101cfa03b22cafd563f4f4f7fe8c.png" alt="B_{n, 0} = 0"/> for <img class="math" src="_images/math/f2594e7c9c316df42db1f629e3e249daddce9a70.png" alt="n \ge 1"/></div>
<div class="line"><img class="math" src="_images/math/0fafb2719b4398fd7051ce54645e8f6607cc09d8.png" alt="B_{0, k} = 0"/> for <img class="math" src="_images/math/ad65a29fbbfecd7931e64c5dd83b7a1761f5969b.png" alt="k \ge 1"/></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>n</strong> : scalar int</p>
<blockquote>
<div><p>The first subscript of the polynomial.</p>
</div></blockquote>
<p><strong>k</strong> : scalar int</p>
<blockquote>
<div><p>The second subscript of the polynomial.</p>
</div></blockquote>
<p><strong>x</strong> : <tt class="xref py py-class docutils literal"><span class="pre">Array</span></tt> of floats, (<cite>p</cite>, <cite>n</cite> - <cite>k</cite> + 1)</p>
<blockquote>
<div><p><cite>p</cite> sets of <cite>n</cite> - <cite>k</cite> + 1 points to use as the arguments to
<img class="math" src="_images/math/a0a57cd24dcdb03b27af5fcf3cfcc411bd1e7857.png" alt="B_{n,k}"/>. The second dimension can be longer than
required, in which case the extra entries are silently ignored
(this facilitates recursion without needing to subset the array <cite>x</cite>).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>result</strong> : <tt class="xref py py-class docutils literal"><span class="pre">Array</span></tt>, (<cite>p</cite>,)</p>
<blockquote class="last">
<div><p>Incomplete Bell polynomial evaluated at the desired values.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="gptools.utils.generate_set_partition_strings">
<tt class="descclassname">gptools.utils.</tt><tt class="descname">generate_set_partition_strings</tt><big>(</big><em>n</em><big>)</big><a class="reference internal" href="_modules/gptools/utils.html#generate_set_partition_strings"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.utils.generate_set_partition_strings" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the restricted growth strings for all of the partitions of an <cite>n</cite>-member set.</p>
<p>Uses Algorithm H from page 416 of volume 4A of Knuth&#8217;s <cite>The Art of Computer
Programming</cite>. Returns the partitions in lexicographical order.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>n</strong> : scalar int, non-negative</p>
<blockquote>
<div><p>Number of (unique) elements in the set to be partitioned.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>partitions</strong> : list of <tt class="xref py py-class docutils literal"><span class="pre">Array</span></tt></p>
<blockquote class="last">
<div><p>List has a number of elements equal to the <cite>n</cite>-th Bell number (i.e.,
the number of partitions for a set of size <cite>n</cite>). Each element has
length <cite>n</cite>, the elements of which are the restricted growth strings
describing the partitions of the set. The strings are returned in
lexicographic order.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="gptools.utils.generate_set_partitions">
<tt class="descclassname">gptools.utils.</tt><tt class="descname">generate_set_partitions</tt><big>(</big><em>set_</em><big>)</big><a class="reference internal" href="_modules/gptools/utils.html#generate_set_partitions"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.utils.generate_set_partitions" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate all of the partitions of a set.</p>
<p>This is a helper function that utilizes the restricted growth strings from
<a class="reference internal" href="#gptools.utils.generate_set_partition_strings" title="gptools.utils.generate_set_partition_strings"><tt class="xref py py-func docutils literal"><span class="pre">generate_set_partition_strings()</span></tt></a>. The partitions are returned in
lexicographic order.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>set_</strong> : <tt class="xref py py-class docutils literal"><span class="pre">Array</span></tt> or other Array-like, (<cite>m</cite>,)</p>
<blockquote>
<div><p>The set to find the partitions of.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>partitions</strong> : list of lists of <tt class="xref py py-class docutils literal"><span class="pre">Array</span></tt></p>
<blockquote class="last">
<div><p>The number of elements in the outer list is equal to the number of
partitions, which is the len(<cite>m</cite>)^th Bell number. Each of the inner lists
corresponds to a single possible partition. The length of an inner list
is therefore equal to the number of blocks. Each of the arrays in an
inner list is hence a block.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="gptools.utils.powerset">
<tt class="descclassname">gptools.utils.</tt><tt class="descname">powerset</tt><big>(</big><em>[1,2,3]) --&gt; () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3</em><big>)</big><a class="reference internal" href="_modules/gptools/utils.html#powerset"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.utils.powerset" title="Permalink to this definition">¶</a></dt>
<dd><p>From itertools documentation.</p>
</dd></dl>

<dl class="function">
<dt id="gptools.utils.unique_rows">
<tt class="descclassname">gptools.utils.</tt><tt class="descname">unique_rows</tt><big>(</big><em>arr</em>, <em>return_index=False</em>, <em>return_inverse=False</em><big>)</big><a class="reference internal" href="_modules/gptools/utils.html#unique_rows"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.utils.unique_rows" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a copy of arr with duplicate rows removed.</p>
<p>From Stackoverflow &#8220;Find unique rows in numpy.array.&#8221;</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>arr</strong> : <tt class="xref py py-class docutils literal"><span class="pre">Array</span></tt>, (<cite>m</cite>, <cite>n</cite>)</p>
<blockquote>
<div><p>The array to find the unique rows of.</p>
</div></blockquote>
<p><strong>return_index</strong> : bool, optional</p>
<blockquote>
<div><p>If True, the indices of the unique rows in the array will also be
returned. I.e., unique = arr[idx]. Default is False (don&#8217;t return
indices).</p>
</div></blockquote>
<p><strong>return_inverse: bool, optional</strong> :</p>
<blockquote>
<div><p>If True, the indices in the unique array to reconstruct the original
array will also be returned. I.e., arr = unique[inv]. Default is False
(don&#8217;t return inverse).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>unique</strong> : <tt class="xref py py-class docutils literal"><span class="pre">Array</span></tt>, (<cite>p</cite>, <cite>n</cite>) where <cite>p</cite> &lt;= <cite>m</cite></p>
<blockquote class="last">
<div><p>The array <cite>arr</cite> with duplicate rows removed.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="gptools.utils.compute_stats">
<tt class="descclassname">gptools.utils.</tt><tt class="descname">compute_stats</tt><big>(</big><em>vals</em>, <em>check_nan=False</em>, <em>robust=False</em>, <em>axis=1</em>, <em>plot_QQ=False</em>, <em>bins=15</em>, <em>name=''</em><big>)</big><a class="reference internal" href="_modules/gptools/utils.html#compute_stats"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.utils.compute_stats" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the average statistics (mean, std dev) for the given values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>vals</strong> : array-like, (<cite>M</cite>, <cite>D</cite>)</p>
<blockquote>
<div><p>Values to compute the average statistics along the specified axis of.</p>
</div></blockquote>
<p><strong>check_nan</strong> : bool, optional</p>
<blockquote>
<div><p>Whether or not to check for (and exclude) NaN&#8217;s. Default is False (do
not attempt to handle NaN&#8217;s).</p>
</div></blockquote>
<p><strong>robust</strong> : bool, optional</p>
<blockquote>
<div><p>Whether or not to use robust estimators (median for mean, IQR for
standard deviation). Default is False (use non-robust estimators).</p>
</div></blockquote>
<p><strong>axis</strong> : int, optional</p>
<blockquote>
<div><p>Axis to compute the statistics along. Presently only supported if
<cite>robust</cite> is False. Default is 1.</p>
</div></blockquote>
<p><strong>plot_QQ</strong> : bool, optional</p>
<blockquote>
<div><p>Whether or not a QQ plot and histogram should be drawn for each channel.
Default is False (do not draw QQ plots).</p>
</div></blockquote>
<p><strong>bins</strong> : int, optional</p>
<blockquote>
<div><p>Number of bins to use when plotting histogram (for plot_QQ=True).
Default is 15</p>
</div></blockquote>
<p><strong>name</strong> : str, optional</p>
<blockquote>
<div><p>Name to put in the title of the QQ/histogram plot.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>mean</strong> : ndarray, (<cite>M</cite>,)</p>
<blockquote>
<div><p>Estimator for the mean of <cite>vals</cite>.</p>
</div></blockquote>
<p><strong>std</strong> : ndarray, (<cite>M</cite>,)</p>
<blockquote>
<div><p>Estimator for the standard deviation of <cite>vals</cite>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>NotImplementedError</strong> :</p>
<blockquote>
<div><p>If <cite>axis</cite> != 1 when <cite>robust</cite> is True.</p>
</div></blockquote>
<p><strong>NotImplementedError</strong> :</p>
<blockquote class="last">
<div><p>If <cite>plot_QQ</cite> is True.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="gptools.utils.univariate_envelope_plot">
<tt class="descclassname">gptools.utils.</tt><tt class="descname">univariate_envelope_plot</tt><big>(</big><em>x, mean, std, ax=None, base_alpha=0.375, envelopes=[1, 3], **kwargs</em><big>)</big><a class="reference internal" href="_modules/gptools/utils.html#univariate_envelope_plot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.utils.univariate_envelope_plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a plot of a mean curve with uncertainty envelopes.</p>
</dd></dl>

<dl class="function">
<dt id="gptools.utils.summarize_sampler">
<tt class="descclassname">gptools.utils.</tt><tt class="descname">summarize_sampler</tt><big>(</big><em>sampler</em>, <em>burn=0</em>, <em>thin=1</em>, <em>ci=0.95</em><big>)</big><a class="reference internal" href="_modules/gptools/utils.html#summarize_sampler"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.utils.summarize_sampler" title="Permalink to this definition">¶</a></dt>
<dd><p>Create summary statistics of the flattened chain of the sampler.</p>
<p>The confidence regions are computed from the quantiles of the data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>sampler</strong> : <tt class="xref py py-class docutils literal"><span class="pre">emcee.EnsembleSampler</span></tt> instance</p>
<blockquote>
<div><p>The sampler to summarize the chains of.</p>
</div></blockquote>
<p><strong>burn</strong> : int, optional</p>
<blockquote>
<div><p>The number of samples to burn from the beginning of the chain. Default
is 0 (no burn).</p>
</div></blockquote>
<p><strong>thin</strong> : int, optional</p>
<blockquote>
<div><p>The step size to thin with. Default is 1 (no thinning).</p>
</div></blockquote>
<p><strong>ci</strong> : float, optional</p>
<blockquote>
<div><p>A number between 0 and 1 indicating the confidence region to compute.
Default is 0.95 (return upper and lower bounds of the 95% confidence
interval).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>mean</strong> : array, (num_params,)</p>
<blockquote>
<div><p>Mean values of each of the parameters sampled.</p>
</div></blockquote>
<p><strong>ci_l</strong> : array, (num_params,)</p>
<blockquote>
<div><p>Lower bounds of the <cite>ci*100%</cite> confidence intervals.</p>
</div></blockquote>
<p><strong>ci_u</strong> : array, (num_params,)</p>
<blockquote class="last">
<div><p>Upper bounds of the <cite>ci*100%</cite> confidence intervals.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="gptools.utils.plot_sampler">
<tt class="descclassname">gptools.utils.</tt><tt class="descname">plot_sampler</tt><big>(</big><em>sampler</em>, <em>labels=None</em>, <em>burn=0</em>, <em>chain_mask=None</em><big>)</big><a class="reference internal" href="_modules/gptools/utils.html#plot_sampler"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#gptools.utils.plot_sampler" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the results of MCMC sampler (posterior and chains).</p>
<p>Loosely based on triangle.py.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>sampler</strong> : <tt class="xref py py-class docutils literal"><span class="pre">emcee.EnsembleSampler</span></tt> instance</p>
<blockquote>
<div><p>The sampler to plot the chains/marginals of.</p>
</div></blockquote>
<p><strong>labels</strong> : list of str, optional</p>
<blockquote>
<div><p>The labels to use for each of the free parameters. Default is to leave
the axes unlabeled.</p>
</div></blockquote>
<p><strong>burn</strong> : int, optional</p>
<blockquote>
<div><p>The number of samples to burn before making the marginal histograms.
Default is zero (use all samples).</p>
</div></blockquote>
<p><strong>chain_mask</strong> : (index) array</p>
<blockquote class="last">
<div><p>Mask identifying the chains to keep before plotting, in case there are
bad chains. Default is to use all chains.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-gptools">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-gptools" title="Permalink to this headline">¶</a></h2>
<p><a class="reference internal" href="#module-gptools" title="gptools"><tt class="xref py py-mod docutils literal"><span class="pre">gptools</span></tt></a> - Gaussian process regression with support for arbitrary derivatives</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">gptools package</a><ul>
<li><a class="reference internal" href="#subpackages">Subpackages</a></li>
<li><a class="reference internal" href="#submodules">Submodules</a></li>
<li><a class="reference internal" href="#module-gptools.error_handling">gptools.error_handling module</a></li>
<li><a class="reference internal" href="#module-gptools.gaussian_process">gptools.gaussian_process module</a></li>
<li><a class="reference internal" href="#module-gptools.gp_utils">gptools.gp_utils module</a></li>
<li><a class="reference internal" href="#module-gptools.mean">gptools.mean module</a></li>
<li><a class="reference internal" href="#module-gptools.utils">gptools.utils module</a></li>
<li><a class="reference internal" href="#module-gptools">Module contents</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="index.html"
                        title="previous chapter">gptools: Gaussian process regression with support for arbitrary derivatives</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="gptools.kernel.html"
                        title="next chapter">gptools.kernel package</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/gptools.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="np-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="gptools.kernel.html" title="gptools.kernel package"
             >next</a> |</li>
        <li class="right" >
          <a href="index.html" title="gptools: Gaussian process regression with support for arbitrary derivatives"
             >previous</a> |</li>
        <li><a href="index.html">gptools 0.2 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2014, Mark Chilenski.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.3.
    </div>
  </body>
</html>