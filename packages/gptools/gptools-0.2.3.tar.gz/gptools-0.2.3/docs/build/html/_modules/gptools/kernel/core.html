<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>gptools.kernel.core &mdash; gptools 0.2 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <link rel="top" title="gptools 0.2 documentation" href="../../../index.html" />
    <link rel="up" title="Module code" href="../../index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../../../np-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">gptools 0.2 documentation</a> &raquo;</li>
          <li><a href="../../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for gptools.kernel.core</h1><div class="highlight"><pre>
<span class="c"># Copyright 2014 Mark Chilenski</span>
<span class="c"># This program is distributed under the terms of the GNU General Purpose License (GPL).</span>
<span class="c"># Refer to http://www.gnu.org/licenses/gpl.txt</span>
<span class="c"># </span>
<span class="c"># This program is free software: you can redistribute it and/or modify</span>
<span class="c"># it under the terms of the GNU General Public License as published by</span>
<span class="c"># the Free Software Foundation, either version 3 of the License, or</span>
<span class="c"># (at your option) any later version.</span>
<span class="c"># </span>
<span class="c"># This program is distributed in the hope that it will be useful,</span>
<span class="c"># but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c"># GNU General Public License for more details.</span>
<span class="c"># </span>
<span class="c"># You should have received a copy of the GNU General Public License</span>
<span class="c"># along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>

<span class="sd">&quot;&quot;&quot;Core kernel classes: contains the base :py:class:`Kernel` class and helper subclasses.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">division</span>

<span class="kn">from</span> <span class="nn">..utils</span> <span class="kn">import</span> <span class="n">unique_rows</span><span class="p">,</span> <span class="n">generate_set_partitions</span><span class="p">,</span> <span class="n">UniformJointPrior</span><span class="p">,</span> \
                    <span class="n">ProductJointPrior</span><span class="p">,</span> <span class="n">IndependentJointPrior</span><span class="p">,</span> <span class="n">powerset</span><span class="p">,</span> <span class="n">MaskedBounds</span>
<span class="kn">from</span> <span class="nn">..error_handling</span> <span class="kn">import</span> <span class="n">GPArgumentError</span>

<span class="kn">import</span> <span class="nn">scipy</span>
<span class="kn">import</span> <span class="nn">scipy.special</span>
<span class="kn">import</span> <span class="nn">scipy.stats</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">mpmath</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">warnings</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;Could not import mpmath. ArbitraryKernel class will not work.&quot;</span><span class="p">,</span>
                  <span class="ne">ImportWarning</span><span class="p">)</span>
<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">import</span> <span class="nn">multiprocessing</span>

<div class="viewcode-block" id="Kernel"><a class="viewcode-back" href="../../../gptools.kernel.html#gptools.kernel.core.Kernel">[docs]</a><span class="k">class</span> <span class="nc">Kernel</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Covariance kernel base class. Not meant to be explicitly instantiated!</span>
<span class="sd">    </span>
<span class="sd">    Initialize the kernel with the given number of input dimensions.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    num_dim : positive int</span>
<span class="sd">        Number of dimensions of the input data. Must be consistent with the `X`</span>
<span class="sd">        and `Xstar` values passed to the :py:class:`~gptools.gaussian_process.GaussianProcess`</span>
<span class="sd">        you wish to use the covariance kernel with. Default is 1.</span>
<span class="sd">    num_params : Non-negative int</span>
<span class="sd">        Number of parameters in the model.</span>
<span class="sd">    initial_params : :py:class:`Array` or other Array-like, (`num_params`,), optional</span>
<span class="sd">        Initial values to set for the hyperparameters. Default is None, in</span>
<span class="sd">        which case 1 is used for the initial values.</span>
<span class="sd">    fixed_params : :py:class:`Array` or other Array-like of bool, (`num_params`,), optional</span>
<span class="sd">        Sets which hyperparameters are considered fixed when optimizing the log</span>
<span class="sd">        likelihood. A True entry corresponds to that element being</span>
<span class="sd">        fixed (where the element ordering is as defined in the class).</span>
<span class="sd">        Default value is None (no hyperparameters are fixed).</span>
<span class="sd">    param_bounds : list of 2-tuples (`num_params`,), optional</span>
<span class="sd">        List of bounds for each of the hyperparameters. Each 2-tuple is of the</span>
<span class="sd">        form (lower`, `upper`). If there is no bound in a given direction, it</span>
<span class="sd">        works best to set it to something big like 1e16. Default is (0.0, 1e16)</span>
<span class="sd">        for each hyperparameter. Note that this is overridden by the `hyperprior`</span>
<span class="sd">        keyword, if present.</span>
<span class="sd">    param_names : list of str (`num_params`,), optional</span>
<span class="sd">        List of labels for the hyperparameters. Default is all empty strings.</span>
<span class="sd">    enforce_bounds : bool, optional</span>
<span class="sd">        If True, an attempt to set a hyperparameter outside of its bounds will</span>
<span class="sd">        result in the hyperparameter being set right at its bound. If False,</span>
<span class="sd">        bounds are not enforced inside the kernel. Default is False (do not</span>
<span class="sd">        enforce bounds).</span>
<span class="sd">    hyperprior : :py:class:`JointPrior` instance or list, optional</span>
<span class="sd">        Joint prior distribution for all hyperparameters. Can either be given</span>
<span class="sd">        as a :py:class:`JointPrior` instance or a list of `num_params`</span>
<span class="sd">        callables or py:class:`rv_frozen` instances from :py:mod:`scipy.stats`,</span>
<span class="sd">        in which case a :py:class:`IndependentJointPrior` is constructed with</span>
<span class="sd">        these as the independent priors on each hyperparameter. Default is a</span>
<span class="sd">        uniform PDF on all hyperparameters.</span>
<span class="sd">    </span>
<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    num_params : int</span>
<span class="sd">        Number of parameters</span>
<span class="sd">    num_dim : int</span>
<span class="sd">        Number of dimensions</span>
<span class="sd">    params : :py:class:`Array` of float, (`num_params`,)</span>
<span class="sd">        Array of parameters.</span>
<span class="sd">    fixed_params : :py:class:`Array` of bool, (`num_params`,)</span>
<span class="sd">        Array of booleans indicated which parameters in params are fixed.</span>
<span class="sd">    param_names : list of str, (`num_params`,)</span>
<span class="sd">        List of the labels for the hyperparameters.</span>
<span class="sd">    hyperprior : :py:class:`JointPrior` instance</span>
<span class="sd">        Joint prior distribution for the hyperparameters.</span>
<span class="sd">    </span>
<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If `num_dim` is not a positive integer or the lengths of the input</span>
<span class="sd">        vectors are inconsistent.</span>
<span class="sd">        </span>
<span class="sd">    GPArgumentError</span>
<span class="sd">        if `fixed_params` is passed but `initial_params` is not.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_dim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_params</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">initial_params</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">fixed_params</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">param_bounds</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">param_names</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">enforce_bounds</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">hyperprior</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">num_params</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">num_params</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">long</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;num_params must be an integer &gt;= 0!&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_params</span> <span class="o">=</span> <span class="n">num_params</span>
        <span class="k">if</span> <span class="n">param_names</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">param_names</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_params</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">param_names</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_params</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;param_names must be a list of length num_params!&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span> <span class="o">=</span> <span class="n">param_names</span>
        
        <span class="k">if</span> <span class="n">num_dim</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">num_dim</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">long</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;num_dim must be an integer &gt; 0!&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_dim</span> <span class="o">=</span> <span class="n">num_dim</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">enforce_bounds</span> <span class="o">=</span> <span class="n">enforce_bounds</span>
        
        <span class="c"># Handle default case for initial parameter values -- set them all to 1.</span>
        <span class="k">if</span> <span class="n">initial_params</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c"># Only accept fixed_params if initial_params is given:</span>
            <span class="k">if</span> <span class="n">fixed_params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">GPArgumentError</span><span class="p">(</span><span class="s">&quot;Must pass explicit parameter values &quot;</span>
                                      <span class="s">&quot;if fixing parameters!&quot;</span><span class="p">)</span>
            <span class="n">initial_params</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">num_params</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">fixed_params</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_params</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">initial_params</span><span class="p">)</span> <span class="o">!=</span> <span class="n">num_params</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Length of initial_params must be equal to num_params!&quot;</span><span class="p">)</span>
            <span class="c"># Handle default case of fixed_params: no fixed parameters.</span>
            <span class="k">if</span> <span class="n">fixed_params</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">fixed_params</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_params</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fixed_params</span><span class="p">)</span> <span class="o">!=</span> <span class="n">num_params</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Length of fixed_params must be equal to num_params!&quot;</span><span class="p">)</span>
        
        <span class="c"># Handle default case for parameter bounds -- set them all to (0, 1e16):</span>
        <span class="k">if</span> <span class="n">param_bounds</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">param_bounds</span> <span class="o">=</span> <span class="n">num_params</span> <span class="o">*</span> <span class="p">[(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1e16</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">param_bounds</span><span class="p">)</span> <span class="o">!=</span> <span class="n">num_params</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Length of param_bounds must be equal to num_params!&quot;</span><span class="p">)</span>
        
        <span class="c"># Handle default case for hyperpriors -- set them all to be uniform:</span>
        <span class="k">if</span> <span class="n">hyperprior</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">hyperprior</span> <span class="o">=</span> <span class="n">UniformJointPrior</span><span class="p">(</span><span class="n">param_bounds</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="nb">iter</span><span class="p">(</span><span class="n">hyperprior</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">hyperprior</span><span class="p">)</span> <span class="o">!=</span> <span class="n">num_params</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;If hyperprior is a list its length must &quot;</span>
                                     <span class="s">&quot;be equal to num_params!&quot;</span><span class="p">)</span>
                <span class="n">hyperprior</span> <span class="o">=</span> <span class="n">IndependentJointPrior</span><span class="p">(</span><span class="n">hyperprior</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="k">pass</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">initial_params</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fixed_params</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">fixed_params</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hyperprior</span> <span class="o">=</span> <span class="n">hyperprior</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">param_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">hyperprior</span><span class="o">.</span><span class="n">bounds</span>
    
    <span class="nd">@param_bounds.setter</span>
<div class="viewcode-block" id="Kernel.param_bounds"><a class="viewcode-back" href="../../../gptools.kernel.html#gptools.kernel.core.Kernel.param_bounds">[docs]</a>    <span class="k">def</span> <span class="nf">param_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hyperprior</span><span class="o">.</span><span class="n">bounds</span> <span class="o">=</span> <span class="n">value</span>
    </div>
<div class="viewcode-block" id="Kernel.__call__"><a class="viewcode-back" href="../../../gptools.kernel.html#gptools.kernel.core.Kernel.__call__">[docs]</a>    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Xi</span><span class="p">,</span> <span class="n">Xj</span><span class="p">,</span> <span class="n">ni</span><span class="p">,</span> <span class="n">nj</span><span class="p">,</span> <span class="n">hyper_deriv</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">symmetric</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluate the covariance between points `Xi` and `Xj` with derivative order `ni`, `nj`.</span>
<span class="sd">        </span>
<span class="sd">        Note that this method only returns the covariance -- the hyperpriors</span>
<span class="sd">        and potentials stored in this kernel must be applied separately.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Xi : :py:class:`Matrix` or other Array-like, (`M`, `D`)</span>
<span class="sd">            `M` inputs with dimension `D`.</span>
<span class="sd">        Xj : :py:class:`Matrix` or other Array-like, (`M`, `D`)</span>
<span class="sd">            `M` inputs with dimension `D`.</span>
<span class="sd">        ni : :py:class:`Matrix` or other Array-like, (`M`, `D`)</span>
<span class="sd">            `M` derivative orders for set `i`.</span>
<span class="sd">        nj : :py:class:`Matrix` or other Array-like, (`M`, `D`)</span>
<span class="sd">            `M` derivative orders for set `j`.</span>
<span class="sd">        hyper_deriv : Non-negative int or None, optional</span>
<span class="sd">            The index of the hyperparameter to compute the first derivative</span>
<span class="sd">            with respect to. If None, no derivatives are taken. Default is None</span>
<span class="sd">            (no hyperparameter derivatives).</span>
<span class="sd">        symmetric : bool, optional</span>
<span class="sd">            Whether or not the input `Xi`, `Xj` are from a symmetric matrix.</span>
<span class="sd">            Default is False.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Kij : :py:class:`Array`, (`M`,)</span>
<span class="sd">            Covariances for each of the `M` `Xi`, `Xj` pairs.</span>
<span class="sd">        </span>
<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        THIS IS ONLY A METHOD STUB TO DEFINE THE NEEDED CALLING FINGERPRINT!</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&quot;This is an abstract method -- please use &quot;</span>
                                  <span class="s">&quot;one of the implementing subclasses!&quot;</span><span class="p">)</span>
    </div>
<div class="viewcode-block" id="Kernel.set_hyperparams"><a class="viewcode-back" href="../../../gptools.kernel.html#gptools.kernel.core.Kernel.set_hyperparams">[docs]</a>    <span class="k">def</span> <span class="nf">set_hyperparams</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_params</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sets the free hyperparameters to the new parameter values in new_params.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        new_params : :py:class:`Array` or other Array-like, (len(:py:attr:`self.params`),)</span>
<span class="sd">            New parameter values, ordered as dictated by the docstring for the</span>
<span class="sd">            class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_params</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">new_params</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_params</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">free_params</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">enforce_bounds</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">new_param</span><span class="p">,</span> <span class="n">bound</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_params</span><span class="p">)),</span> <span class="n">new_params</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">free_param_bounds</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">bound</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">new_param</span> <span class="o">&lt;</span> <span class="n">bound</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                        <span class="n">new_params</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">bound</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">elif</span> <span class="n">bound</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">new_param</span> <span class="o">&gt;</span> <span class="n">bound</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="n">new_params</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">bound</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">fixed_params</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_params</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Length of new_params must be </span><span class="si">%s</span><span class="s">!&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">free_params</span><span class="p">),))</span>
    </div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="Kernel.num_free_params"><a class="viewcode-back" href="../../../gptools.kernel.html#gptools.kernel.core.Kernel.num_free_params">[docs]</a>    <span class="k">def</span> <span class="nf">num_free_params</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the number of free parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">fixed_params</span><span class="p">)</span>
    </div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="Kernel.free_param_idxs"><a class="viewcode-back" href="../../../gptools.kernel.html#gptools.kernel.core.Kernel.free_param_idxs">[docs]</a>    <span class="k">def</span> <span class="nf">free_param_idxs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the indices of the free parameters in the main arrays of parameters, etc.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">scipy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_params</span><span class="p">)[</span><span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">fixed_params</span><span class="p">]</span>
    </div>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">free_params</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the values of the free hyperparameters.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        free_params : :py:class:`Array`</span>
<span class="sd">            Array of the free parameters, in order.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">MaskedBounds</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">free_param_idxs</span><span class="p">)</span>
    
    <span class="nd">@free_params.setter</span>
<div class="viewcode-block" id="Kernel.free_params"><a class="viewcode-back" href="../../../gptools.kernel.html#gptools.kernel.core.Kernel.free_params">[docs]</a>    <span class="k">def</span> <span class="nf">free_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">free_param_idxs</span><span class="p">]</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    </div>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">free_param_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the bounds of the free hyperparameters.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        free_param_bounds : :py:class:`Array`</span>
<span class="sd">            Array of the bounds of the free parameters, in order.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">MaskedBounds</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hyperprior</span><span class="o">.</span><span class="n">bounds</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">free_param_idxs</span><span class="p">)</span>
    
    <span class="nd">@free_param_bounds.setter</span>
<div class="viewcode-block" id="Kernel.free_param_bounds"><a class="viewcode-back" href="../../../gptools.kernel.html#gptools.kernel.core.Kernel.free_param_bounds">[docs]</a>    <span class="k">def</span> <span class="nf">free_param_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="c"># Need to use a loop since self.hyperprior.bounds is NOT guaranteed to support fancy indexing.</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">free_param_idxs</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hyperprior</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
    </div>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">free_param_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the names of the free hyperparameters.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        free_param_names : :py:class:`Array`</span>
<span class="sd">            Array of the names of the free parameters, in order.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">MaskedBounds</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">free_param_idxs</span><span class="p">)</span>
    
    <span class="nd">@free_param_names.setter</span>
<div class="viewcode-block" id="Kernel.free_param_names"><a class="viewcode-back" href="../../../gptools.kernel.html#gptools.kernel.core.Kernel.free_param_names">[docs]</a>    <span class="k">def</span> <span class="nf">free_param_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="c"># Cast to array in case it hasn&#39;t been done already:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">[</span><span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">fixed_params</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
    </div>
<div class="viewcode-block" id="Kernel.__add__"><a class="viewcode-back" href="../../../gptools.kernel.html#gptools.kernel.core.Kernel.__add__">[docs]</a>    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add two Kernels together.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : :py:class:`Kernel`</span>
<span class="sd">            Kernel to be added to this one.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sum : :py:class:`SumKernel`</span>
<span class="sd">            Instance representing the sum of the two kernels.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">SumKernel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
    </div>
<div class="viewcode-block" id="Kernel.__mul__"><a class="viewcode-back" href="../../../gptools.kernel.html#gptools.kernel.core.Kernel.__mul__">[docs]</a>    <span class="k">def</span> <span class="nf">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Multiply two Kernels together.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : :py:class:`Kernel`</span>
<span class="sd">            Kernel to be multiplied by this one.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        prod : :py:class:`ProductKernel`</span>
<span class="sd">            Instance representing the product of the two kernels.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">ProductKernel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
    </div>
    <span class="k">def</span> <span class="nf">_compute_r2l2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">return_l</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;Compute the anisotropic :math:`r^2/l^2` term for the given `tau`.</span>
<span class="sd">        </span>
<span class="sd">        Here, :math:`\tau=X_i-X_j` is the difference vector. Computes</span>
<span class="sd">        .. math::</span>
<span class="sd">            \frac{r^2}{l^2} = \sum_i\frac{\tau_i^2}{l_{i}^{2}}</span>
<span class="sd">        Assumes that the length parameters are the last `num_dim` elements of</span>
<span class="sd">        :py:attr:`self.params`.</span>
<span class="sd">        </span>
<span class="sd">        Where `l` and `tau` are both zero, that term is set to zero.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tau : :py:class:`Array`, (`M`, `D`)</span>
<span class="sd">            `M` inputs with dimension `D`.</span>
<span class="sd">        return_l : bool, optional</span>
<span class="sd">            Set to True to return a tuple of (`tau`, `l_mat`), where `l_mat`</span>
<span class="sd">            is the matrix of length scales to match the shape of `tau`. Default</span>
<span class="sd">            is False (only return `tau`).</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        r2l2 : :py:class:`Array`, (`M`,)</span>
<span class="sd">            Anisotropically scaled distances squared.</span>
<span class="sd">        l_mat : :py:class:`Array`, (`M`, `D`)</span>
<span class="sd">            The (`D`,) array of length scales repeated for each of the `M`</span>
<span class="sd">            inputs. Only returned if `return_l` is True.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">l_mat</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">num_dim</span><span class="p">:],</span> <span class="p">(</span><span class="n">tau</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">tau_over_l</span> <span class="o">=</span> <span class="n">tau</span> <span class="o">/</span> <span class="n">l_mat</span>
        <span class="n">tau_over_l</span><span class="p">[(</span><span class="n">tau</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">l_mat</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">r2l2</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">tau_over_l</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">return_l</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">r2l2</span><span class="p">,</span> <span class="n">l_mat</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">r2l2</span>
</div>
<div class="viewcode-block" id="BinaryKernel"><a class="viewcode-back" href="../../../gptools.kernel.html#gptools.kernel.core.BinaryKernel">[docs]</a><span class="k">class</span> <span class="nc">BinaryKernel</span><span class="p">(</span><span class="n">Kernel</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Abstract class for binary operations on kernels (addition, multiplication, etc.).</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    k1, k2 : :py:class:`Kernel` instances to be combined</span>
<span class="sd">    </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    `k1` and `k2` must have the same number of dimensions.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k1</span><span class="p">,</span> <span class="n">k2</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">k1</span><span class="p">,</span> <span class="n">Kernel</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">k2</span><span class="p">,</span> <span class="n">Kernel</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;Both arguments to BinaryKernel must be instances of &quot;</span>
                            <span class="s">&quot;type Kernel!&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">k1</span><span class="o">.</span><span class="n">num_dim</span> <span class="o">!=</span> <span class="n">k2</span><span class="o">.</span><span class="n">num_dim</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Only kernels having the same number of dimensions &quot;</span>
                             <span class="s">&quot;can be summed!&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k1</span> <span class="o">=</span> <span class="n">k1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k2</span> <span class="o">=</span> <span class="n">k2</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">_enforce_bounds</span> <span class="o">=</span> <span class="n">k1</span><span class="o">.</span><span class="n">enforce_bounds</span> <span class="ow">or</span> <span class="n">k2</span><span class="o">.</span><span class="n">enforce_bounds</span>
        
        <span class="nb">super</span><span class="p">(</span><span class="n">BinaryKernel</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">num_dim</span><span class="o">=</span><span class="n">k1</span><span class="o">.</span><span class="n">num_dim</span><span class="p">,</span>
                                           <span class="n">num_params</span><span class="o">=</span><span class="n">k1</span><span class="o">.</span><span class="n">num_params</span> <span class="o">+</span> <span class="n">k2</span><span class="o">.</span><span class="n">num_params</span><span class="p">,</span>
                                           <span class="n">initial_params</span><span class="o">=</span><span class="n">scipy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">k1</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">k2</span><span class="o">.</span><span class="n">params</span><span class="p">)),</span>
                                           <span class="n">fixed_params</span><span class="o">=</span><span class="n">scipy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">k1</span><span class="o">.</span><span class="n">fixed_params</span><span class="p">,</span> <span class="n">k2</span><span class="o">.</span><span class="n">fixed_params</span><span class="p">)),</span>
                                           <span class="n">param_names</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">k1</span><span class="o">.</span><span class="n">param_names</span><span class="p">)</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">k2</span><span class="o">.</span><span class="n">param_names</span><span class="p">),</span>
                                           <span class="n">hyperprior</span><span class="o">=</span><span class="n">k1</span><span class="o">.</span><span class="n">hyperprior</span> <span class="o">*</span> <span class="n">k2</span><span class="o">.</span><span class="n">hyperprior</span><span class="p">,</span>
                                           <span class="n">enforce_bounds</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_enforce_bounds</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">enforce_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Boolean indicating whether or not the kernel will explicitly enforce the bounds defined by the hyperprior.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_enforce_bounds</span>
    
    <span class="nd">@enforce_bounds.setter</span>
<div class="viewcode-block" id="BinaryKernel.enforce_bounds"><a class="viewcode-back" href="../../../gptools.kernel.html#gptools.kernel.core.BinaryKernel.enforce_bounds">[docs]</a>    <span class="k">def</span> <span class="nf">enforce_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set `enforce_bounds` for both of the kernels to a new value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_enforce_bounds</span> <span class="o">=</span> <span class="n">v</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k1</span><span class="o">.</span><span class="n">enforce_bounds</span> <span class="o">=</span> <span class="n">v</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k2</span><span class="o">.</span><span class="n">enforce_bounds</span> <span class="o">=</span> <span class="n">v</span>
    </div>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">fixed_params</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">scipy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">k1</span><span class="o">.</span><span class="n">fixed_params</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k2</span><span class="o">.</span><span class="n">fixed_params</span><span class="p">))</span>
    
    <span class="nd">@fixed_params.setter</span>
<div class="viewcode-block" id="BinaryKernel.fixed_params"><a class="viewcode-back" href="../../../gptools.kernel.html#gptools.kernel.core.BinaryKernel.fixed_params">[docs]</a>    <span class="k">def</span> <span class="nf">fixed_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k1</span><span class="o">.</span><span class="n">fixed_params</span> <span class="o">=</span> <span class="n">v</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">k1</span><span class="o">.</span><span class="n">num_params</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k2</span><span class="o">.</span><span class="n">fixed_params</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">k1</span><span class="o">.</span><span class="n">num_params</span><span class="p">:]</span>
    </div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="BinaryKernel.free_param_bounds"><a class="viewcode-back" href="../../../gptools.kernel.html#gptools.kernel.core.BinaryKernel.free_param_bounds">[docs]</a>    <span class="k">def</span> <span class="nf">free_param_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the bounds of the free hyperparameters.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        free_param_bounds : :py:class:`Array`</span>
<span class="sd">            Array of the bounds of the free parameters, in order.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">scipy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">k1</span><span class="o">.</span><span class="n">free_param_bounds</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k2</span><span class="o">.</span><span class="n">free_param_bounds</span><span class="p">))</span>
    </div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="BinaryKernel.free_param_names"><a class="viewcode-back" href="../../../gptools.kernel.html#gptools.kernel.core.BinaryKernel.free_param_names">[docs]</a>    <span class="k">def</span> <span class="nf">free_param_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the names of the free hyperparameters.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        free_param_names : :py:class:`Array`</span>
<span class="sd">            Array of the names of the free parameters, in order.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">scipy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">k1</span><span class="o">.</span><span class="n">free_param_names</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k2</span><span class="o">.</span><span class="n">free_param_names</span><span class="p">))</span>
    </div>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">params</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">scipy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">k1</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k2</span><span class="o">.</span><span class="n">params</span><span class="p">))</span>
    
    <span class="nd">@params.setter</span>
<div class="viewcode-block" id="BinaryKernel.params"><a class="viewcode-back" href="../../../gptools.kernel.html#gptools.kernel.core.BinaryKernel.params">[docs]</a>    <span class="k">def</span> <span class="nf">params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k1</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="n">v</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">k1</span><span class="o">.</span><span class="n">num_params</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k2</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">k1</span><span class="o">.</span><span class="n">num_params</span><span class="p">:]</span>
    </div>
<div class="viewcode-block" id="BinaryKernel.set_hyperparams"><a class="viewcode-back" href="../../../gptools.kernel.html#gptools.kernel.core.BinaryKernel.set_hyperparams">[docs]</a>    <span class="k">def</span> <span class="nf">set_hyperparams</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_params</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the (free) hyperparameters.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        new_params : :py:class:`Array` or other Array-like</span>
<span class="sd">            New values of the free parameters.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the length of `new_params` is not consistent with :py:attr:`self.params`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_params</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">new_params</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_params</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">free_params</span><span class="p">):</span>
            <span class="n">num_free_k1</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">k1</span><span class="o">.</span><span class="n">fixed_params</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">k1</span><span class="o">.</span><span class="n">set_hyperparams</span><span class="p">(</span><span class="n">new_params</span><span class="p">[:</span><span class="n">num_free_k1</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">k2</span><span class="o">.</span><span class="n">set_hyperparams</span><span class="p">(</span><span class="n">new_params</span><span class="p">[</span><span class="n">num_free_k1</span><span class="p">:])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Length of new_params must be </span><span class="si">%s</span><span class="s">!&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">free_params</span><span class="p">),))</span>
</div></div>
<div class="viewcode-block" id="SumKernel"><a class="viewcode-back" href="../../../gptools.kernel.html#gptools.kernel.core.SumKernel">[docs]</a><span class="k">class</span> <span class="nc">SumKernel</span><span class="p">(</span><span class="n">BinaryKernel</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The sum of two kernels.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="SumKernel.__call__"><a class="viewcode-back" href="../../../gptools.kernel.html#gptools.kernel.core.SumKernel.__call__">[docs]</a>    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluate the covariance between points `Xi` and `Xj` with derivative order `ni`, `nj`.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Xi : :py:class:`Matrix` or other Array-like, (`M`, `D`)</span>
<span class="sd">            `M` inputs with dimension `D`.</span>
<span class="sd">        Xj : :py:class:`Matrix` or other Array-like, (`M`, `D`)</span>
<span class="sd">            `M` inputs with dimension `D`.</span>
<span class="sd">        ni : :py:class:`Matrix` or other Array-like, (`M`, `D`)</span>
<span class="sd">            `M` derivative orders for set `i`.</span>
<span class="sd">        nj : :py:class:`Matrix` or other Array-like, (`M`, `D`)</span>
<span class="sd">            `M` derivative orders for set `j`.</span>
<span class="sd">        symmetric : bool, optional</span>
<span class="sd">            Whether or not the input `Xi`, `Xj` are from a symmetric matrix.</span>
<span class="sd">            Default is False.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Kij : :py:class:`Array`, (`M`,)</span>
<span class="sd">            Covariances for each of the `M` `Xi`, `Xj` pairs.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        NotImplementedError</span>
<span class="sd">            If the `hyper_deriv` keyword is given and is not None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s">&#39;hyper_deriv&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="ow">and</span> <span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;hyper_deriv&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&quot;Keyword hyper_deriv is not presently &quot;</span>
                                      <span class="s">&quot;supported for SumKernel!&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">k1</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">k2</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</div></div>
<div class="viewcode-block" id="ProductKernel"><a class="viewcode-back" href="../../../gptools.kernel.html#gptools.kernel.core.ProductKernel">[docs]</a><span class="k">class</span> <span class="nc">ProductKernel</span><span class="p">(</span><span class="n">BinaryKernel</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The product of two kernels.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="ProductKernel.__call__"><a class="viewcode-back" href="../../../gptools.kernel.html#gptools.kernel.core.ProductKernel.__call__">[docs]</a>    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Xi</span><span class="p">,</span> <span class="n">Xj</span><span class="p">,</span> <span class="n">ni</span><span class="p">,</span> <span class="n">nj</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluate the covariance between points `Xi` and `Xj` with derivative order `ni`, `nj`.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Xi : :py:class:`Matrix` or other Array-like, (`M`, `D`)</span>
<span class="sd">            `M` inputs with dimension `D`.</span>
<span class="sd">        Xj : :py:class:`Matrix` or other Array-like, (`M`, `D`)</span>
<span class="sd">            `M` inputs with dimension `D`.</span>
<span class="sd">        ni : :py:class:`Matrix` or other Array-like, (`M`, `D`)</span>
<span class="sd">            `M` derivative orders for set `i`.</span>
<span class="sd">        nj : :py:class:`Matrix` or other Array-like, (`M`, `D`)</span>
<span class="sd">            `M` derivative orders for set `j`.</span>
<span class="sd">        symmetric : bool, optional</span>
<span class="sd">            Whether or not the input `Xi`, `Xj` are from a symmetric matrix.</span>
<span class="sd">            Default is False.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Kij : :py:class:`Array`, (`M`,)</span>
<span class="sd">            Covariances for each of the `M` `Xi`, `Xj` pairs.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        NotImplementedError</span>
<span class="sd">            If the `hyper_deriv` keyword is given and is not None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Need to process ni, nj to handle the product rule properly.</span>
        <span class="n">nij</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">ni</span><span class="p">,</span> <span class="n">nj</span><span class="p">))</span>
        <span class="n">nij_unique</span> <span class="o">=</span> <span class="n">unique_rows</span><span class="p">(</span><span class="n">nij</span><span class="p">)</span>
        
        <span class="n">result</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Xi</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        
        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">nij_unique</span><span class="p">:</span>
            <span class="c"># deriv_pattern is the pattern of partial derivatives, where the</span>
            <span class="c"># indicies for derivatives with respect to the elements of Xj have</span>
            <span class="c"># been offset by self.num_dim. For instance, if ni = [1, 2] and</span>
            <span class="c"># nj = [3, 4], deriv_pattern will be [0, 1, 1, 2, 2, 2, 3, 3, 3, 3].</span>
            <span class="n">deriv_pattern</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">)):</span>
                <span class="n">deriv_pattern</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">*</span> <span class="p">[</span><span class="n">idx</span><span class="p">])</span>
            
            <span class="n">idxs</span> <span class="o">=</span> <span class="p">(</span><span class="n">nij</span> <span class="o">==</span> <span class="n">row</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            
            <span class="n">S</span> <span class="o">=</span> <span class="n">powerset</span><span class="p">(</span><span class="n">deriv_pattern</span><span class="p">)</span>
            
            <span class="c"># little &quot;s&quot; is a member of the power set of S:</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">S</span><span class="p">:</span>
                <span class="c"># nij_1 is the combined array of derivative orders for function 1:</span>
                <span class="n">nij_1</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">idxs</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_dim</span><span class="p">))</span>
                <span class="c"># sC is the complement of s with respect to S:</span>
                <span class="n">sC</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">deriv_pattern</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
                    <span class="n">nij_1</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">sC</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="c"># nij_2 is the combined array of derivative orders for function 2:</span>
                <span class="n">nij_2</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">idxs</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_dim</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sC</span><span class="p">:</span>
                    <span class="n">nij_2</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">result</span><span class="p">[</span><span class="n">idxs</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">k1</span><span class="p">(</span><span class="n">Xi</span><span class="p">[</span><span class="n">idxs</span><span class="p">,</span> <span class="p">:],</span> <span class="n">Xj</span><span class="p">[</span><span class="n">idxs</span><span class="p">,</span> <span class="p">:],</span> <span class="n">nij_1</span><span class="p">[:,</span> <span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">num_dim</span><span class="p">],</span> <span class="n">nij_1</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_dim</span><span class="p">:],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">*</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">k2</span><span class="p">(</span><span class="n">Xi</span><span class="p">[</span><span class="n">idxs</span><span class="p">,</span> <span class="p">:],</span> <span class="n">Xj</span><span class="p">[</span><span class="n">idxs</span><span class="p">,</span> <span class="p">:],</span> <span class="n">nij_2</span><span class="p">[:,</span> <span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">num_dim</span><span class="p">],</span> <span class="n">nij_2</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_dim</span><span class="p">:],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>
</div></div>
<div class="viewcode-block" id="ChainRuleKernel"><a class="viewcode-back" href="../../../gptools.kernel.html#gptools.kernel.core.ChainRuleKernel">[docs]</a><span class="k">class</span> <span class="nc">ChainRuleKernel</span><span class="p">(</span><span class="n">Kernel</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Abstract class for the common methods in creating kernels that require application of Faa di Bruno&#39;s formula.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="ChainRuleKernel.__call__"><a class="viewcode-back" href="../../../gptools.kernel.html#gptools.kernel.core.ChainRuleKernel.__call__">[docs]</a>    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Xi</span><span class="p">,</span> <span class="n">Xj</span><span class="p">,</span> <span class="n">ni</span><span class="p">,</span> <span class="n">nj</span><span class="p">,</span> <span class="n">hyper_deriv</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">symmetric</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluate the covariance between points `Xi` and `Xj` with derivative order `ni`, `nj`.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Xi : :py:class:`Matrix` or other Array-like, (`M`, `D`)</span>
<span class="sd">            `M` inputs with dimension `D`.</span>
<span class="sd">        Xj : :py:class:`Matrix` or other Array-like, (`M`, `D`)</span>
<span class="sd">            `M` inputs with dimension `D`.</span>
<span class="sd">        ni : :py:class:`Matrix` or other Array-like, (`M`, `D`)</span>
<span class="sd">            `M` derivative orders for set `i`.</span>
<span class="sd">        nj : :py:class:`Matrix` or other Array-like, (`M`, `D`)</span>
<span class="sd">            `M` derivative orders for set `j`.</span>
<span class="sd">        hyper_deriv : Non-negative int or None, optional</span>
<span class="sd">            The index of the hyperparameter to compute the first derivative</span>
<span class="sd">            with respect to. If None, no derivatives are taken. Hyperparameter</span>
<span class="sd">            derivatives are not supported at this point. Default is None.</span>
<span class="sd">        symmetric : bool</span>
<span class="sd">            Whether or not the input `Xi`, `Xj` are from a symmetric matrix.</span>
<span class="sd">            Default is False.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Kij : :py:class:`Array`, (`M`,)</span>
<span class="sd">            Covariances for each of the `M` `Xi`, `Xj` pairs.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        NotImplementedError</span>
<span class="sd">            If the `hyper_deriv` keyword is not None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">hyper_deriv</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&quot;Hyperparameter derivatives have not been implemented!&quot;</span><span class="p">)</span>

        <span class="n">tau</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">Xi</span> <span class="o">-</span> <span class="n">Xj</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="c"># Account for derivatives:</span>
        <span class="c"># Get total number of differentiations:</span>
        <span class="n">n_tot_j</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">nj</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">n_combined</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">ni</span> <span class="o">+</span> <span class="n">nj</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">n_combined_unique</span> <span class="o">=</span> <span class="n">unique_rows</span><span class="p">(</span><span class="n">n_combined</span><span class="p">)</span>

        <span class="c"># Evaluate the kernel:</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Xi</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="c"># First compute dk/dtau</span>
        <span class="k">for</span> <span class="n">n_combined_state</span> <span class="ow">in</span> <span class="n">n_combined_unique</span><span class="p">:</span>
            <span class="n">idxs</span> <span class="o">=</span> <span class="p">(</span><span class="n">n_combined</span> <span class="o">==</span> <span class="n">n_combined_state</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">k</span><span class="p">[</span><span class="n">idxs</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_dk_dtau</span><span class="p">(</span><span class="n">tau</span><span class="p">[</span><span class="n">idxs</span><span class="p">],</span> <span class="n">n_combined_state</span><span class="p">)</span>
        
        <span class="c"># Compute factor from the dtau_d/dx_d_j terms in the chain rule:</span>
        <span class="n">j_chain_factors</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">n_tot_j</span><span class="p">)</span>
        
        <span class="c"># Multiply by the chain rule factor to get dk/dXi or dk/dXj:</span>
        <span class="n">k</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">j_chain_factors</span> <span class="o">*</span> <span class="n">k</span>
        <span class="k">return</span> <span class="n">k</span>
    </div>
    <span class="k">def</span> <span class="nf">_compute_dk_dtau</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;Evaluate :math:`dk/d\tau` at the specified locations with the specified derivatives.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tau : :py:class:`Matrix`, (`M`, `D`)</span>
<span class="sd">            `M` inputs with dimension `D`.</span>
<span class="sd">        n : :py:class:`Array`, (`D`,)</span>
<span class="sd">            Degree of derivative with respect to each dimension.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            dk_dtau : :py:class:`Array`, (`M`,)</span>
<span class="sd">                Specified derivative at specified locations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Construct the derivative pattern:</span>
        <span class="c"># For each dimension, this will contain the index of the dimension</span>
        <span class="c"># repeated a number of times equal to the order of derivative with</span>
        <span class="c"># respect to that dimension.</span>
        <span class="c"># Example: For d^3 k(x, y, z) / dx^2 dy, n would be [2, 1, 0] and</span>
        <span class="c"># deriv_pattern should be [0, 0, 1]. For k(x, y, z) deriv_pattern is [].</span>
        <span class="n">deriv_pattern</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="p">)):</span>
            <span class="n">deriv_pattern</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">*</span> <span class="p">[</span><span class="n">idx</span><span class="p">])</span>
        <span class="n">deriv_pattern</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">deriv_pattern</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="c"># Handle non-derivative case separately for efficiency:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">deriv_pattern</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_k</span><span class="p">(</span><span class="n">tau</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># Compute all partitions of the deriv_pattern:</span>
            <span class="n">deriv_partitions</span> <span class="o">=</span> <span class="n">generate_set_partitions</span><span class="p">(</span><span class="n">deriv_pattern</span><span class="p">)</span>
            <span class="c"># Compute the requested derivative using the multivariate Faa di Bruno&#39;s equation:</span>
            <span class="n">dk_dtau</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">tau</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="c"># Loop over the partitions:</span>
            <span class="k">for</span> <span class="n">partition</span> <span class="ow">in</span> <span class="n">deriv_partitions</span><span class="p">:</span>
                <span class="n">dk_dtau</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_dk_dtau_on_partition</span><span class="p">(</span><span class="n">tau</span><span class="p">,</span> <span class="n">partition</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">dk_dtau</span>
    
    <span class="k">def</span> <span class="nf">_compute_dk_dtau_on_partition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluate the term inside the sum of Faa di Bruno&#39;s formula for the given partition.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tau : :py:class:`Matrix`, (`M`, `D`)</span>
<span class="sd">            `M` inputs with dimension `D`.</span>
<span class="sd">        p : list of :py:class:`Array`</span>
<span class="sd">            Each element is a block of the partition representing the</span>
<span class="sd">            derivative orders to use.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dk_dtau : :py:class:`Array`, (`M`,)</span>
<span class="sd">            The specified derivatives over the given partition at the specified</span>
<span class="sd">            locations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">y</span><span class="p">,</span> <span class="n">r2l2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_y</span><span class="p">(</span><span class="n">tau</span><span class="p">,</span> <span class="n">return_r2l2</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="c"># Compute the d^(|pi|)f/dy term:</span>
        <span class="n">dk_dtau</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_dk_dy</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
        <span class="c"># Multiply in each of the block terms:</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">p</span><span class="p">:</span>
            <span class="n">dk_dtau</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_dy_dtau</span><span class="p">(</span><span class="n">tau</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">r2l2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dk_dtau</span>
</div>
<div class="viewcode-block" id="ArbitraryKernel"><a class="viewcode-back" href="../../../gptools.kernel.html#gptools.kernel.core.ArbitraryKernel">[docs]</a><span class="k">class</span> <span class="nc">ArbitraryKernel</span><span class="p">(</span><span class="n">Kernel</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Covariance kernel from an arbitrary covariance function.</span>
<span class="sd">    </span>
<span class="sd">    Computes derivatives using :py:func:`mpmath.diff` and is hence in general</span>
<span class="sd">    much slower than a hard-coded implementation of a given kernel.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    num_dim : positive int</span>
<span class="sd">        Number of dimensions of the input data. Must be consistent with the `X`</span>
<span class="sd">        and `Xstar` values passed to the</span>
<span class="sd">        :py:class:`~gptools.gaussian_process.GaussianProcess` you wish to use</span>
<span class="sd">        the covariance kernel with.</span>
<span class="sd">    cov_func : callable, takes &gt;= 2 args</span>
<span class="sd">        Covariance function. Must take arrays of `Xi` and `Xj` as the</span>
<span class="sd">        first two arguments. The subsequent (scalar) arguments are the</span>
<span class="sd">        hyperparameters. The number of parameters is found by inspection of</span>
<span class="sd">        `cov_func` itself, or with the num_params keyword.</span>
<span class="sd">    num_proc : int or None, optional</span>
<span class="sd">        Number of procs to use in evaluating covariance derivatives. 0 means</span>
<span class="sd">        to do it in serial, None means to use all available cores. Default is</span>
<span class="sd">        0 (serial evaluation).</span>
<span class="sd">    num_params : int or None, optional</span>
<span class="sd">        Number of hyperparameters. If None, inspection will be used to infer</span>
<span class="sd">        the number of hyperparameters (but will fail if you used clever business</span>
<span class="sd">        with *args, etc.). Default is None (use inspection to find argument</span>
<span class="sd">        count).</span>
<span class="sd">    **kwargs</span>
<span class="sd">        All other keyword parameters are passed to :py:class:`~gptools.kernel.core.Kernel`.</span>
<span class="sd">    </span>
<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    cov_func : callable</span>
<span class="sd">        The covariance function</span>
<span class="sd">    num_proc : non-negative int</span>
<span class="sd">        Number of processors to use in evaluating covariance derivatives. 0 means serial.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cov_func</span><span class="p">,</span> <span class="n">num_dim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_proc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_params</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">num_proc</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">num_proc</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_proc</span> <span class="o">=</span> <span class="n">num_proc</span>
        <span class="k">if</span> <span class="n">num_params</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">argspec</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getargspec</span><span class="p">(</span><span class="n">cov_func</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">num_params</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">argspec</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span>
                <span class="n">param_names</span> <span class="o">=</span> <span class="n">argspec</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="c"># Need to remove self from the arg list for bound method:</span>
                <span class="n">argspec</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getargspec</span><span class="p">(</span><span class="n">cov_func</span><span class="o">.</span><span class="n">__call__</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">num_params</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">argspec</span><span class="p">)</span> <span class="o">-</span> <span class="mi">3</span>
                <span class="n">param_names</span> <span class="o">=</span> <span class="n">argspec</span><span class="p">[</span><span class="mi">3</span><span class="p">:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cov_func</span> <span class="o">=</span> <span class="n">cov_func</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ArbitraryKernel</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">num_dim</span><span class="o">=</span><span class="n">num_dim</span><span class="p">,</span>
                                              <span class="n">num_params</span><span class="o">=</span><span class="n">num_params</span><span class="p">,</span>
                                              <span class="n">param_names</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;param_names&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span>
                                              <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    
<div class="viewcode-block" id="ArbitraryKernel.__call__"><a class="viewcode-back" href="../../../gptools.kernel.html#gptools.kernel.core.ArbitraryKernel.__call__">[docs]</a>    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Xi</span><span class="p">,</span> <span class="n">Xj</span><span class="p">,</span> <span class="n">ni</span><span class="p">,</span> <span class="n">nj</span><span class="p">,</span> <span class="n">hyper_deriv</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">symmetric</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluate the covariance between points `Xi` and `Xj` with derivative order `ni`, `nj`.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Xi : :py:class:`Matrix` or other Array-like, (`M`, `D`)</span>
<span class="sd">            `M` inputs with dimension `D`.</span>
<span class="sd">        Xj : :py:class:`Matrix` or other Array-like, (`M`, `D`)</span>
<span class="sd">            `M` inputs with dimension `D`.</span>
<span class="sd">        ni : :py:class:`Matrix` or other Array-like, (`M`, `D`)</span>
<span class="sd">            `M` derivative orders for set `i`.</span>
<span class="sd">        nj : :py:class:`Matrix` or other Array-like, (`M`, `D`)</span>
<span class="sd">            `M` derivative orders for set `j`.</span>
<span class="sd">        hyper_deriv : Non-negative int or None, optional</span>
<span class="sd">            The index of the hyperparameter to compute the first derivative</span>
<span class="sd">            with respect to. If None, no derivatives are taken. Hyperparameter</span>
<span class="sd">            derivatives are not supported at this point. Default is None.</span>
<span class="sd">        symmetric : bool, optional</span>
<span class="sd">            Whether or not the input `Xi`, `Xj` are from a symmetric matrix.</span>
<span class="sd">            Default is False.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Kij : :py:class:`Array`, (`M`,)</span>
<span class="sd">            Covariances for each of the `M` `Xi`, `Xj` pairs.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        NotImplementedError</span>
<span class="sd">            If the `hyper_deriv` keyword is not None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">hyper_deriv</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&quot;Hyperparameter derivatives have not been implemented!&quot;</span><span class="p">)</span>
        <span class="n">n_cat</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">ni</span><span class="p">,</span> <span class="n">nj</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">X_cat</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">Xi</span><span class="p">,</span> <span class="n">Xj</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">n_cat_unique</span> <span class="o">=</span> <span class="n">unique_rows</span><span class="p">(</span><span class="n">n_cat</span><span class="p">)</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Xi</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="c"># Loop over unique derivative patterns:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_proc</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">pool</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span><span class="n">processes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">num_proc</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">n_cat_state</span> <span class="ow">in</span> <span class="n">n_cat_unique</span><span class="p">:</span>
            <span class="n">idxs</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">asarray</span><span class="p">((</span><span class="n">n_cat</span> <span class="o">==</span> <span class="n">n_cat_state</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">squeeze</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">n_cat_state</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                <span class="n">k</span><span class="p">[</span><span class="n">idxs</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov_func</span><span class="p">(</span><span class="n">Xi</span><span class="p">[</span><span class="n">idxs</span><span class="p">,</span> <span class="p">:],</span> <span class="n">Xj</span><span class="p">[</span><span class="n">idxs</span><span class="p">,</span> <span class="p">:],</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_proc</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">idxs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">k</span><span class="p">[</span><span class="n">idxs</span><span class="p">]</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span>
                        <span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">_ArbitraryKernelEval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_cat_state</span><span class="p">),</span> <span class="n">X_cat</span><span class="p">[</span><span class="n">idxs</span><span class="p">,</span> <span class="p">:]),</span>
                        <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">idxs</span><span class="p">:</span>
                        <span class="n">k</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">mpmath</span><span class="o">.</span><span class="n">chop</span><span class="p">(</span><span class="n">mpmath</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mask_cov_func</span><span class="p">,</span>
                                                         <span class="n">X_cat</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">:],</span>
                                                         <span class="n">n</span><span class="o">=</span><span class="n">n_cat_state</span><span class="p">,</span>
                                                         <span class="n">singular</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_proc</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">pool</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">k</span>
    </div>
    <span class="k">def</span> <span class="nf">_mask_cov_func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Masks the covariance function into a form usable by :py:func:`mpmath.diff`.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        *args : `num_dim` * 2 floats</span>
<span class="sd">            The individual elements of Xi and Xj to be passed to :py:attr:`cov_func`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Have to do it in two cases to get the 1d unwrapped properly:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_dim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov_func</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov_func</span><span class="p">(</span><span class="n">args</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">num_dim</span><span class="p">],</span> <span class="n">args</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">num_dim</span><span class="p">:],</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
</div>
<span class="k">class</span> <span class="nc">_ArbitraryKernelEval</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Helper class to support parallel evaluation of the :py:class:ArbitraryKernel:.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    obj : :py:class:`Kernel` instance</span>
<span class="sd">        Instance to wrap to allow parallel computation of.</span>
<span class="sd">    n_cat_state : Array-like, (2,)</span>
<span class="sd">        Derivative orders to take with respect to `Xi` and `Xj`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># TODO: Generalize this for higher dimensions, since ArbitraryKernel is</span>
    <span class="c"># supposed to be more general than univariate.</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">n_cat_state</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">obj</span> <span class="o">=</span> <span class="n">obj</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_cat_state</span> <span class="o">=</span> <span class="n">n_cat_state</span>
    
    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X_cat_row</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the covariance function of object evaluated at the given `X_cat_row`.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X_cat_row : Array-like, (2,)</span>
<span class="sd">            The `Xi` and `Xj` point to evaluate at.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">mpmath</span><span class="o">.</span><span class="n">chop</span><span class="p">(</span><span class="n">mpmath</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="o">.</span><span class="n">_mask_cov_func</span><span class="p">,</span>
                                       <span class="n">X_cat_row</span><span class="p">,</span>
                                       <span class="n">n</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_cat_state</span><span class="p">,</span>
                                       <span class="n">singular</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>

<span class="n">MASKEDKERNEL_RESERVED_NAMES</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;base&#39;</span><span class="p">,</span> <span class="s">&#39;mask&#39;</span><span class="p">,</span> <span class="s">&#39;maskC&#39;</span><span class="p">,</span> <span class="s">&#39;num_dim&#39;</span><span class="p">,</span> <span class="s">&#39;scale&#39;</span><span class="p">]</span>

<div class="viewcode-block" id="MaskedKernel"><a class="viewcode-back" href="../../../gptools.kernel.html#gptools.kernel.core.MaskedKernel">[docs]</a><span class="k">class</span> <span class="nc">MaskedKernel</span><span class="p">(</span><span class="n">Kernel</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Creates a kernel that is only masked to operate on certain dimensions, or has scaling/shifting.</span>
<span class="sd">    </span>
<span class="sd">    This can be used, for instance, to put a squared exponential kernel in one</span>
<span class="sd">    direction and a Matern kernel in the other.</span>
<span class="sd">    </span>
<span class="sd">    Overrides :py:meth:`__getattribute__` and :py:meth:`__setattr__` to make all</span>
<span class="sd">    setting/accessing go to the `base` kernel.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    base : :py:class:`Kernel` instance</span>
<span class="sd">        The :py:class:`Kernel` to apply in the dimensions specified in `mask`.</span>
<span class="sd">    total_dim : int, optional</span>
<span class="sd">        The total number of dimensions the masked kernel should have. Default</span>
<span class="sd">        is 2.</span>
<span class="sd">    mask : list or other array-like, optional</span>
<span class="sd">        1d list of indices of dimensions `X` to include when passing to the</span>
<span class="sd">        `base` kernel. Length must be `base.num_dim`. Default is [0] (i.e.,</span>
<span class="sd">        just pass the first column of `X` to a univariate `base` kernel).</span>
<span class="sd">    scale : list or other array-like, optional</span>
<span class="sd">        1d list of scale factors to apply to the elements in `Xi`, `Xj`. Default</span>
<span class="sd">        is ones. Length must be equal to 2`base.num_dim`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">total_dim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">scale</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span> <span class="o">!=</span> <span class="n">base</span><span class="o">.</span><span class="n">num_dim</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Length of mask must be equal to the number of &quot;</span>
                             <span class="s">&quot;dimensions of the base kernel!&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">scale</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">base</span><span class="o">.</span><span class="n">num_dim</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">scale</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">base</span><span class="o">.</span><span class="n">num_dim</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Length of scale must be equal to twice the number &quot;</span>
                             <span class="s">&quot;of dimensions of the base kernel!&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base</span> <span class="o">=</span> <span class="n">base</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">MaskedKernel</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">num_dim</span><span class="o">=</span><span class="n">total_dim</span><span class="p">,</span>
                                           <span class="n">num_params</span><span class="o">=</span><span class="n">base</span><span class="o">.</span><span class="n">num_params</span><span class="p">,</span>
                                           <span class="n">initial_params</span><span class="o">=</span><span class="n">base</span><span class="o">.</span><span class="n">params</span><span class="p">,</span>
                                           <span class="n">fixed_params</span><span class="o">=</span><span class="n">base</span><span class="o">.</span><span class="n">fixed_params</span><span class="p">,</span>
                                           <span class="n">param_names</span><span class="o">=</span><span class="n">base</span><span class="o">.</span><span class="n">param_names</span><span class="p">,</span>
                                           <span class="n">enforce_bounds</span><span class="o">=</span><span class="n">base</span><span class="o">.</span><span class="n">enforce_bounds</span><span class="p">,</span>
                                           <span class="n">hyperprior</span><span class="o">=</span><span class="n">base</span><span class="o">.</span><span class="n">hyperprior</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span>
        <span class="c"># maskC is the complement of mask:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">maskC</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_dim</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">maskC</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">=</span> <span class="n">scale</span>
    
<div class="viewcode-block" id="MaskedKernel.__getattribute__"><a class="viewcode-back" href="../../../gptools.kernel.html#gptools.kernel.core.MaskedKernel.__getattribute__">[docs]</a>    <span class="k">def</span> <span class="nf">__getattribute__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Gets all attributes from the base kernel.</span>
<span class="sd">        </span>
<span class="sd">        The exceptions are &#39;base&#39;, &#39;mask&#39;, &#39;maskC&#39;, &#39;num_dim&#39;, &#39;scale&#39; and any</span>
<span class="sd">        special method (i.e., a method/attribute having leading and trailing</span>
<span class="sd">        double underscores), which are taken from :py:class:`MaskedKernel`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;__&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s">&#39;__&#39;</span><span class="p">))</span> <span class="ow">and</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">MASKEDKERNEL_RESERVED_NAMES</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">__getattribute__</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">MaskedKernel</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__getattribute__</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">MaskedKernel</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__getattribute__</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
    </div>
<div class="viewcode-block" id="MaskedKernel.__setattr__"><a class="viewcode-back" href="../../../gptools.kernel.html#gptools.kernel.core.MaskedKernel.__setattr__">[docs]</a>    <span class="k">def</span> <span class="nf">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sets all attributes in the base kernel.</span>
<span class="sd">        </span>
<span class="sd">        The exceptions are &#39;base&#39;, &#39;mask&#39;, &#39;maskC&#39;, &#39;num_dim&#39;, &#39;scale&#39; and any</span>
<span class="sd">        special method (i.e., a method/attribute having leading and trailing</span>
<span class="sd">        double underscores), which are set in :py:class:`MaskedKernel`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;__&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s">&#39;__&#39;</span><span class="p">))</span> <span class="ow">and</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">MASKEDKERNEL_RESERVED_NAMES</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">__setattr__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">MaskedKernel</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__setattr__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    </div>
<div class="viewcode-block" id="MaskedKernel.__call__"><a class="viewcode-back" href="../../../gptools.kernel.html#gptools.kernel.core.MaskedKernel.__call__">[docs]</a>    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Xi</span><span class="p">,</span> <span class="n">Xj</span><span class="p">,</span> <span class="n">ni</span><span class="p">,</span> <span class="n">nj</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluate the covariance between points `Xi` and `Xj` with derivative order `ni`, `nj`.</span>
<span class="sd">        </span>
<span class="sd">        Note that in the argument specifications, `D` is the `total_dim`</span>
<span class="sd">        specified in the constructor (i.e., :py:attr:`num_dim` for the</span>
<span class="sd">        :py:class:`MaskedKernel` instance itself).</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Xi : :py:class:`Matrix` or other Array-like, (`M`, `D`)</span>
<span class="sd">            `M` inputs with dimension `D`.</span>
<span class="sd">        Xj : :py:class:`Matrix` or other Array-like, (`M`, `D`)</span>
<span class="sd">            `M` inputs with dimension `D`.</span>
<span class="sd">        ni : :py:class:`Matrix` or other Array-like, (`M`, `D`)</span>
<span class="sd">            `M` derivative orders for set `i`.</span>
<span class="sd">        nj : :py:class:`Matrix` or other Array-like, (`M`, `D`)</span>
<span class="sd">            `M` derivative orders for set `j`.</span>
<span class="sd">        hyper_deriv : Non-negative int or None, optional</span>
<span class="sd">            The index of the hyperparameter to compute the first derivative</span>
<span class="sd">            with respect to. If None, no derivatives are taken. Default is None</span>
<span class="sd">            (no hyperparameter derivatives).</span>
<span class="sd">        symmetric : bool, optional</span>
<span class="sd">            Whether or not the input `Xi`, `Xj` are from a symmetric matrix.</span>
<span class="sd">            Default is False.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Kij : :py:class:`Array`, (`M`,)</span>
<span class="sd">            Covariances for each of the `M` `Xi`, `Xj` pairs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Need to see if there are any derivatives of the masked variables:</span>
        <span class="n">good_idxs</span> <span class="o">=</span> <span class="p">(</span><span class="n">ni</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">maskC</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">nj</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">maskC</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Xi</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="c"># Need to do the indexing kinda funny to keep the shape right:</span>
        <span class="k">if</span> <span class="n">good_idxs</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="n">scale_tile</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">,</span> <span class="p">(</span><span class="n">good_idxs</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">result</span><span class="p">[</span><span class="n">good_idxs</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">(</span>
                <span class="n">Xi</span><span class="p">[</span><span class="n">good_idxs</span><span class="p">][:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">]</span> <span class="o">*</span> <span class="n">scale_tile</span><span class="p">[:,</span> <span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">num_dim</span><span class="p">],</span>
                <span class="n">Xj</span><span class="p">[</span><span class="n">good_idxs</span><span class="p">][:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">]</span> <span class="o">*</span> <span class="n">scale_tile</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">num_dim</span><span class="p">:],</span>
                <span class="n">ni</span><span class="p">[</span><span class="n">good_idxs</span><span class="p">][:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">],</span>
                <span class="n">nj</span><span class="p">[</span><span class="n">good_idxs</span><span class="p">][:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">],</span>
                <span class="o">**</span><span class="n">kwargs</span>
            <span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">scale_tile</span><span class="o">**</span><span class="n">scipy</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">ni</span><span class="p">[</span><span class="n">good_idxs</span><span class="p">][:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">],</span> <span class="n">nj</span><span class="p">[</span><span class="n">good_idxs</span><span class="p">][:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">])))</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="c"># Final factor is to account for the scaling.</span>
        <span class="k">return</span> <span class="n">result</span>
        </div></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../../../np-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">gptools 0.2 documentation</a> &raquo;</li>
          <li><a href="../../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2014, Mark Chilenski.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.3.
    </div>
  </body>
</html>