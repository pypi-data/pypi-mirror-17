<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>gptools.utils &mdash; gptools 0.2 documentation</title>
    
    <link rel="stylesheet" href="../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="top" title="gptools 0.2 documentation" href="../../index.html" />
    <link rel="up" title="Module code" href="../index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../../np-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../index.html">gptools 0.2 documentation</a> &raquo;</li>
          <li><a href="../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for gptools.utils</h1><div class="highlight"><pre>
<span class="c"># Copyright 2013 Mark Chilenski</span>
<span class="c"># This program is distributed under the terms of the GNU General Purpose License (GPL).</span>
<span class="c"># Refer to http://www.gnu.org/licenses/gpl.txt</span>
<span class="c"># </span>
<span class="c"># This program is free software: you can redistribute it and/or modify</span>
<span class="c"># it under the terms of the GNU General Public License as published by</span>
<span class="c"># the Free Software Foundation, either version 3 of the License, or</span>
<span class="c"># (at your option) any later version.</span>
<span class="c"># </span>
<span class="c"># This program is distributed in the hope that it will be useful,</span>
<span class="c"># but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c"># GNU General Public License for more details.</span>
<span class="c"># </span>
<span class="c"># You should have received a copy of the GNU General Public License</span>
<span class="c"># along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>

<span class="sd">&quot;&quot;&quot;Provides convenient utilities for working with the classes and results from :py:mod:`gptools`.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">division</span>

<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">scipy</span>
<span class="kn">import</span> <span class="nn">scipy.optimize</span>
<span class="kn">import</span> <span class="nn">scipy.special</span>
<span class="kn">import</span> <span class="nn">scipy.stats</span>
<span class="kn">import</span> <span class="nn">numpy.random</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
    <span class="kn">import</span> <span class="nn">matplotlib.widgets</span> <span class="kn">as</span> <span class="nn">mplw</span>
    <span class="kn">import</span> <span class="nn">matplotlib.gridspec</span> <span class="kn">as</span> <span class="nn">mplgs</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;Could not import matplotlib. plot_QQ keyword for compute_stats will not function.&quot;</span><span class="p">,</span>
                  <span class="ne">ImportWarning</span><span class="p">)</span>


<div class="viewcode-block" id="LessThanUniformPotential"><a class="viewcode-back" href="../../gptools.html#gptools.utils.LessThanUniformPotential">[docs]</a><span class="k">class</span> <span class="nc">LessThanUniformPotential</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Class to implement a potential to enforce an inequality constraint.</span>
<span class="sd">    </span>
<span class="sd">    Specifically lets you change the param with l_idx to have a uniform prior</span>
<span class="sd">    between its lower bound and the param with g_idx.</span>
<span class="sd">    </span>
<span class="sd">    Returns log((ub-lb)/(theta[g_idx]-lb)) if theta[l_idx] &lt;= theta[g_idx],</span>
<span class="sd">    double_min otherwise.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    l_idx : int</span>
<span class="sd">        Index of the parameter that is required to be lesser.</span>
<span class="sd">    g_idx : int</span>
<span class="sd">        Index of the parameter that is required to be greater.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l_idx</span><span class="p">,</span> <span class="n">g_idx</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">l_idx</span> <span class="o">=</span> <span class="n">l_idx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">g_idx</span> <span class="o">=</span> <span class="n">g_idx</span>
    
<div class="viewcode-block" id="LessThanUniformPotential.__call__"><a class="viewcode-back" href="../../gptools.html#gptools.utils.LessThanUniformPotential.__call__">[docs]</a>    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the log-density of the potential.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        theta : array-like</span>
<span class="sd">            Array of the hyperparameters.</span>
<span class="sd">        k : Kernel instance</span>
<span class="sd">            The kernel the hyperparameters apply to.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        f : float</span>
<span class="sd">            Returns log((ub-lb)/(theta[g_idx]-lb)) if the condition is met, -inf if not.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">theta</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">l_idx</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">theta</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">g_idx</span><span class="p">]</span> <span class="ow">and</span> <span class="n">theta</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">l_idx</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">k</span><span class="o">.</span><span class="n">param_bounds</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">l_idx</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">param_bounds</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">l_idx</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">k</span><span class="o">.</span><span class="n">param_bounds</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">l_idx</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span>
                    <span class="n">scipy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">theta</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">g_idx</span><span class="p">]</span> <span class="o">-</span> <span class="n">k</span><span class="o">.</span><span class="n">param_bounds</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">l_idx</span><span class="p">][</span><span class="mi">0</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">scipy</span><span class="o">.</span><span class="n">inf</span>
</div></div>
<div class="viewcode-block" id="JeffreysPrior"><a class="viewcode-back" href="../../gptools.html#gptools.utils.JeffreysPrior">[docs]</a><span class="k">class</span> <span class="nc">JeffreysPrior</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Class to implement a Jeffreys prior over a finite range. Returns log-density.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    idx : int</span>
<span class="sd">        The index this prior applies to.</span>
<span class="sd">    bounds : 2-tuple</span>
<span class="sd">        The bounds for the parameter this prior corresponds to: (lb, ub).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">bounds</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span> <span class="o">=</span> <span class="n">bounds</span>
    
<div class="viewcode-block" id="JeffreysPrior.__call__"><a class="viewcode-back" href="../../gptools.html#gptools.utils.JeffreysPrior.__call__">[docs]</a>    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">theta</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">idx</span><span class="p">]</span> <span class="ow">and</span> <span class="n">theta</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">idx</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">scipy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="o">-</span> <span class="n">scipy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">theta</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">idx</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">scipy</span><span class="o">.</span><span class="n">inf</span>
            </div>
<div class="viewcode-block" id="JeffreysPrior.interval"><a class="viewcode-back" href="../../gptools.html#gptools.utils.JeffreysPrior.interval">[docs]</a>    <span class="k">def</span> <span class="nf">interval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">alpha</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Unsupported interval!&quot;</span><span class="p">)</span>
</div></div>
<div class="viewcode-block" id="LinearPrior"><a class="viewcode-back" href="../../gptools.html#gptools.utils.LinearPrior">[docs]</a><span class="k">class</span> <span class="nc">LinearPrior</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Class to implement a linear prior. Returns log-density.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    idx : int</span>
<span class="sd">        The index this prior applies to.</span>
<span class="sd">    bounds : 2-tuple</span>
<span class="sd">        The bounds for the parameter this prior corresponds to: (lb, ub).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">bounds</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span> <span class="o">=</span> <span class="n">bounds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span>
    
<div class="viewcode-block" id="LinearPrior.__call__"><a class="viewcode-back" href="../../gptools.html#gptools.utils.LinearPrior.__call__">[docs]</a>    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the log-density of the uniform prior.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        theta : array-like, or float</span>
<span class="sd">            Value of values of the hyperparameter.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        f : :py:class:`Array` or float</span>
<span class="sd">            Returns log(2/(b-a)^2) + log(b-theta) if theta is in bounds, -inf</span>
<span class="sd">            if theta is out of bounds.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">theta</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">idx</span><span class="p">]</span> <span class="ow">and</span> <span class="n">theta</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">idx</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">return</span> <span class="n">scipy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">scipy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">theta</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">idx</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">scipy</span><span class="o">.</span><span class="n">inf</span>
    </div>
<div class="viewcode-block" id="LinearPrior.interval"><a class="viewcode-back" href="../../gptools.html#gptools.utils.LinearPrior.interval">[docs]</a>    <span class="k">def</span> <span class="nf">interval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">alpha</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Unsupported interval!&quot;</span><span class="p">)</span>
</div></div>
<div class="viewcode-block" id="UniformPrior"><a class="viewcode-back" href="../../gptools.html#gptools.utils.UniformPrior">[docs]</a><span class="k">class</span> <span class="nc">UniformPrior</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Class to implement a uniform prior. Returns log-density.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    idx : int</span>
<span class="sd">        The index this prior applies to.</span>
<span class="sd">    bounds : 2-tuple</span>
<span class="sd">        The bounds for the parameter this prior corresponds to: (lb, ub).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">bounds</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span> <span class="o">=</span> <span class="n">bounds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span>
        
<div class="viewcode-block" id="UniformPrior.__call__"><a class="viewcode-back" href="../../gptools.html#gptools.utils.UniformPrior.__call__">[docs]</a>    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the log-PDF of the uniform prior.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        theta : array-like</span>
<span class="sd">            Values of the hyperparameters.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        f : :py:class:`Array` or float</span>
<span class="sd">            Returns -log(ub - lb) if theta is scalar and in bounds, double_min</span>
<span class="sd">            if theta is scalar and out of bounds and an appropriately-shaped</span>
<span class="sd">            array if theta is array-like.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">theta</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">idx</span><span class="p">]</span> <span class="ow">and</span> <span class="n">theta</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">idx</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">scipy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">scipy</span><span class="o">.</span><span class="n">inf</span>  <span class="c">#scipy.finfo(&#39;d&#39;).min</span>
    </div>
<div class="viewcode-block" id="UniformPrior.interval"><a class="viewcode-back" href="../../gptools.html#gptools.utils.UniformPrior.interval">[docs]</a>    <span class="k">def</span> <span class="nf">interval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">):</span>
        <span class="c"># Can&#39;t store the frozen distribution since it isn&#39;t pickleable.</span>
        <span class="k">return</span> <span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">uniform</span><span class="o">.</span><span class="n">interval</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">scale</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    </div>
<div class="viewcode-block" id="UniformPrior.rvs"><a class="viewcode-back" href="../../gptools.html#gptools.utils.UniformPrior.rvs">[docs]</a>    <span class="k">def</span> <span class="nf">rvs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">uniform</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">scale</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</div></div>
<div class="viewcode-block" id="JointPrior"><a class="viewcode-back" href="../../gptools.html#gptools.utils.JointPrior">[docs]</a><span class="k">class</span> <span class="nc">JointPrior</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Abstract class for objects implementing joint priors over hyperparameters.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
<div class="viewcode-block" id="JointPrior.__call__"><a class="viewcode-back" href="../../gptools.html#gptools.utils.JointPrior.__call__">[docs]</a>    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluate the prior log-PDF at the given values of the hyperparameters, theta.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        theta : array-like, (`num_params`,)</span>
<span class="sd">            The hyperparameters to evaluate the log-PDF at.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&quot;__call__ must be implemented in your own class.&quot;</span><span class="p">)</span>
    </div>
<div class="viewcode-block" id="JointPrior.random_draw"><a class="viewcode-back" href="../../gptools.html#gptools.utils.JointPrior.random_draw">[docs]</a>    <span class="k">def</span> <span class="nf">random_draw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Draw random samples of the hyperparameters.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        size : None, int or array-like, optional</span>
<span class="sd">            The number/shape of samples to draw. If None, only one sample is</span>
<span class="sd">            returned. Default is None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&quot;random_draw must be implemented in your own class.&quot;</span><span class="p">)</span>
    </div>
<div class="viewcode-block" id="JointPrior.__mul__"><a class="viewcode-back" href="../../gptools.html#gptools.utils.JointPrior.__mul__">[docs]</a>    <span class="k">def</span> <span class="nf">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Multiply two :py:class:`JointPrior` instances together.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">ProductJointPrior</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
</div></div>
<div class="viewcode-block" id="CombinedBounds"><a class="viewcode-back" href="../../gptools.html#gptools.utils.CombinedBounds">[docs]</a><span class="k">class</span> <span class="nc">CombinedBounds</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Object to support reassignment of the bounds from a combined prior.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># TODO: This could use a lot more work!</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l1</span><span class="p">,</span> <span class="n">l2</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">l1</span> <span class="o">=</span> <span class="n">l1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">l2</span> <span class="o">=</span> <span class="n">l2</span>
    
<div class="viewcode-block" id="CombinedBounds.__getitem__"><a class="viewcode-back" href="../../gptools.html#gptools.utils.CombinedBounds.__getitem__">[docs]</a>    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">l1</span><span class="p">)</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">l2</span><span class="p">))[</span><span class="n">pos</span><span class="p">]</span>
    </div>
<div class="viewcode-block" id="CombinedBounds.__setitem__"><a class="viewcode-back" href="../../gptools.html#gptools.utils.CombinedBounds.__setitem__">[docs]</a>    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">pos</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">l1</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">l1</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">l2</span><span class="p">[</span><span class="n">pos</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">l1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">value</span>
    </div>
<div class="viewcode-block" id="CombinedBounds.__len__"><a class="viewcode-back" href="../../gptools.html#gptools.utils.CombinedBounds.__len__">[docs]</a>    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">l1</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">l2</span><span class="p">)</span>
    </div>
<div class="viewcode-block" id="CombinedBounds.__invert__"><a class="viewcode-back" href="../../gptools.html#gptools.utils.CombinedBounds.__invert__">[docs]</a>    <span class="k">def</span> <span class="nf">__invert__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">~</span><span class="n">scipy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</div></div>
<div class="viewcode-block" id="MaskedBounds"><a class="viewcode-back" href="../../gptools.html#gptools.utils.MaskedBounds">[docs]</a><span class="k">class</span> <span class="nc">MaskedBounds</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Object to support reassignment of free parameter bounds.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">a</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="o">=</span> <span class="n">m</span>
    
<div class="viewcode-block" id="MaskedBounds.__getitem__"><a class="viewcode-back" href="../../gptools.html#gptools.utils.MaskedBounds.__getitem__">[docs]</a>    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">pos</span><span class="p">]]</span>
    </div>
<div class="viewcode-block" id="MaskedBounds.__setitem__"><a class="viewcode-back" href="../../gptools.html#gptools.utils.MaskedBounds.__setitem__">[docs]</a>    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">pos</span><span class="p">]]</span> <span class="o">=</span> <span class="n">value</span>
    </div>
<div class="viewcode-block" id="MaskedBounds.__len__"><a class="viewcode-back" href="../../gptools.html#gptools.utils.MaskedBounds.__len__">[docs]</a>    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">)</span>
</div></div>
<div class="viewcode-block" id="ProductJointPrior"><a class="viewcode-back" href="../../gptools.html#gptools.utils.ProductJointPrior">[docs]</a><span class="k">class</span> <span class="nc">ProductJointPrior</span><span class="p">(</span><span class="n">JointPrior</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Product of two independent priors.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    p1, p2: :py:class:`JointPrior` instances</span>
<span class="sd">        The two priors to merge.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">JointPrior</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p2</span><span class="p">,</span> <span class="n">JointPrior</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;Both arguments to ProductPrior must be instances &quot;</span>
                            <span class="s">&quot;of type JointPrior!&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p1</span> <span class="o">=</span> <span class="n">p1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p2</span> <span class="o">=</span> <span class="n">p2</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">CombinedBounds</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p1</span><span class="o">.</span><span class="n">bounds</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">p2</span><span class="o">.</span><span class="n">bounds</span><span class="p">)</span>
    
    <span class="nd">@bounds.setter</span>
<div class="viewcode-block" id="ProductJointPrior.bounds"><a class="viewcode-back" href="../../gptools.html#gptools.utils.ProductJointPrior.bounds">[docs]</a>    <span class="k">def</span> <span class="nf">bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="n">num_p1_bounds</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p1</span><span class="o">.</span><span class="n">bounds</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p1</span><span class="o">.</span><span class="n">bounds</span> <span class="o">=</span> <span class="n">v</span><span class="p">[:</span><span class="n">num_p1_bounds</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p2</span><span class="o">.</span><span class="n">bounds</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">num_p1_bounds</span><span class="p">:]</span>
</div>
<div class="viewcode-block" id="ProductJointPrior.__call__"><a class="viewcode-back" href="../../gptools.html#gptools.utils.ProductJointPrior.__call__">[docs]</a>    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluate the prior log-PDF at the given values of the hyperparameters, theta.</span>
<span class="sd">        </span>
<span class="sd">        The log-PDFs of the two priors are summed.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        theta : array-like, (`num_params`,)</span>
<span class="sd">            The hyperparameters to evaluate the log-PDF at.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">p1_num_params</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p1</span><span class="o">.</span><span class="n">bounds</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">p1</span><span class="p">(</span><span class="n">theta</span><span class="p">[:</span><span class="n">p1_num_params</span><span class="p">])</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">p2</span><span class="p">(</span><span class="n">theta</span><span class="p">[</span><span class="n">p1_num_params</span><span class="p">:])</span>
    </div>
<div class="viewcode-block" id="ProductJointPrior.random_draw"><a class="viewcode-back" href="../../gptools.html#gptools.utils.ProductJointPrior.random_draw">[docs]</a>    <span class="k">def</span> <span class="nf">random_draw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Draw random samples of the hyperparameters.</span>

<span class="sd">        The outputs of the two priors are stacked vertically.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        size : None, int or array-like, optional</span>
<span class="sd">            The number/shape of samples to draw. If None, only one sample is</span>
<span class="sd">            returned. Default is None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">scipy</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">p1</span><span class="o">.</span><span class="n">random_draw</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">p2</span><span class="o">.</span><span class="n">random_draw</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">)))</span>
</div></div>
<div class="viewcode-block" id="UniformJointPrior"><a class="viewcode-back" href="../../gptools.html#gptools.utils.UniformJointPrior">[docs]</a><span class="k">class</span> <span class="nc">UniformJointPrior</span><span class="p">(</span><span class="n">JointPrior</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Uniform prior over the specified bounds.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    bounds : list of tuples, (`num_params`,)</span>
<span class="sd">        The bounds for each of the random variables.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bounds</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span> <span class="o">=</span> <span class="n">bounds</span>
    
<div class="viewcode-block" id="UniformJointPrior.__call__"><a class="viewcode-back" href="../../gptools.html#gptools.utils.UniformJointPrior.__call__">[docs]</a>    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluate the prior log-PDF at the given values of the hyperparameters, theta.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        theta : array-like, (`num_params`,)</span>
<span class="sd">            The hyperparameters to evaluate the log-PDF at.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ll</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">v</span> <span class="ow">and</span> <span class="n">v</span> <span class="o">&lt;=</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">ll</span> <span class="o">+=</span> <span class="o">-</span><span class="n">scipy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ll</span> <span class="o">=</span> <span class="o">-</span><span class="n">scipy</span><span class="o">.</span><span class="n">inf</span>
                <span class="k">break</span>
        <span class="k">return</span> <span class="n">ll</span>
    </div>
<div class="viewcode-block" id="UniformJointPrior.random_draw"><a class="viewcode-back" href="../../gptools.html#gptools.utils.UniformJointPrior.random_draw">[docs]</a>    <span class="k">def</span> <span class="nf">random_draw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Draw random samples of the hyperparameters.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        size : None, int or array-like, optional</span>
<span class="sd">            The number/shape of samples to draw. If None, only one sample is</span>
<span class="sd">            returned. Default is None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">scipy</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">high</span><span class="o">=</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">])</span>
</div></div>
<div class="viewcode-block" id="CoreEdgeJointPrior"><a class="viewcode-back" href="../../gptools.html#gptools.utils.CoreEdgeJointPrior">[docs]</a><span class="k">class</span> <span class="nc">CoreEdgeJointPrior</span><span class="p">(</span><span class="n">UniformJointPrior</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Prior for use with Gibbs kernel warping functions with an inequality constraint between the core and edge length scales.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
<div class="viewcode-block" id="CoreEdgeJointPrior.__call__"><a class="viewcode-back" href="../../gptools.html#gptools.utils.CoreEdgeJointPrior.__call__">[docs]</a>    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluate the prior log-PDF at the given values of the hyperparameters, theta.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        theta : array-like, (`num_params`,)</span>
<span class="sd">            The hyperparameters to evaluate the log-PDF at.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ll</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">bounds_new</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">)</span>
        <span class="n">bounds_new</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">theta</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">bounds_new</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">v</span> <span class="ow">and</span> <span class="n">v</span> <span class="o">&lt;=</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">ll</span> <span class="o">+=</span> <span class="o">-</span><span class="n">scipy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ll</span> <span class="o">=</span> <span class="o">-</span><span class="n">scipy</span><span class="o">.</span><span class="n">inf</span>
                <span class="k">break</span>
        <span class="k">return</span> <span class="n">ll</span>
    </div>
<div class="viewcode-block" id="CoreEdgeJointPrior.random_draw"><a class="viewcode-back" href="../../gptools.html#gptools.utils.CoreEdgeJointPrior.random_draw">[docs]</a>    <span class="k">def</span> <span class="nf">random_draw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Draw random samples of the hyperparameters.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        size : None, int or array-like, optional</span>
<span class="sd">            The number/shape of samples to draw. If None, only one sample is</span>
<span class="sd">            returned. Default is None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">size</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">single_val</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">single_val</span> <span class="o">=</span> <span class="bp">False</span>
        
        <span class="n">out_shape</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">)]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">out_shape</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="n">out_shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
        
        <span class="n">out</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">out_shape</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">j</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">out</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                                                 <span class="n">high</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span>
                                                 <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">out</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                                                 <span class="n">high</span><span class="o">=</span><span class="n">out</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:],</span>
                                                 <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">single_val</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">out</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">out</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
</div></div>
<div class="viewcode-block" id="CoreMidEdgeJointPrior"><a class="viewcode-back" href="../../gptools.html#gptools.utils.CoreMidEdgeJointPrior">[docs]</a><span class="k">class</span> <span class="nc">CoreMidEdgeJointPrior</span><span class="p">(</span><span class="n">UniformJointPrior</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Prior for use with Gibbs kernel warping functions with an inequality constraint between the core, mid and edge length scales and the core-mid and mid-edge joins.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
<div class="viewcode-block" id="CoreMidEdgeJointPrior.__call__"><a class="viewcode-back" href="../../gptools.html#gptools.utils.CoreMidEdgeJointPrior.__call__">[docs]</a>    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluate the prior log-PDF at the given values of the hyperparameters, theta.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        theta : array-like, (`num_params`,)</span>
<span class="sd">            The hyperparameters to evaluate the log-PDF at.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ll</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">bounds_new</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">)</span>
        <span class="c"># lc &lt; lm:</span>
        <span class="c"># bounds_new[1] = (self.bounds[1][0], theta[2])</span>
        <span class="c"># le &lt; lm:</span>
        <span class="c"># bounds_new[3] = (self.bounds[3][0], theta[2])</span>
        <span class="c"># xa &lt; xb:</span>
        <span class="n">bounds_new</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="mi">6</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">theta</span><span class="p">[</span><span class="mi">7</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">bounds_new</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">v</span> <span class="ow">and</span> <span class="n">v</span> <span class="o">&lt;=</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">ll</span> <span class="o">+=</span> <span class="o">-</span><span class="n">scipy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ll</span> <span class="o">=</span> <span class="o">-</span><span class="n">scipy</span><span class="o">.</span><span class="n">inf</span>
                <span class="k">break</span>
        <span class="k">return</span> <span class="n">ll</span>
    </div>
<div class="viewcode-block" id="CoreMidEdgeJointPrior.random_draw"><a class="viewcode-back" href="../../gptools.html#gptools.utils.CoreMidEdgeJointPrior.random_draw">[docs]</a>    <span class="k">def</span> <span class="nf">random_draw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Draw random samples of the hyperparameters.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        size : None, int or array-like, optional</span>
<span class="sd">            The number/shape of samples to draw. If None, only one sample is</span>
<span class="sd">            returned. Default is None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">size</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">single_val</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">single_val</span> <span class="o">=</span> <span class="bp">False</span>
        
        <span class="n">out_shape</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">)]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">out_shape</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="n">out_shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
        
        <span class="n">out</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">out_shape</span><span class="p">)</span>
        <span class="c"># sigma_f, lm, la, lb, xb:</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">]:</span>
            <span class="n">out</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                                             <span class="n">high</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span>
                                             <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">)</span>
        <span class="c"># lc, le:</span>
        <span class="c"># for j in [1, 3]:</span>
        <span class="c">#     out[j, :] = numpy.random.uniform(low=self.bounds[j][0],</span>
        <span class="c">#                                      high=out[2, :],</span>
        <span class="c">#                                      size=size)</span>
        <span class="c"># xa:</span>
        <span class="n">out</span><span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="mi">6</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                                         <span class="n">high</span><span class="o">=</span><span class="n">out</span><span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="p">:],</span>
                                         <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">single_val</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">out</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">out</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
</div></div>
<div class="viewcode-block" id="IndependentJointPrior"><a class="viewcode-back" href="../../gptools.html#gptools.utils.IndependentJointPrior">[docs]</a><span class="k">class</span> <span class="nc">IndependentJointPrior</span><span class="p">(</span><span class="n">JointPrior</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Joint prior for which each hyperparameter is independent.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    univariate_priors : list of callables or rv_frozen, (`num_params`,)</span>
<span class="sd">        The univariate priors for each hyperparameter. Entries in this list</span>
<span class="sd">        can either be a callable that takes as an argument the entire list of</span>
<span class="sd">        hyperparameters or a frozen instance of a distribution from</span>
<span class="sd">        :py:mod:`scipy.stats`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">univariate_priors</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">univariate_priors</span> <span class="o">=</span> <span class="n">univariate_priors</span>
    
<div class="viewcode-block" id="IndependentJointPrior.__call__"><a class="viewcode-back" href="../../gptools.html#gptools.utils.IndependentJointPrior.__call__">[docs]</a>    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluate the prior log-PDF at the given values of the hyperparameters, theta.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        theta : array-like, (`num_params`,)</span>
<span class="sd">            The hyperparameters to evaluate the log-PDF at.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ll</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">univariate_priors</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">ll</span> <span class="o">+=</span> <span class="n">p</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="n">ll</span> <span class="o">+=</span> <span class="n">p</span><span class="o">.</span><span class="n">logpdf</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ll</span>
    </div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="IndependentJointPrior.bounds"><a class="viewcode-back" href="../../gptools.html#gptools.utils.IndependentJointPrior.bounds">[docs]</a>    <span class="k">def</span> <span class="nf">bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The bounds of the random variable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">interval</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">univariate_priors</span><span class="p">]</span>
    </div>
<div class="viewcode-block" id="IndependentJointPrior.random_draw"><a class="viewcode-back" href="../../gptools.html#gptools.utils.IndependentJointPrior.random_draw">[docs]</a>    <span class="k">def</span> <span class="nf">random_draw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Draw random samples of the hyperparameters.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        size : None, int or array-like, optional</span>
<span class="sd">            The number/shape of samples to draw. If None, only one sample is</span>
<span class="sd">            returned. Default is None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">scipy</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">p</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">univariate_priors</span><span class="p">])</span>
</div></div>
<div class="viewcode-block" id="NormalJointPrior"><a class="viewcode-back" href="../../gptools.html#gptools.utils.NormalJointPrior">[docs]</a><span class="k">class</span> <span class="nc">NormalJointPrior</span><span class="p">(</span><span class="n">JointPrior</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Joint prior for which each hyperparameter has a normal prior with fixed hyper-hyperparameters.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mu : list of float, same size as `sigma`</span>
<span class="sd">        Means of the hyperparameters.</span>
<span class="sd">    sigma : list of float</span>
<span class="sd">        Standard deviations of the hyperparameters.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">sigma</span><span class="p">):</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">))</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">sigma</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">mu</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;sigma and mu must have the same shape!&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sigma</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;sigma and mu must both be one dimensional!&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span> <span class="o">=</span> <span class="n">sigma</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mu</span> <span class="o">=</span> <span class="n">mu</span>
    
<div class="viewcode-block" id="NormalJointPrior.__call__"><a class="viewcode-back" href="../../gptools.html#gptools.utils.NormalJointPrior.__call__">[docs]</a>    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluate the prior log-PDF at the given values of the hyperparameters, theta.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        theta : array-like, (`num_params`,)</span>
<span class="sd">            The hyperparameters to evaluate the log-PDF at.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ll</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu</span><span class="p">):</span>
            <span class="n">ll</span> <span class="o">+=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">logpdf</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">m</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">s</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ll</span>
    </div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="NormalJointPrior.bounds"><a class="viewcode-back" href="../../gptools.html#gptools.utils.NormalJointPrior.bounds">[docs]</a>    <span class="k">def</span> <span class="nf">bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The bounds of the random variable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">interval</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">m</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu</span><span class="p">)]</span>
    </div>
<div class="viewcode-block" id="NormalJointPrior.random_draw"><a class="viewcode-back" href="../../gptools.html#gptools.utils.NormalJointPrior.random_draw">[docs]</a>    <span class="k">def</span> <span class="nf">random_draw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Draw random samples of the hyperparameters.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        size : None, int or array-like, optional</span>
<span class="sd">            The number/shape of samples to draw. If None, only one sample is</span>
<span class="sd">            returned. Default is None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">scipy</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="n">m</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">s</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu</span><span class="p">)])</span>
</div></div>
<div class="viewcode-block" id="LogNormalJointPrior"><a class="viewcode-back" href="../../gptools.html#gptools.utils.LogNormalJointPrior">[docs]</a><span class="k">class</span> <span class="nc">LogNormalJointPrior</span><span class="p">(</span><span class="n">JointPrior</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Joint prior for which each hyperparameter has a log-normal prior with fixed hyper-hyperparameters.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mu : list of float, same size as `sigma`</span>
<span class="sd">        Means of the logarithms of the hyperparameters.</span>
<span class="sd">    sigma : list of float</span>
<span class="sd">        Standard deviations of the logarithms of the hyperparameters.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">sigma</span><span class="p">):</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">))</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">sigma</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">mu</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;sigma and mu must have the same shape!&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sigma</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;sigma and mu must both be one dimensional!&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span> <span class="o">=</span> <span class="n">sigma</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">emu</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span>
    
<div class="viewcode-block" id="LogNormalJointPrior.__call__"><a class="viewcode-back" href="../../gptools.html#gptools.utils.LogNormalJointPrior.__call__">[docs]</a>    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluate the prior log-PDF at the given values of the hyperparameters, theta.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        theta : array-like, (`num_params`,)</span>
<span class="sd">            The hyperparameters to evaluate the log-PDF at.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ll</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">em</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">emu</span><span class="p">):</span>
            <span class="n">ll</span> <span class="o">+=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">lognorm</span><span class="o">.</span><span class="n">logpdf</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">em</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ll</span>
    </div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="LogNormalJointPrior.bounds"><a class="viewcode-back" href="../../gptools.html#gptools.utils.LogNormalJointPrior.bounds">[docs]</a>    <span class="k">def</span> <span class="nf">bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The bounds of the random variable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">lognorm</span><span class="o">.</span><span class="n">interval</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">em</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">em</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">emu</span><span class="p">)]</span>
    </div>
<div class="viewcode-block" id="LogNormalJointPrior.random_draw"><a class="viewcode-back" href="../../gptools.html#gptools.utils.LogNormalJointPrior.random_draw">[docs]</a>    <span class="k">def</span> <span class="nf">random_draw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Draw random samples of the hyperparameters.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        size : None, int or array-like, optional</span>
<span class="sd">            The number/shape of samples to draw. If None, only one sample is</span>
<span class="sd">            returned. Default is None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">scipy</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">lognorm</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">em</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">em</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">emu</span><span class="p">)])</span>
</div></div>
<div class="viewcode-block" id="GammaJointPrior"><a class="viewcode-back" href="../../gptools.html#gptools.utils.GammaJointPrior">[docs]</a><span class="k">class</span> <span class="nc">GammaJointPrior</span><span class="p">(</span><span class="n">JointPrior</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Joint prior for which each hyperparameter has a gamma prior with fixed hyper-hyperparameters.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : list of float, same size as `b`</span>
<span class="sd">        Shape parameters.</span>
<span class="sd">    b : list of float</span>
<span class="sd">        Rate parameters.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">))</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;sigma and mu must have the same shape!&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;sigma and mu must both be one dimensional!&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">a</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">b</span>
    
<div class="viewcode-block" id="GammaJointPrior.__call__"><a class="viewcode-back" href="../../gptools.html#gptools.utils.GammaJointPrior.__call__">[docs]</a>    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluate the prior log-PDF at the given values of the hyperparameters, theta.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        theta : array-like, (`num_params`,)</span>
<span class="sd">            The hyperparameters to evaluate the log-PDF at.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ll</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">):</span>
            <span class="n">ll</span> <span class="o">+=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">gamma</span><span class="o">.</span><span class="n">logpdf</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">b</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ll</span>
    </div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="GammaJointPrior.bounds"><a class="viewcode-back" href="../../gptools.html#gptools.utils.GammaJointPrior.bounds">[docs]</a>    <span class="k">def</span> <span class="nf">bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The bounds of the random variable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">gamma</span><span class="o">.</span><span class="n">interval</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">)]</span>
    </div>
<div class="viewcode-block" id="GammaJointPrior.random_draw"><a class="viewcode-back" href="../../gptools.html#gptools.utils.GammaJointPrior.random_draw">[docs]</a>    <span class="k">def</span> <span class="nf">random_draw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Draw random samples of the hyperparameters.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        size : None, int or array-like, optional</span>
<span class="sd">            The number/shape of samples to draw. If None, only one sample is</span>
<span class="sd">            returned. Default is None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">scipy</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">gamma</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">b</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">)])</span>
</div></div>
<div class="viewcode-block" id="wrap_fmin_slsqp"><a class="viewcode-back" href="../../gptools.html#gptools.utils.wrap_fmin_slsqp">[docs]</a><span class="k">def</span> <span class="nf">wrap_fmin_slsqp</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">guess</span><span class="p">,</span> <span class="n">opt_kwargs</span><span class="o">=</span><span class="p">{}):</span>
    <span class="sd">&quot;&quot;&quot;Wrapper for :py:func:`fmin_slsqp` to allow it to be called with :py:func:`minimize`-like syntax.</span>

<span class="sd">    This is included to enable the code to run with :py:mod:`scipy` versions</span>
<span class="sd">    older than 0.11.0.</span>

<span class="sd">    Accepts `opt_kwargs` in the same format as used by</span>
<span class="sd">    :py:func:`scipy.optimize.minimize`, with the additional precondition</span>
<span class="sd">    that the keyword `method` has already been removed by the calling code.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fun : callable</span>
<span class="sd">        The function to minimize.</span>
<span class="sd">    guess : sequence</span>
<span class="sd">        The initial guess for the parameters.</span>
<span class="sd">    opt_kwargs : dict, optional</span>
<span class="sd">        Dictionary of extra keywords to pass to</span>
<span class="sd">        :py:func:`scipy.optimize.minimize`. Refer to that function&#39;s</span>
<span class="sd">        docstring for valid options. The keywords &#39;jac&#39;, &#39;hess&#39; and &#39;hessp&#39;</span>
<span class="sd">        are ignored. Note that if you were planning to use `jac` = True</span>
<span class="sd">        (i.e., optimization function returns Jacobian) and have set</span>
<span class="sd">        `args` = (True,) to tell :py:meth:`update_hyperparameters` to</span>
<span class="sd">        compute and return the Jacobian this may cause unexpected behavior.</span>
<span class="sd">        Default is: {}.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Result : namedtuple</span>
<span class="sd">        :py:class:`namedtuple` that mimics the fields of the</span>
<span class="sd">        :py:class:`Result` object returned by</span>
<span class="sd">        :py:func:`scipy.optimize.minimize`. Has the following fields:</span>

<span class="sd">        ======= ======= ===================================================================================</span>
<span class="sd">        status  int     Code indicating the exit mode of the optimizer (`imode` from :py:func:`fmin_slsqp`)</span>
<span class="sd">        success bool    Boolean indicating whether or not the optimizer thinks a minimum was found.</span>
<span class="sd">        fun     float   Value of the optimized function (-1*LL).</span>
<span class="sd">        x       ndarray Optimal values of the hyperparameters.</span>
<span class="sd">        message str     String describing the exit state (`smode` from :py:func:`fmin_slsqp`)</span>
<span class="sd">        nit     int     Number of iterations.</span>
<span class="sd">        ======= ======= ===================================================================================</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        Invalid constraint type in `constraints`. (See documentation for :py:func:`scipy.optimize.minimize`.)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">opt_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">opt_kwargs</span><span class="p">)</span>

    <span class="n">opt_kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;method&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>

    <span class="n">eqcons</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">ieqcons</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="s">&#39;constraints&#39;</span> <span class="ow">in</span> <span class="n">opt_kwargs</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">opt_kwargs</span><span class="p">[</span><span class="s">&#39;constraints&#39;</span><span class="p">],</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">opt_kwargs</span><span class="p">[</span><span class="s">&#39;constraints&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">opt_kwargs</span><span class="p">[</span><span class="s">&#39;constraints&#39;</span><span class="p">],]</span>
        <span class="k">for</span> <span class="n">con</span> <span class="ow">in</span> <span class="n">opt_kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;constraints&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">con</span><span class="p">[</span><span class="s">&#39;type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;eq&#39;</span><span class="p">:</span>
                <span class="n">eqcons</span> <span class="o">+=</span> <span class="p">[</span><span class="n">con</span><span class="p">[</span><span class="s">&#39;fun&#39;</span><span class="p">],]</span>
            <span class="k">elif</span> <span class="n">con</span><span class="p">[</span><span class="s">&#39;type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;ineq&#39;</span><span class="p">:</span>
                <span class="n">ieqcons</span> <span class="o">+=</span> <span class="p">[</span><span class="n">con</span><span class="p">[</span><span class="s">&#39;fun&#39;</span><span class="p">],]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Invalid constraint type </span><span class="si">%s</span><span class="s">!&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">con</span><span class="p">[</span><span class="s">&#39;type&#39;</span><span class="p">],))</span>

    <span class="k">if</span> <span class="s">&#39;jac&#39;</span> <span class="ow">in</span> <span class="n">opt_kwargs</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;Jacobian not supported for default solver SLSQP!&quot;</span><span class="p">,</span>
                      <span class="ne">RuntimeWarning</span><span class="p">)</span>
        <span class="n">opt_kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;jac&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="s">&#39;tol&#39;</span> <span class="ow">in</span> <span class="n">opt_kwargs</span><span class="p">:</span>
        <span class="n">opt_kwargs</span><span class="p">[</span><span class="s">&#39;acc&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">opt_kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;tol&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="s">&#39;options&#39;</span> <span class="ow">in</span> <span class="n">opt_kwargs</span><span class="p">:</span>
        <span class="n">opts</span> <span class="o">=</span> <span class="n">opt_kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;options&#39;</span><span class="p">)</span>
        <span class="n">opt_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">opt_kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="o">+</span> <span class="n">opts</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>

    <span class="c"># Other keywords with less likelihood for causing failures are silently ignored:</span>
    <span class="n">opt_kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;hess&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
    <span class="n">opt_kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;hessp&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
    <span class="n">opt_kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;callback&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>

    <span class="n">out</span><span class="p">,</span> <span class="n">fx</span><span class="p">,</span> <span class="n">its</span><span class="p">,</span> <span class="n">imode</span><span class="p">,</span> <span class="n">smode</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">fmin_slsqp</span><span class="p">(</span>
        <span class="n">fun</span><span class="p">,</span>
        <span class="n">guess</span><span class="p">,</span>
        <span class="n">full_output</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
        <span class="n">eqcons</span><span class="o">=</span><span class="n">eqcons</span><span class="p">,</span>
        <span class="n">ieqcons</span><span class="o">=</span><span class="n">ieqcons</span><span class="p">,</span>
        <span class="o">**</span><span class="n">opt_kwargs</span>
    <span class="p">)</span>

    <span class="n">Result</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="s">&#39;Result&#39;</span><span class="p">,</span>
                                    <span class="p">[</span><span class="s">&#39;status&#39;</span><span class="p">,</span> <span class="s">&#39;success&#39;</span><span class="p">,</span> <span class="s">&#39;fun&#39;</span><span class="p">,</span> <span class="s">&#39;x&#39;</span><span class="p">,</span> <span class="s">&#39;message&#39;</span><span class="p">,</span> <span class="s">&#39;nit&#39;</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">Result</span><span class="p">(</span><span class="n">status</span><span class="o">=</span><span class="n">imode</span><span class="p">,</span>
                  <span class="n">success</span><span class="o">=</span><span class="p">(</span><span class="n">imode</span> <span class="o">==</span> <span class="mi">0</span><span class="p">),</span>
                  <span class="n">fun</span><span class="o">=</span><span class="n">fx</span><span class="p">,</span>
                  <span class="n">x</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
                  <span class="n">message</span><span class="o">=</span><span class="n">smode</span><span class="p">,</span>
                  <span class="n">nit</span><span class="o">=</span><span class="n">its</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="incomplete_bell_poly"><a class="viewcode-back" href="../../gptools.html#gptools.utils.incomplete_bell_poly">[docs]</a><span class="k">def</span> <span class="nf">incomplete_bell_poly</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;Recursive evaluation of the incomplete Bell polynomial :math:`B_{n, k}(x)`.</span>
<span class="sd">    </span>
<span class="sd">    Evaluates the incomplete Bell polynomial :math:`B_{n, k}(x_1, x_2, \dots, x_{n-k+1})`,</span>
<span class="sd">    also known as the partial Bell polynomial or the Bell polynomial of the</span>
<span class="sd">    second kind. This polynomial is useful in the evaluation of (the univariate)</span>
<span class="sd">    Faa di Bruno&#39;s formula which generalizes the chain rule to higher order</span>
<span class="sd">    derivatives.</span>
<span class="sd">    </span>
<span class="sd">    The implementation here is based on the implementation in:</span>
<span class="sd">    :py:func:`sympy.functions.combinatorial.numbers.bell._bell_incomplete_poly`</span>
<span class="sd">    Following that function&#39;s documentation, the polynomial is computed</span>
<span class="sd">    according to the recurrence formula:</span>
<span class="sd">    </span>
<span class="sd">    .. math::</span>
<span class="sd">        </span>
<span class="sd">        B_{n, k}(x_1, x_2, \dots, x_{n-k+1}) = \sum_{m=1}^{n-k+1}x_m\binom{n-1}{m-1}B_{n-m, k-1}(x_1, x_2, \dots, x_{n-m-k})</span>
<span class="sd">        </span>
<span class="sd">    | The end cases are:</span>
<span class="sd">    | :math:`B_{0, 0} = 1`</span>
<span class="sd">    | :math:`B_{n, 0} = 0` for :math:`n \ge 1`</span>
<span class="sd">    | :math:`B_{0, k} = 0` for :math:`k \ge 1`</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : scalar int</span>
<span class="sd">        The first subscript of the polynomial.</span>
<span class="sd">    k : scalar int</span>
<span class="sd">        The second subscript of the polynomial.</span>
<span class="sd">    x : :py:class:`Array` of floats, (`p`, `n` - `k` + 1)</span>
<span class="sd">        `p` sets of `n` - `k` + 1 points to use as the arguments to</span>
<span class="sd">        :math:`B_{n,k}`. The second dimension can be longer than</span>
<span class="sd">        required, in which case the extra entries are silently ignored</span>
<span class="sd">        (this facilitates recursion without needing to subset the array `x`).</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    result : :py:class:`Array`, (`p`,)</span>
<span class="sd">        Incomplete Bell polynomial evaluated at the desired values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">scipy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">scipy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">k</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">scipy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="n">x</span><span class="p">[:,</span> <span class="n">m</span><span class="p">]</span> <span class="o">*</span> <span class="n">scipy</span><span class="o">.</span><span class="n">special</span><span class="o">.</span><span class="n">binom</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="o">*</span> <span class="n">incomplete_bell_poly</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>
</div>
<div class="viewcode-block" id="generate_set_partition_strings"><a class="viewcode-back" href="../../gptools.html#gptools.utils.generate_set_partition_strings">[docs]</a><span class="k">def</span> <span class="nf">generate_set_partition_strings</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generate the restricted growth strings for all of the partitions of an `n`-member set.</span>
<span class="sd">    </span>
<span class="sd">    Uses Algorithm H from page 416 of volume 4A of Knuth&#39;s `The Art of Computer</span>
<span class="sd">    Programming`. Returns the partitions in lexicographical order.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : scalar int, non-negative</span>
<span class="sd">        Number of (unique) elements in the set to be partitioned.</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    partitions : list of :py:class:`Array`</span>
<span class="sd">        List has a number of elements equal to the `n`-th Bell number (i.e.,</span>
<span class="sd">        the number of partitions for a set of size `n`). Each element has</span>
<span class="sd">        length `n`, the elements of which are the restricted growth strings</span>
<span class="sd">        describing the partitions of the set. The strings are returned in</span>
<span class="sd">        lexicographic order.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># Handle edge cases:</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>
    <span class="k">elif</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">scipy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">])]</span>
    
    <span class="n">partitions</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="c"># Step 1: Initialize</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="c"># Step 2: Visit</span>
        <span class="n">partitions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">a</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="c"># Step 4: Find j. j is the index of the first element from the end</span>
            <span class="c"># for which a != b, with the exception of the last element.</span>
            <span class="n">j</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">b</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="c"># Step 5: Increase a_j (or terminate):</span>
            <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="c"># Step 6: Zero out a_{j+1} to a_n:</span>
                <span class="n">b</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                <span class="n">a</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">b</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># Step 3: Increase a_n:</span>
            <span class="n">a</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
    
    <span class="k">return</span> <span class="n">partitions</span>
</div>
<div class="viewcode-block" id="generate_set_partitions"><a class="viewcode-back" href="../../gptools.html#gptools.utils.generate_set_partitions">[docs]</a><span class="k">def</span> <span class="nf">generate_set_partitions</span><span class="p">(</span><span class="n">set_</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generate all of the partitions of a set.</span>
<span class="sd">    </span>
<span class="sd">    This is a helper function that utilizes the restricted growth strings from</span>
<span class="sd">    :py:func:`generate_set_partition_strings`. The partitions are returned in</span>
<span class="sd">    lexicographic order.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    set_ : :py:class:`Array` or other Array-like, (`m`,)</span>
<span class="sd">        The set to find the partitions of.</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    partitions : list of lists of :py:class:`Array`</span>
<span class="sd">        The number of elements in the outer list is equal to the number of</span>
<span class="sd">        partitions, which is the len(`m`)^th Bell number. Each of the inner lists</span>
<span class="sd">        corresponds to a single possible partition. The length of an inner list</span>
<span class="sd">        is therefore equal to the number of blocks. Each of the arrays in an</span>
<span class="sd">        inner list is hence a block.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">set_</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">set_</span><span class="p">)</span>
    <span class="n">strings</span> <span class="o">=</span> <span class="n">generate_set_partition_strings</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">set_</span><span class="p">))</span>
    <span class="n">partitions</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">string</span> <span class="ow">in</span> <span class="n">strings</span><span class="p">:</span>
        <span class="n">blocks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">block_num</span> <span class="ow">in</span> <span class="n">scipy</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">string</span><span class="p">):</span>
            <span class="n">blocks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">set_</span><span class="p">[</span><span class="n">string</span> <span class="o">==</span> <span class="n">block_num</span><span class="p">])</span>
        <span class="n">partitions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">blocks</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">partitions</span>
</div>
<div class="viewcode-block" id="powerset"><a class="viewcode-back" href="../../gptools.html#gptools.utils.powerset">[docs]</a><span class="k">def</span> <span class="nf">powerset</span><span class="p">(</span><span class="n">iterable</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;powerset([1,2,3]) --&gt; () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)</span>
<span class="sd">    </span>
<span class="sd">    From itertools documentation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">s</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="unique_rows"><a class="viewcode-back" href="../../gptools.html#gptools.utils.unique_rows">[docs]</a><span class="k">def</span> <span class="nf">unique_rows</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">return_index</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">return_inverse</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns a copy of arr with duplicate rows removed.</span>
<span class="sd">    </span>
<span class="sd">    From Stackoverflow &quot;Find unique rows in numpy.array.&quot;</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arr : :py:class:`Array`, (`m`, `n`)</span>
<span class="sd">        The array to find the unique rows of.</span>
<span class="sd">    return_index : bool, optional</span>
<span class="sd">        If True, the indices of the unique rows in the array will also be</span>
<span class="sd">        returned. I.e., unique = arr[idx]. Default is False (don&#39;t return</span>
<span class="sd">        indices).</span>
<span class="sd">    return_inverse: bool, optional</span>
<span class="sd">        If True, the indices in the unique array to reconstruct the original</span>
<span class="sd">        array will also be returned. I.e., arr = unique[inv]. Default is False</span>
<span class="sd">        (don&#39;t return inverse).</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    unique : :py:class:`Array`, (`p`, `n`) where `p` &lt;= `m`</span>
<span class="sd">        The array `arr` with duplicate rows removed.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span>
        <span class="n">scipy</span><span class="o">.</span><span class="n">dtype</span><span class="p">((</span><span class="n">scipy</span><span class="o">.</span><span class="n">void</span><span class="p">,</span> <span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span> <span class="o">*</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">return_index</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">return_inverse</span><span class="o">=</span><span class="n">return_inverse</span><span class="p">)</span>
        <span class="n">dum</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">return_inverse</span><span class="p">:</span>
            <span class="n">inv</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">return_inverse</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s">&quot;Error in scipy.unique on older versions of numpy prevents &quot;</span>
                <span class="s">&quot;return_inverse from working!&quot;</span>
            <span class="p">)</span>
        <span class="c"># Handle bug in numpy 1.6.2:</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="p">[</span><span class="n">_Row</span><span class="p">(</span><span class="n">row</span><span class="p">)</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">b</span><span class="p">]</span>
        <span class="n">srt_idx</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rows</span><span class="p">)),</span> <span class="n">key</span><span class="o">=</span><span class="n">rows</span><span class="o">.</span><span class="n">__getitem__</span><span class="p">)</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">rows</span><span class="p">)[</span><span class="n">srt_idx</span><span class="p">]</span>
        <span class="n">row_cmp</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">srt_idx</span><span class="p">)):</span>
            <span class="n">row_cmp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rows</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">__cmp__</span><span class="p">(</span><span class="n">rows</span><span class="p">[</span><span class="n">k</span><span class="p">]))</span>
        <span class="n">row_cmp</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">row_cmp</span><span class="p">)</span>
        <span class="n">transition_idxs</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">row_cmp</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">srt_idx</span><span class="p">)[</span><span class="n">transition_idxs</span><span class="p">]</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">return_index</span><span class="p">:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">return_inverse</span><span class="p">:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">inv</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">return_index</span> <span class="ow">and</span> <span class="n">return_inverse</span><span class="p">:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">inv</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">out</span>
</div>
<span class="k">class</span> <span class="nc">_Row</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Helper class to compare rows of a matrix.</span>
<span class="sd">    </span>
<span class="sd">    This is used to workaround the bug with scipy.unique in numpy 1.6.2.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    row : ndarray</span>
<span class="sd">        The row this object is to represent. Must be 1d. (Will be flattened.)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">row</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">row</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">row</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    
    <span class="k">def</span> <span class="nf">__cmp__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compare two rows.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : :py:class:`_Row`</span>
<span class="sd">            The row to compare to.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        cmp : int</span>
<span class="sd">            == ==================================================================</span>
<span class="sd">            0  if the two rows have all elements equal</span>
<span class="sd">            1  if the first non-equal element (from the right) in self is greater</span>
<span class="sd">            -1 if the first non-equal element (from the right) in self is lesser</span>
<span class="sd">            == ==================================================================</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">row</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">row</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># Get first non-equal element:</span>
            <span class="n">first_nonequal_idx</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">row</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">row</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">row</span><span class="p">[</span><span class="n">first_nonequal_idx</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">other</span><span class="o">.</span><span class="n">row</span><span class="p">[</span><span class="n">first_nonequal_idx</span><span class="p">]:</span>
                <span class="k">return</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># Other must be greater than self in this case:</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

<span class="c"># Conversion factor to get from interquartile range to standard deviation:</span>
<span class="n">IQR_TO_STD</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">isf</span><span class="p">(</span><span class="mf">0.25</span><span class="p">)</span>

<div class="viewcode-block" id="compute_stats"><a class="viewcode-back" href="../../gptools.html#gptools.utils.compute_stats">[docs]</a><span class="k">def</span> <span class="nf">compute_stats</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="n">check_nan</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">robust</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">plot_QQ</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">&#39;&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute the average statistics (mean, std dev) for the given values.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    vals : array-like, (`M`, `D`)</span>
<span class="sd">        Values to compute the average statistics along the specified axis of.</span>
<span class="sd">    check_nan : bool, optional</span>
<span class="sd">        Whether or not to check for (and exclude) NaN&#39;s. Default is False (do</span>
<span class="sd">        not attempt to handle NaN&#39;s).</span>
<span class="sd">    robust : bool, optional</span>
<span class="sd">        Whether or not to use robust estimators (median for mean, IQR for</span>
<span class="sd">        standard deviation). Default is False (use non-robust estimators).</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        Axis to compute the statistics along. Presently only supported if</span>
<span class="sd">        `robust` is False. Default is 1.</span>
<span class="sd">    plot_QQ : bool, optional</span>
<span class="sd">        Whether or not a QQ plot and histogram should be drawn for each channel.</span>
<span class="sd">        Default is False (do not draw QQ plots).</span>
<span class="sd">    bins : int, optional</span>
<span class="sd">        Number of bins to use when plotting histogram (for plot_QQ=True).</span>
<span class="sd">        Default is 15</span>
<span class="sd">    name : str, optional</span>
<span class="sd">        Name to put in the title of the QQ/histogram plot.</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    mean : ndarray, (`M`,)</span>
<span class="sd">        Estimator for the mean of `vals`.</span>
<span class="sd">    std : ndarray, (`M`,)</span>
<span class="sd">        Estimator for the standard deviation of `vals`.</span>
<span class="sd">    </span>
<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    NotImplementedError</span>
<span class="sd">        If `axis` != 1 when `robust` is True.</span>
<span class="sd">    NotImplementedError</span>
<span class="sd">        If `plot_QQ` is True.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">robust</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&quot;Values of axis other than 1 are not supported &quot;</span>
                                  <span class="s">&quot;with the robust keyword at this time!&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">robust</span><span class="p">:</span>
        <span class="c"># TODO: This stuff should really be vectorized if there is something that allows it!</span>
        <span class="k">if</span> <span class="n">check_nan</span><span class="p">:</span>
            <span class="n">mean</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
            <span class="c"># TODO: HANDLE AXIS PROPERLY!</span>
            <span class="n">std</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">vals</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">vals</span><span class="p">)):</span>
                <span class="n">ch</span> <span class="o">=</span> <span class="n">vals</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                <span class="n">ok_idxs</span> <span class="o">=</span> <span class="o">~</span><span class="n">scipy</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ok_idxs</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                    <span class="n">std</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">scoreatpercentile</span><span class="p">(</span><span class="n">ch</span><span class="p">[</span><span class="n">ok_idxs</span><span class="p">],</span> <span class="mi">75</span><span class="p">)</span> <span class="o">-</span>
                              <span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">scoreatpercentile</span><span class="p">(</span><span class="n">ch</span><span class="p">[</span><span class="n">ok_idxs</span><span class="p">],</span> <span class="mi">25</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c"># Leave a nan where there are no non-nan values:</span>
                    <span class="n">std</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">std</span> <span class="o">/=</span> <span class="n">IQR_TO_STD</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mean</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
            <span class="c"># TODO: HANDLE AXIS PROPERLY!</span>
            <span class="n">std</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">scoreatpercentile</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="mf">75.0</span><span class="p">)</span> <span class="o">-</span>
                                 <span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">scoreatpercentile</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="mf">25.0</span><span class="p">)</span>
                                 <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">vals</span><span class="p">])</span> <span class="o">/</span> <span class="n">IQR_TO_STD</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">check_nan</span><span class="p">:</span>
            <span class="n">mean</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
            <span class="n">std</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mean</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
            <span class="n">std</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">plot_QQ</span><span class="p">:</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="n">gs</span> <span class="o">=</span> <span class="n">mplgs</span><span class="o">.</span><span class="n">GridSpec</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">height_ratios</span><span class="o">=</span><span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">a_QQ</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">gs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">a_hist</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">gs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">a_slider</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">gs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:])</span>
        
        <span class="n">title</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">)</span>
        
        <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Update the index from the results to be displayed.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">a_QQ</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="n">a_hist</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">slider</span><span class="o">.</span><span class="n">val</span>
            <span class="n">title</span><span class="o">.</span><span class="n">set_text</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s">, n=</span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">idx</span><span class="p">))</span>
            
            <span class="n">nan_idxs</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">vals</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">:])</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">nan_idxs</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                <span class="n">osm</span><span class="p">,</span> <span class="n">osr</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">probplot</span><span class="p">(</span><span class="n">vals</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="o">~</span><span class="n">nan_idxs</span><span class="p">],</span> <span class="n">dist</span><span class="o">=</span><span class="s">&#39;norm&#39;</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">fit</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
                <span class="n">a_QQ</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">osm</span><span class="p">,</span> <span class="n">osr</span><span class="p">,</span> <span class="s">&#39;bo&#39;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
                <span class="n">a_QQ</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s">&#39;QQ plot&#39;</span><span class="p">)</span>
                <span class="n">a_QQ</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s">&#39;quantiles of $\mathcal{N}(0,1)$&#39;</span><span class="p">)</span>
                <span class="n">a_QQ</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s">&#39;quantiles of data&#39;</span><span class="p">)</span>
                
                <span class="n">a_hist</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">vals</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="o">~</span><span class="n">nan_idxs</span><span class="p">],</span> <span class="n">bins</span><span class="o">=</span><span class="n">bins</span><span class="p">,</span> <span class="n">normed</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                <span class="n">locs</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">vals</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="o">~</span><span class="n">nan_idxs</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">vals</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="o">~</span><span class="n">nan_idxs</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
                <span class="n">a_hist</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">locs</span><span class="p">,</span> <span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">locs</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">mean</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">scale</span><span class="o">=</span><span class="n">std</span><span class="p">[</span><span class="n">idx</span><span class="p">]))</span>
                <span class="n">a_hist</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s">&#39;Normalized histogram and reported PDF&#39;</span><span class="p">)</span>
                <span class="n">a_hist</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s">&#39;value&#39;</span><span class="p">)</span>
                <span class="n">a_hist</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s">&#39;density&#39;</span><span class="p">)</span>
            
            <span class="n">f</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
        
        <span class="k">def</span> <span class="nf">arrow_respond</span><span class="p">(</span><span class="n">slider</span><span class="p">,</span> <span class="n">event</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Event handler for arrow key events in plot windows.</span>

<span class="sd">            Pass the slider object to update as a masked argument using a lambda function::</span>

<span class="sd">                lambda evt: arrow_respond(my_slider, evt)</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            slider : Slider instance associated with this handler.</span>
<span class="sd">            event : Event to be handled.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">key</span> <span class="o">==</span> <span class="s">&#39;right&#39;</span><span class="p">:</span>
                <span class="n">slider</span><span class="o">.</span><span class="n">set_val</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">slider</span><span class="o">.</span><span class="n">val</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">slider</span><span class="o">.</span><span class="n">valmax</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">event</span><span class="o">.</span><span class="n">key</span> <span class="o">==</span> <span class="s">&#39;left&#39;</span><span class="p">:</span>
                <span class="n">slider</span><span class="o">.</span><span class="n">set_val</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">slider</span><span class="o">.</span><span class="n">val</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">slider</span><span class="o">.</span><span class="n">valmin</span><span class="p">))</span>

        <span class="n">slider</span> <span class="o">=</span> <span class="n">mplw</span><span class="o">.</span><span class="n">Slider</span><span class="p">(</span><span class="n">a_slider</span><span class="p">,</span>
                             <span class="s">&#39;index&#39;</span><span class="p">,</span>
                             <span class="mi">0</span><span class="p">,</span>
                             <span class="nb">len</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                             <span class="n">valinit</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                             <span class="n">valfmt</span><span class="o">=</span><span class="s">&#39;</span><span class="si">%d</span><span class="s">&#39;</span><span class="p">)</span>
        <span class="n">slider</span><span class="o">.</span><span class="n">on_changed</span><span class="p">(</span><span class="n">update</span><span class="p">)</span>
        <span class="n">update</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">mpl_connect</span><span class="p">(</span><span class="s">&#39;key_press_event&#39;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">evt</span><span class="p">:</span> <span class="n">arrow_respond</span><span class="p">(</span><span class="n">slider</span><span class="p">,</span> <span class="n">evt</span><span class="p">))</span>
    
    <span class="k">return</span> <span class="p">(</span><span class="n">mean</span><span class="p">,</span> <span class="n">std</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="univariate_envelope_plot"><a class="viewcode-back" href="../../gptools.html#gptools.utils.univariate_envelope_plot">[docs]</a><span class="k">def</span> <span class="nf">univariate_envelope_plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">std</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">base_alpha</span><span class="o">=</span><span class="mf">0.375</span><span class="p">,</span> <span class="n">envelopes</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Make a plot of a mean curve with uncertainty envelopes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">ax</span> <span class="o">==</span> <span class="s">&#39;gca&#39;</span><span class="p">:</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
    
    <span class="n">l</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">color</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">getp</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s">&#39;color&#39;</span><span class="p">)</span>
    <span class="n">e</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">envelopes</span><span class="p">:</span>
        <span class="n">e</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">fill_between</span><span class="p">(</span>
                <span class="n">x</span><span class="p">,</span>
                <span class="n">mean</span> <span class="o">-</span> <span class="n">i</span> <span class="o">*</span> <span class="n">std</span><span class="p">,</span>
                <span class="n">mean</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">std</span><span class="p">,</span>
                <span class="n">facecolor</span><span class="o">=</span><span class="n">color</span><span class="p">,</span>
                <span class="n">alpha</span><span class="o">=</span><span class="n">base_alpha</span> <span class="o">/</span> <span class="n">i</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="summarize_sampler"><a class="viewcode-back" href="../../gptools.html#gptools.utils.summarize_sampler">[docs]</a><span class="k">def</span> <span class="nf">summarize_sampler</span><span class="p">(</span><span class="n">sampler</span><span class="p">,</span> <span class="n">burn</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">thin</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ci</span><span class="o">=</span><span class="mf">0.95</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;Create summary statistics of the flattened chain of the sampler.</span>
<span class="sd">    </span>
<span class="sd">    The confidence regions are computed from the quantiles of the data.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sampler : :py:class:`emcee.EnsembleSampler` instance</span>
<span class="sd">        The sampler to summarize the chains of.</span>
<span class="sd">    burn : int, optional</span>
<span class="sd">        The number of samples to burn from the beginning of the chain. Default</span>
<span class="sd">        is 0 (no burn).</span>
<span class="sd">    thin : int, optional</span>
<span class="sd">        The step size to thin with. Default is 1 (no thinning).</span>
<span class="sd">    ci : float, optional</span>
<span class="sd">        A number between 0 and 1 indicating the confidence region to compute.</span>
<span class="sd">        Default is 0.95 (return upper and lower bounds of the 95% confidence</span>
<span class="sd">        interval).</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    mean : array, (num_params,)</span>
<span class="sd">        Mean values of each of the parameters sampled.</span>
<span class="sd">    ci_l : array, (num_params,)</span>
<span class="sd">        Lower bounds of the `ci*100%` confidence intervals.</span>
<span class="sd">    ci_u : array, (num_params,)</span>
<span class="sd">        Upper bounds of the `ci*100%` confidence intervals.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">flat_trace</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">chain</span><span class="p">[:,</span> <span class="n">burn</span><span class="p">::</span><span class="n">thin</span><span class="p">,</span> <span class="p">:]</span>
    <span class="n">flat_trace</span> <span class="o">=</span> <span class="n">flat_trace</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">flat_trace</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
    
    <span class="n">mean</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">flat_trace</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">cibdry</span> <span class="o">=</span> <span class="mf">100.0</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">ci</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
    <span class="n">ci_l</span><span class="p">,</span> <span class="n">ci_u</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">flat_trace</span><span class="p">,</span> <span class="p">[</span><span class="n">cibdry</span><span class="p">,</span> <span class="mf">100.0</span> <span class="o">-</span> <span class="n">cibdry</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="p">(</span><span class="n">mean</span><span class="p">,</span> <span class="n">ci_l</span><span class="p">,</span> <span class="n">ci_u</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="plot_sampler"><a class="viewcode-back" href="../../gptools.html#gptools.utils.plot_sampler">[docs]</a><span class="k">def</span> <span class="nf">plot_sampler</span><span class="p">(</span><span class="n">sampler</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">burn</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">chain_mask</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Plot the results of MCMC sampler (posterior and chains).</span>
<span class="sd">    </span>
<span class="sd">    Loosely based on triangle.py.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sampler : :py:class:`emcee.EnsembleSampler` instance</span>
<span class="sd">        The sampler to plot the chains/marginals of.</span>
<span class="sd">    labels : list of str, optional</span>
<span class="sd">        The labels to use for each of the free parameters. Default is to leave</span>
<span class="sd">        the axes unlabeled.</span>
<span class="sd">    burn : int, optional</span>
<span class="sd">        The number of samples to burn before making the marginal histograms.</span>
<span class="sd">        Default is zero (use all samples).</span>
<span class="sd">    chain_mask : (index) array</span>
<span class="sd">        Mask identifying the chains to keep before plotting, in case there are</span>
<span class="sd">        bad chains. Default is to use all chains.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c"># Create axes:</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">flatchain</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">labels</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">k</span>
    
    <span class="n">f</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
    <span class="n">gs1</span> <span class="o">=</span> <span class="n">mplgs</span><span class="o">.</span><span class="n">GridSpec</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
    <span class="n">gs2</span> <span class="o">=</span> <span class="n">mplgs</span><span class="o">.</span><span class="n">GridSpec</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
    <span class="n">gs1</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">bottom</span><span class="o">=</span><span class="mf">0.275</span><span class="p">,</span> <span class="n">top</span><span class="o">=</span><span class="mf">0.98</span><span class="p">)</span>
    <span class="n">gs2</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">bottom</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">top</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)</span>
    <span class="n">axes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c"># j is the row, i is the column.</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">row</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">j</span><span class="p">:</span>
                <span class="n">row</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sharey</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">k</span> <span class="k">else</span> <span class="bp">None</span>
                <span class="n">sharex</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="n">i</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">k</span> <span class="k">else</span> \
                    <span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">==</span> <span class="n">k</span> <span class="k">else</span> <span class="bp">None</span><span class="p">)</span>
                <span class="n">gs</span> <span class="o">=</span> <span class="n">gs1</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">k</span> <span class="k">else</span> <span class="n">gs2</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span>
                <span class="n">row</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">gs</span><span class="p">,</span> <span class="n">sharey</span><span class="o">=</span><span class="n">sharey</span><span class="p">,</span> <span class="n">sharex</span><span class="o">=</span><span class="n">sharex</span><span class="p">))</span>
        <span class="n">axes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
    <span class="n">axes</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span>
    
    <span class="c"># Update axes with the data:</span>
    <span class="k">if</span> <span class="n">chain_mask</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">chain_mask</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="n">flat_trace</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">chain</span><span class="p">[</span><span class="n">chain_mask</span><span class="p">,</span> <span class="n">burn</span><span class="p">:,</span> <span class="p">:]</span>
    <span class="n">flat_trace</span> <span class="o">=</span> <span class="n">flat_trace</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="p">))</span>
    
    <span class="c"># j is the row, i is the column.</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">flat_trace</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">bins</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">&#39;black&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">setp</span><span class="p">(</span><span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">get_xticklabels</span><span class="p">(),</span> <span class="n">visible</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">setp</span><span class="p">(</span><span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">get_yticklabels</span><span class="p">(),</span> <span class="n">visible</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="c"># for j in xrange(0, i):</span>
        <span class="c">#     axes[j, i].set_visible(False)</span>
        <span class="c">#     axes[j, i].set_frame_on(False)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
            <span class="n">axes</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="n">ct</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">im</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">hist2d</span><span class="p">(</span><span class="n">flat_trace</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">flat_trace</span><span class="p">[:,</span> <span class="n">j</span><span class="p">],</span> <span class="n">bins</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s">&#39;gray_r&#39;</span><span class="p">)</span>
            <span class="c"># xmid = 0.5 * (x[1:] + x[:-1])</span>
            <span class="c"># ymid = 0.5 * (y[1:] + y[:-1])</span>
            <span class="c"># axes[j, i].contour(xmid, ymid, ct.T, colors=&#39;k&#39;)</span>
            <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">setp</span><span class="p">(</span><span class="n">axes</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">get_xticklabels</span><span class="p">(),</span> <span class="n">visible</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">setp</span><span class="p">(</span><span class="n">axes</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">get_yticklabels</span><span class="p">(),</span> <span class="n">visible</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">axes</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">axes</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">axes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="n">axes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">chain</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="n">axes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">burn</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">&#39;r&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">axes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">axes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s">&#39;step&#39;</span><span class="p">)</span>
    
    <span class="n">f</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../../np-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../index.html">gptools 0.2 documentation</a> &raquo;</li>
          <li><a href="../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2014, Mark Chilenski.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.3.
    </div>
  </body>
</html>