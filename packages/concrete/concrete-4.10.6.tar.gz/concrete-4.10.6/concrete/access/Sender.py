# -*- coding: utf-8 -*-
#
# Autogenerated by Thrift Compiler (0.9.3)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:new_style,utf8strings,coding=utf-8
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
import concrete.services.Service
import logging
from ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Iface(concrete.services.Service.Iface):
  """
  A service that exists so that clients can send Concrete data
  structures to implementing servers.

  Implement this if you are creating an analytic that wishes to
  send its results back to a server. That server may perform
  validation, write the new layers to a database, and so forth.
  """
  def send(self, communication):
    """
    Send a communication to a server implementing this method.

    The communication that is sent back should contain the new
    analytic layers you wish to append. You may also wish to call
    methods that unset annotations you feel the receiver would not
    find useful in order to reduce network overhead.

    Parameters:
     - communication
    """
    pass


class Client(concrete.services.Service.Client, Iface):
  """
  A service that exists so that clients can send Concrete data
  structures to implementing servers.

  Implement this if you are creating an analytic that wishes to
  send its results back to a server. That server may perform
  validation, write the new layers to a database, and so forth.
  """
  def __init__(self, iprot, oprot=None):
    concrete.services.Service.Client.__init__(self, iprot, oprot)

  def send(self, communication):
    """
    Send a communication to a server implementing this method.

    The communication that is sent back should contain the new
    analytic layers you wish to append. You may also wish to call
    methods that unset annotations you feel the receiver would not
    find useful in order to reduce network overhead.

    Parameters:
     - communication
    """
    self.send_send(communication)
    self.recv_send()

  def send_send(self, communication):
    self._oprot.writeMessageBegin('send', TMessageType.CALL, self._seqid)
    args = send_args()
    args.communication = communication
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_send(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = send_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ex is not None:
      raise result.ex
    return


class Processor(concrete.services.Service.Processor, Iface, TProcessor):
  def __init__(self, handler):
    concrete.services.Service.Processor.__init__(self, handler)
    self._processMap["send"] = Processor.process_send

  def process(self, iprot, oprot):
    (name, type, seqid) = iprot.readMessageBegin()
    if name not in self._processMap:
      iprot.skip(TType.STRUCT)
      iprot.readMessageEnd()
      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.trans.flush()
      return
    else:
      self._processMap[name](self, seqid, iprot, oprot)
    return True

  def process_send(self, seqid, iprot, oprot):
    args = send_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = send_result()
    try:
      self._handler.send(args.communication)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except concrete.services.ttypes.ServicesException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("send", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES

class send_args(object):
  """
  Attributes:
   - communication
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'communication', (concrete.communication.ttypes.Communication, concrete.communication.ttypes.Communication.thrift_spec), None, ), # 1
  )

  def __init__(self, communication=None,):
    self.communication = communication

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.communication = concrete.communication.ttypes.Communication()
          self.communication.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('send_args')
    if self.communication is not None:
      oprot.writeFieldBegin('communication', TType.STRUCT, 1)
      self.communication.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.communication)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class send_result(object):
  """
  Attributes:
   - ex
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ex', (concrete.services.ttypes.ServicesException, concrete.services.ttypes.ServicesException.thrift_spec), None, ), # 1
  )

  def __init__(self, ex=None,):
    self.ex = ex

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ex = concrete.services.ttypes.ServicesException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('send_result')
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ex)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
