<?xml version="1.0" encoding="UTF-8"?>
<contents>
  <reference>
    <title>to inner classes</title>
    <abstract>This file contains the declarations for inner classes handling a relationship</abstract>
    <author>Mel Viso</author>
    <date>10/2016</date>
    <package>standard</package>
    <digital-sign/>
  </reference>
  <definitions>
    <def>arg=p{toRel._name}</def>
    <def>toKey={toRel._name}</def>
    <def>fromPtr={fromRel._fromPtr.prefixed_name}</def>
    <def>counter={toRel._counter.prefixed_name}</def>
    <def>classTo={TO._name}</def>
  </definitions>
  <classes>
	<class name="{toKey}Iterator" access="protected">
		<types>
			 <type name="filter" definition="typedef bool ({TO._name}::*filter)() const;" note="Type for functions filtering iteration" />
		</types>
		<members>
			<member name="pRef{toKey}" type="TO" access="private" ptr="True" default="nullptr" />
			<member name="pPrev{toKey}" type="TO" access="private" ptr="True" default="nullptr" />
			<member name="pNext{toKey}" type="TO" access="private" ptr="True" default="nullptr" />
			<member name="iter{toKey}" type="TO" access="private" ptr="True" const="True" default="nullptr" />
			<member name="prev" type="{toKey}Iterator" access="private" ptr="True" default="nullptr" />
			<member name="next" type="{toKey}Iterator" access="private" ptr="True" default="nullptr" />
			<member name="method" type="filter" access="private" default="nullptr" />
			<member name="first"  type="{toKey}Iterator" access="private" static="True" ptr="True" default="nullptr"/>
			<member name="last"  type="{toKey}Iterator" access="private" static="True" ptr="True" default="nullptr"/>
		</members>
		<ctors>
			<ctor access="public">
				<args>
					<arg name="method" type="filter" default="nullptr" />
					<arg name="ref{toKey}" type="TO" ptr="True" default="nullptr" />
				</args>
				<init/>
				<content filter="{transactional:False}"/>
			</ctor>
			<ctor access="public">
				<args>
					<arg name="iterator" type="{toKey}Iterator" const="True" ref="True" />
					<arg name="method" type="filter" default="nullptr" />
				</args>
				<init/>
				<content filter="{transactional:False}"/>
			</ctor>
		</ctors>
		<methods>
			<method name="operator =" access="public" type="{toKey}Iterator" ref="True">
				<args>
					<arg name="iterator" type="{toKey}Iterator" const="True" ref="True" />
				</args>
				<content filter="{transactional:False}">
					pRef{toKey} = iterator.pRef{toKey};
					pPrev{toKey} = iterator.pPrev{toKey};
					pNext{toKey} = iterator.pNext{toKey};
					_method = iterator._method;
					return *this;
				</content>
			</method>
			<method name="operator ++" access="public" type="TO" ptr="True">
				<args/>
				<content filter="{transactional:False}">
					pNext{toKey} = GetNext{toKey}(pNext{toKey});
					if(_method != 0)
					{{
						while (pNext{toKey} &amp;&amp; !pNext{toKey}-&gt;*_method)())
						
							pNext{toKey} = GetNext{toKey}(pNext{toKey});
					}}
					pRef{toKey} = pPrev{toKey} = pNext{toKey};
					return pRef{toKey};
				</content>
			</method>
			<method name="operator --" access="public" type="TO" ptr="True">
				<args/>
				<content filter="{transactional:False}">
					pPrev{toKey} = GetPrev{toKey}(pPrev{toKey});
					if (_method != 0)
					{{
						while (pPrev{toKey} &amp;&amp; !pPrev{toKey}-&gt;*_method)())
							pPrev{toKey} = GetPrev{toKey}(pPrev{toKey});
					}}
					pRef{toKey} = pNext{toKey} = pPrev{toKey};
					return pRef{toKey};
				</content>
			</method>
			<method name="operator {TO._name}*" access="public" type='' >
				<args/>
				<content filter="{transactional:False}">
					return pRef{toKey};
				</content>
			</method>
			<method name="operator ->" access="public" type="TO" ptr="True" >
				<args/>
				<content filter="{transactional:False}">
					return pRef{toKey};
				</content>
			</method>
			<method name="Get" access="public" type="TO" ptr="True" >
				<args/>
				<content filter="{transactional:False}">
					return pRef{toKey};
				</content>
			</method>
			<method name="Reset" access="public" type="void"  >
				<args/>
				<content filter="{transactional:False}">
					pRef{toKey} = pNext{toKey} = pPrev{toKey} = nullptr;
				</content>
			</method>
			<method name="IsLast" access="public" type="bool"  >
				<args/>
				<content filter="{transactional:False}">
					return _iter{toKey}-&gt;GetLast{toKey}() == pRef{toKey};
				</content>
			</method>
			<method name="IsFirst" access="public" type="bool"  >
				<args/>
				<content filter="{transactional:False}">
					return _iter{toKey}-&gt;GetFirst{toKey}() == pRef{toKey};
				</content>
			</method>
			<method name="Check" access="public" type="void"  static="True">
				<args>
					<arg name="item" type="TO" ptr="True" />
				</args>
				<content filter="{transactional:False}">
				</content>
			</method>
			<method name="Check" access="public" type="void"  static="True">
				<args>
					<arg name="item" type="TO" ptr="True" />
					<arg name="newItem" type="TO" ptr="True" />
				</args>
				<content filter="{transactional:False}">
				</content>
			</method>
		</methods>
		<dtor virtual="True">
			<content filter="{transactional:False}"/>
		</dtor>
	</class>
  </classes>
</contents>
