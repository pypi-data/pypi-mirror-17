# Copyright (C) 2014/15 - Iraklis Diakos (hdiakos@outlook.com)
# Pilavidis Kriton (kriton_pilavidis@outlook.com)
# All Rights Reserved.
# You may use, distribute and modify this code under the
# terms of the ASF 2.0 license.
#

"""Part of the service module."""

# NOTE: unicode_literals causes problems when using instantiation with 'type'
# so use 'str' which is a no-op in Python 3.x and converts arguments properly
# in Python 2.x
# TODO: This is a nested daemon factory class. Maybe we can enhance it?
#       This is also known as CRTP: Curiously Recurring Template Pattern.
from __future__ import absolute_import
from __future__ import print_function
from __future__ import unicode_literals
from __future__ import generators
# Python native libraries.
from enum import Enum
import os
import io
import re
import imp
import inspect
import types
import errno
# Python 3rd party libraries.
import jinja2

import crapi.misc.Utils as Utils
from crapi.service.DaemonNamingError import DaemonNamingError
from crapi.service.DaemonContractError import DaemonContractError

__CLASS_NAME_PATTERN = re.compile(
    "^[_a-z][-a-z0-9_]{4,30}$",
    re.IGNORECASE
)

__IMPORT_NAME_PATTERN = re.compile(
    "import ^[-a-z0-9_\.]$",
    re.IGNORECASE
)


class ACTION(Enum):
    INSTALL = 'install'
    UPDATE = 'update'
    STOP = 'stop'
    DELETE = 'delete'


class WindowsDaemonFactory(object):

    """A class that allows creating templated Windows services."""


def __xor(a, b):
    return bool(a) ^ bool(b)


# Jinja2 custom template filters.
def py_indent(s, indent, lines, indent_first, same, maximum=False):
    source = s.splitlines()
    l = lines[0]    # Minimum
    lines = set(lines)
    space = ''
    if indent_first:
        if same:
            for i in range(indent):
                space += ' '
        else:
            for i in range(indent // 2):
                space += ' '
        source[0] = space + source[0]
    for line in source:
        space = ''
        if maximum:
            for i in range(indent):
                space += ' '
            source[l - 1] = space + source[l - 1]
            l += 1
        else:
            if l in lines:
                for i in range(indent):
                    space += ' '
                source[l - 1] = space + source[l - 1]
            l += 1
    return '\n'.join(source)


    #FIXME: Use unassociated attribute for users who do not wish to use our
    #       daemon library for daemon creation but want to control it instead.
    #FIXME: User imports should be handled too (decorator maybe?)
    # TODO: Use a decorator in the sense of annotation.
    #TODO: Use uuid and anonymous groups with dictionary lookups.
def instantiate(
    name='crapi', display_name='CRAPI: Common Range API',
    description='Dynamic runtime templating engine of system services.',
    timeout=0, action_policy=ACTION.UPDATE, action_file='.'
):

    """A class that enables implementation of Windows services."""

    class_name = name.replace('-', '_')
    r = __CLASS_NAME_PATTERN.match(class_name)
    if r is None:
        raise DaemonNamingError(
            'Windows service class names should start with an underscore '
            'or letter followed by alphanumerics or underscore. The '
            'minimum length of the service name should be 6 characters '
            'and the maximum should be 30 characters.',
            'name',
            class_name
        )
    template_class = 'WindowsDaemonTemplate.tmpl'
    class_docstring = '\n    =================================='
    class_docstring += '=========================================\n'
    class_docstring += '    This file is autogenerated. Do NOT modify!'
    class_docstring += '\n    =================================='
    class_docstring += '=========================================\n'
    class_docstring += '    Part of the service/rt (runtime) module.\n'

    top_frame = None
    for frame in inspect.stack():
        top_frame = frame[1]

    cwf = os.path.realpath(top_frame)
    cwd = os.path.dirname(cwf)

    # NOTE - Resolution rules:
    # File that calls user's daemon actions and is in '.':
    #   Resolve path of user file by assuming that action_file == name.
    # File that calls user's daemon actions and path is relative to caller:
    #   Resolve path of user file for given action_file.
    # In any case, created service will have class_name == name.
    if action_file == '.':
        action_md = imp.load_source(
            'crapi.service.rt.' + class_name,
            cwd + os.sep + class_name + '.py'
        )
    else:
        action_md = imp.load_source(
            'crapi.service.rt.' + action_file.split('\.py')[0],
            os.path.realpath(action_file)
        )

    if hasattr(action_md, class_name):
        action = getattr(action_md, class_name)
        indent = 0
        if not isinstance(action, type):
            raise DaemonContractError(
                'The action signature is not a class!',
                'action',
                type(action)
            )
    else:
        action = action_md
        indent = 4

    # Discover any user imports and filter them if we have already imported
    # them in our template.
    action_imports = map(
        lambda l: l.strip(),
        filter(
            lambda l: 'import' in l,
            inspect.getsourcelines(action_md)[0]
        )
    )
    action_imports = filter(
        lambda f: 'import win32events as w32ev' not in f and
                  'import win32file as w32f' not in f and
                  'import win32service as w32svc' not in f and
                  'import win32serviceutil as w32scu' not in f and
                  'import ntsecuritycon as ntsec' not in f and
                  'import pywintypes as WinT' not in f and
                  'import servicemanager as scm' not in f and
                  'from __future__ import absolute_import' not in f and
                  'from __future__ import print_function' not in f and
                  'from __future__ import unicode_literals' not in f and
                  'from __future__ import generators' not in f and
                  'import sys' not in f and
                  'import multiprocessing' not in f and
                  'import crapi.ipc.ServerPipe as ServerPipe' not in f and
                  not f.startswith('#'),
        action_imports
    )
    if not action_imports:
        action_imports = ''
    else:
        action_imports = '\n'.join('%s' % i for i in action_imports)

    action_init = None
    action_run = None
    action_advance = None
    action_bootstrap = 'def bootstrap(self): pass'
    action_preprocess = 'def preprocess(self): pass'
    action_postprocess = 'def postprocess(self): pass'
    action_cleanup = 'def cleanup(self): pass'
    if hasattr(action_md, class_name):
        if hasattr(action, '__init__'):
            if isinstance(action.__init__, types.MethodType):
                action_init = ''.join(
                    inspect.getsource(action.__init__).strip().splitlines(
                        True
                    )[1:]
                )
            # NOTE: Implicit object - slot-wrapper
    elif hasattr(action, 'init'):
        if not isinstance(action.init, types.FunctionType):
            raise DaemonContractError(
                'The init method signature is not a function!',
                'action.init',
                type(action.init)
            )
        else:
            action_init = ''.join(
                inspect.getsource(action.init).strip().splitlines(
                    True
                )[1:]
            )
    if hasattr(action, 'run'):
        if not __xor(
            isinstance(action.run, types.FunctionType),
            isinstance(action.run, types.MethodType)
        ):
            raise DaemonContractError(
                'The run method signature is not a function!',
                'action.run',
                type(action.run)
            )
        action_run = inspect.getsource(action.run).strip()
    else:
        if not hasattr(action, 'advance'):
            raise DaemonContractError(
                'One of the advance or run methods must be implemented!',
                'action.attributes',
                dir(action)
            )
        elif not __xor(
                isinstance(action.advance, types.FunctionType),
                isinstance(action.advance, types.MethodType)
        ):
                raise DaemonContractError(
                    'The advance method signature is not a function!',
                    'action.advance',
                    type(action.advance)
                )
        else:
            action_advance = inspect.getsource(action.advance).strip()
        if hasattr(action, 'bootstrap'):
            if not __xor(
                isinstance(action.bootstrap, types.FunctionType),
                isinstance(action.bootstrap, types.MethodType)
            ):
                raise DaemonContractError(
                    'The bootstrap method signature is not a function!',
                    'action.bootstrap',
                    type(action.bootstrap)
                )
            else:
                action_bootstrap = inspect.getsource(action.bootstrap).strip()
        if hasattr(action, 'preprocess'):
            if not __xor(
                isinstance(action.preprocess, types.FunctionType),
                isinstance(action.preprocess, types.MethodType)
            ):
                raise DaemonContractError(
                    'The preprocess method signature is not a function!',
                    'action.preprocess',
                    type(action.preprocess)
                )
            else:
                action_preprocess = inspect.getsource(
                    action.preprocess
                ).strip()
        if hasattr(action, 'postprocess'):
            if not __xor(
                isinstance(action.postprocess, types.FunctionType),
                isinstance(action.postprocess, types.MethodType)
            ):
                raise DaemonContractError(
                    'The postprocess method signature is not a function!',
                    'action.postprocess',
                    type(action.postprocess)
                )
            else:
                action_postprocess = inspect.getsource(
                    action.postprocess
                ).strip()
        if hasattr(action, 'cleanup'):
            if not __xor(
                isinstance(action.cleanup, types.FunctionType),
                isinstance(action.cleanup, types.MethodType)
            ):
                raise DaemonContractError(
                    'The cleanup method signature is not a function!',
                    'action.cleanup',
                    type(action.cleanup)
                )
            else:
                action_cleanup = inspect.getsource(action.cleanup).strip()

    # Boilerplate code time :P
    # Make sure that the service's python class file path is correctly set
    # since there is no __main__ entrypoint (BTW this is desirable).
    src_file = Utils.Environment.getSourceFilePath(name=__name__)
    src_file_no_ext = Utils.Environment.getSourceFilePath(
        name=__name__, extensionless=True
    )

    top_md = __name__.split('.')[0]
    proj_base_path = src_file_no_ext.split(top_md)[0]

    base_dir = os.sep.join(src_file.split(os.sep)[:-1])
    class_file = class_name + '.py'
    class_module = '.'.join(__name__.split('.')[:-1]) + '.rt.' + class_name

    dst_filepath = base_dir + os.sep + 'rt' + os.sep + class_file

    # NOTE: Workaround jinja2's weird caching behaviour :/
    try:
        os.remove(dst_filepath)
    except OSError, e:
        if e.errno != errno.ENOENT:
            raise
    tmpl_env = jinja2.Environment(
        loader=jinja2.PackageLoader(class_name, base_dir),
        trim_blocks=True,
        lstrip_blocks=True,
        keep_trailing_newline=True
    )
    tmpl_env.filters['py_indent'] = py_indent
    template_file = tmpl_env.get_template(template_class)

    if not os.path.isfile(dst_filepath) or action_policy == ACTION.UPDATE:
        with io.open(dst_filepath, 'w') as fdout:
            if action_run is None:
                if action_init is None:
                    print(
                        template_file.render(
                            class_docstring=class_docstring,
                            name=class_name,
                            display_name=display_name,
                            description=description,
                            timeout=timeout,
                            indent=indent,
                            action_imports=action_imports,
                            action_advance=action_advance,
                            action_bootstrap=action_bootstrap,
                            action_preprocess=action_preprocess,
                            action_postprocess=action_postprocess,
                            action_cleanup=action_cleanup
                        ),
                        file=fdout
                    )
                else:
                    print(
                        template_file.render(
                            class_docstring=class_docstring,
                            name=class_name,
                            display_name=display_name,
                            description=description,
                            timeout=timeout,
                            indent=indent,
                            action_imports=action_imports,
                            action_init=action_init,
                            action_advance=action_advance,
                            action_bootstrap=action_bootstrap,
                            action_preprocess=action_preprocess,
                            action_postprocess=action_postprocess,
                            action_cleanup=action_cleanup
                        ),
                        file=fdout
                    )
            else:
                if action_init is None:
                    print(
                        template_file.render(
                            class_docstring=class_docstring,
                            name=class_name,
                            display_name=display_name,
                            description=description,
                            timeout=timeout,
                            indent=indent,
                            action_imports=action_imports,
                            action_run=action_run
                        ),
                        file=fdout
                    )
                else:
                    print(
                        template_file.render(
                            class_docstring=class_docstring,
                            name=class_name,
                            display_name=display_name,
                            description=description,
                            timeout=timeout,
                            indent=indent,
                            action_imports=action_imports,
                            action_init=action_init,
                            action_run=action_run
                        ),
                        file=fdout
                    )

    return (class_module, proj_base_path + class_module + '.' + class_name)
