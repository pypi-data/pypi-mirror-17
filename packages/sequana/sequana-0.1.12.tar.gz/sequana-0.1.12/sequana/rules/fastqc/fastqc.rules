import glob

__sequana__fastqc = [":options"]
import sequana.snaketools as sm
cfg = sm.SequanaConfig.from_dict(config)


# should be called after bwa_mem and bwa_bam


def fastqc_dynamic(name, inputs, outputs=[]):

    metadata = {'inputs':inputs, 'name':name, 'project':cfg.PROJECT}

    fastqc_code = '''

rule fastqc__%(name)s:
    """Calls FastQC on input data sets """
    # we could have a dynamic search or based on config file
    input:
        %(inputs)s
    output:
        touch('fastqc__%(name)s/fastqc.done')
    params:
        wkdir="fastqc__%(name)s",
        kargs = cfg.config.fastqc.options
    threads: 4
    log:
        "logs/fastqc__%(name)s.log"
    run:
        # if the content of the file is empty, this will fail. We need to
        # touch  a file in such case.
        #
        from sequana import snaketools as sm
        from sequana import FastQ
        newinput = []
        for i, this in enumerate(input):
            fastq = FastQ(this)
            # TODO: could just try to iterate once instead of computing the length
            if len(fastq) != 0:
                newinput.append(this)
            else:
                pass

        if len(newinput):
            shell(
            " fastqc -t {threads} --outdir {params.wkdir} -f fastq "
            " {newinput} {params.kargs} > {log}")
        else:
            pass

        # report
        from sequana import FastQCReport
        s = FastQCReport(
                "fastqc__%(name)s",
                output_filename="fastqc__%(name)s.html",
                directory=params.wkdir)
        s.jinja['main_link'] = '../summary.html'
        s.create_report()



    '''

    from easydev import TempFile
    tt = TempFile()
    fh = open(tt.name, "w")
    fh.write(fastqc_code % metadata)
    fh.close()
    return fh.name






